{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"LICENSE/","title":"LICENSE","text":"<p>Attribution 4.0 International</p> <p>=======================================================================</p> <p>Creative Commons Corporation (\"Creative Commons\") is not a law firm and does not provide legal services or legal advice. Distribution of Creative Commons public licenses does not create a lawyer-client or other relationship. Creative Commons makes its licenses and related information available on an \"as-is\" basis. Creative Commons gives no warranties regarding its licenses, any material licensed under their terms and conditions, or any related information. Creative Commons disclaims all liability for damages resulting from their use to the fullest extent possible.</p> <p>Using Creative Commons Public Licenses</p> <p>Creative Commons public licenses provide a standard set of terms and conditions that creators and other rights holders may use to share original works of authorship and other material subject to copyright and certain other rights specified in the public license below. The following considerations are for informational purposes only, are not exhaustive, and do not form part of our licenses.</p> <pre><code> Considerations for licensors: Our public licenses are\n intended for use by those authorized to give the public\n permission to use material in ways otherwise restricted by\n copyright and certain other rights. Our licenses are\n irrevocable. Licensors should read and understand the terms\n and conditions of the license they choose before applying it.\n Licensors should also secure all rights necessary before\n applying our licenses so that the public can reuse the\n material as expected. Licensors should clearly mark any\n material not subject to the license. This includes other CC-\n licensed material, or material used under an exception or\n limitation to copyright. More considerations for licensors:\nwiki.creativecommons.org/Considerations_for_licensors\n\n Considerations for the public: By using one of our public\n licenses, a licensor grants the public permission to use the\n licensed material under specified terms and conditions. If\n the licensor's permission is not necessary for any reason--for\n example, because of any applicable exception or limitation to\n copyright--then that use is not regulated by the license. Our\n licenses grant only permissions under copyright and certain\n other rights that a licensor has authority to grant. Use of\n the licensed material may still be restricted for other\n reasons, including because others have copyright or other\n rights in the material. A licensor may make special requests,\n such as asking that all changes be marked or described.\n Although not required by our licenses, you are encouraged to\n respect those requests where reasonable. More_considerations\n for the public:\nwiki.creativecommons.org/Considerations_for_licensees\n</code></pre> <p>=======================================================================</p> <p>Creative Commons Attribution 4.0 International Public License</p> <p>By exercising the Licensed Rights (defined below), You accept and agree to be bound by the terms and conditions of this Creative Commons Attribution 4.0 International Public License (\"Public License\"). To the extent this Public License may be interpreted as a contract, You are granted the Licensed Rights in consideration of Your acceptance of these terms and conditions, and the Licensor grants You such rights in consideration of benefits the Licensor receives from making the Licensed Material available under these terms and conditions.</p> <p>Section 1 -- Definitions.</p> <p>a. Adapted Material means material subject to Copyright and Similar      Rights that is derived from or based upon the Licensed Material      and in which the Licensed Material is translated, altered,      arranged, transformed, or otherwise modified in a manner requiring      permission under the Copyright and Similar Rights held by the      Licensor. For purposes of this Public License, where the Licensed      Material is a musical work, performance, or sound recording,      Adapted Material is always produced where the Licensed Material is      synched in timed relation with a moving image.</p> <p>b. Adapter's License means the license You apply to Your Copyright      and Similar Rights in Your contributions to Adapted Material in      accordance with the terms and conditions of this Public License.</p> <p>c. Copyright and Similar Rights means copyright and/or similar rights      closely related to copyright including, without limitation,      performance, broadcast, sound recording, and Sui Generis Database      Rights, without regard to how the rights are labeled or      categorized. For purposes of this Public License, the rights      specified in Section 2(b)(1)-(2) are not Copyright and Similar      Rights.</p> <p>d. Effective Technological Measures means those measures that, in the      absence of proper authority, may not be circumvented under laws      fulfilling obligations under Article 11 of the WIPO Copyright      Treaty adopted on December 20, 1996, and/or similar international      agreements.</p> <p>e. Exceptions and Limitations means fair use, fair dealing, and/or      any other exception or limitation to Copyright and Similar Rights      that applies to Your use of the Licensed Material.</p> <p>f. Licensed Material means the artistic or literary work, database,      or other material to which the Licensor applied this Public      License.</p> <p>g. Licensed Rights means the rights granted to You subject to the      terms and conditions of this Public License, which are limited to      all Copyright and Similar Rights that apply to Your use of the      Licensed Material and that the Licensor has authority to license.</p> <p>h. Licensor means the individual(s) or entity(ies) granting rights      under this Public License.</p> <p>i. Share means to provide material to the public by any means or      process that requires permission under the Licensed Rights, such      as reproduction, public display, public performance, distribution,      dissemination, communication, or importation, and to make material      available to the public including in ways that members of the      public may access the material from a place and at a time      individually chosen by them.</p> <p>j. Sui Generis Database Rights means rights other than copyright      resulting from Directive 96/9/EC of the European Parliament and of      the Council of 11 March 1996 on the legal protection of databases,      as amended and/or succeeded, as well as other essentially      equivalent rights anywhere in the world.</p> <p>k. You means the individual or entity exercising the Licensed Rights      under this Public License. Your has a corresponding meaning.</p> <p>Section 2 -- Scope.</p> <p>a. License grant.</p> <pre><code>   1. Subject to the terms and conditions of this Public License,\n      the Licensor hereby grants You a worldwide, royalty-free,\n      non-sublicensable, non-exclusive, irrevocable license to\n      exercise the Licensed Rights in the Licensed Material to:\n\n        a. reproduce and Share the Licensed Material, in whole or\n           in part; and\n\n        b. produce, reproduce, and Share Adapted Material.\n\n   2. Exceptions and Limitations. For the avoidance of doubt, where\n      Exceptions and Limitations apply to Your use, this Public\n      License does not apply, and You do not need to comply with\n      its terms and conditions.\n\n   3. Term. The term of this Public License is specified in Section\n      6(a).\n\n   4. Media and formats; technical modifications allowed. The\n      Licensor authorizes You to exercise the Licensed Rights in\n      all media and formats whether now known or hereafter created,\n      and to make technical modifications necessary to do so. The\n      Licensor waives and/or agrees not to assert any right or\n      authority to forbid You from making technical modifications\n      necessary to exercise the Licensed Rights, including\n      technical modifications necessary to circumvent Effective\n      Technological Measures. For purposes of this Public License,\n      simply making modifications authorized by this Section 2(a)\n      (4) never produces Adapted Material.\n\n   5. Downstream recipients.\n\n        a. Offer from the Licensor -- Licensed Material. Every\n           recipient of the Licensed Material automatically\n           receives an offer from the Licensor to exercise the\n           Licensed Rights under the terms and conditions of this\n           Public License.\n\n        b. No downstream restrictions. You may not offer or impose\n           any additional or different terms or conditions on, or\n           apply any Effective Technological Measures to, the\n           Licensed Material if doing so restricts exercise of the\n           Licensed Rights by any recipient of the Licensed\n           Material.\n\n   6. No endorsement. Nothing in this Public License constitutes or\n      may be construed as permission to assert or imply that You\n      are, or that Your use of the Licensed Material is, connected\n      with, or sponsored, endorsed, or granted official status by,\n      the Licensor or others designated to receive attribution as\n      provided in Section 3(a)(1)(A)(i).\n</code></pre> <p>b. Other rights.</p> <pre><code>   1. Moral rights, such as the right of integrity, are not\n      licensed under this Public License, nor are publicity,\n      privacy, and/or other similar personality rights; however, to\n      the extent possible, the Licensor waives and/or agrees not to\n      assert any such rights held by the Licensor to the limited\n      extent necessary to allow You to exercise the Licensed\n      Rights, but not otherwise.\n\n   2. Patent and trademark rights are not licensed under this\n      Public License.\n\n   3. To the extent possible, the Licensor waives any right to\n      collect royalties from You for the exercise of the Licensed\n      Rights, whether directly or through a collecting society\n      under any voluntary or waivable statutory or compulsory\n      licensing scheme. In all other cases the Licensor expressly\n      reserves any right to collect such royalties.\n</code></pre> <p>Section 3 -- License Conditions.</p> <p>Your exercise of the Licensed Rights is expressly made subject to the following conditions.</p> <p>a. Attribution.</p> <pre><code>   1. If You Share the Licensed Material (including in modified\n      form), You must:\n\n        a. retain the following if it is supplied by the Licensor\n           with the Licensed Material:\n\n             i. identification of the creator(s) of the Licensed\n                Material and any others designated to receive\n                attribution, in any reasonable manner requested by\n                the Licensor (including by pseudonym if\n                designated);\n\n            ii. a copyright notice;\n\n           iii. a notice that refers to this Public License;\n\n            iv. a notice that refers to the disclaimer of\n                warranties;\n\n             v. a URI or hyperlink to the Licensed Material to the\n                extent reasonably practicable;\n\n        b. indicate if You modified the Licensed Material and\n           retain an indication of any previous modifications; and\n\n        c. indicate the Licensed Material is licensed under this\n           Public License, and include the text of, or the URI or\n           hyperlink to, this Public License.\n\n   2. You may satisfy the conditions in Section 3(a)(1) in any\n      reasonable manner based on the medium, means, and context in\n      which You Share the Licensed Material. For example, it may be\n      reasonable to satisfy the conditions by providing a URI or\n      hyperlink to a resource that includes the required\n      information.\n\n   3. If requested by the Licensor, You must remove any of the\n      information required by Section 3(a)(1)(A) to the extent\n      reasonably practicable.\n\n   4. If You Share Adapted Material You produce, the Adapter's\n      License You apply must not prevent recipients of the Adapted\n      Material from complying with this Public License.\n</code></pre> <p>Section 4 -- Sui Generis Database Rights.</p> <p>Where the Licensed Rights include Sui Generis Database Rights that apply to Your use of the Licensed Material:</p> <p>a. for the avoidance of doubt, Section 2(a)(1) grants You the right      to extract, reuse, reproduce, and Share all or a substantial      portion of the contents of the database;</p> <p>b. if You include all or a substantial portion of the database      contents in a database in which You have Sui Generis Database      Rights, then the database in which You have Sui Generis Database      Rights (but not its individual contents) is Adapted Material; and</p> <p>c. You must comply with the conditions in Section 3(a) if You Share      all or a substantial portion of the contents of the database.</p> <p>For the avoidance of doubt, this Section 4 supplements and does not replace Your obligations under this Public License where the Licensed Rights include other Copyright and Similar Rights.</p> <p>Section 5 -- Disclaimer of Warranties and Limitation of Liability.</p> <p>a. UNLESS OTHERWISE SEPARATELY UNDERTAKEN BY THE LICENSOR, TO THE      EXTENT POSSIBLE, THE LICENSOR OFFERS THE LICENSED MATERIAL AS-IS      AND AS-AVAILABLE, AND MAKES NO REPRESENTATIONS OR WARRANTIES OF      ANY KIND CONCERNING THE LICENSED MATERIAL, WHETHER EXPRESS,      IMPLIED, STATUTORY, OR OTHER. THIS INCLUDES, WITHOUT LIMITATION,      WARRANTIES OF TITLE, MERCHANTABILITY, FITNESS FOR A PARTICULAR      PURPOSE, NON-INFRINGEMENT, ABSENCE OF LATENT OR OTHER DEFECTS,      ACCURACY, OR THE PRESENCE OR ABSENCE OF ERRORS, WHETHER OR NOT      KNOWN OR DISCOVERABLE. WHERE DISCLAIMERS OF WARRANTIES ARE NOT      ALLOWED IN FULL OR IN PART, THIS DISCLAIMER MAY NOT APPLY TO YOU.</p> <p>b. TO THE EXTENT POSSIBLE, IN NO EVENT WILL THE LICENSOR BE LIABLE      TO YOU ON ANY LEGAL THEORY (INCLUDING, WITHOUT LIMITATION,      NEGLIGENCE) OR OTHERWISE FOR ANY DIRECT, SPECIAL, INDIRECT,      INCIDENTAL, CONSEQUENTIAL, PUNITIVE, EXEMPLARY, OR OTHER LOSSES,      COSTS, EXPENSES, OR DAMAGES ARISING OUT OF THIS PUBLIC LICENSE OR      USE OF THE LICENSED MATERIAL, EVEN IF THE LICENSOR HAS BEEN      ADVISED OF THE POSSIBILITY OF SUCH LOSSES, COSTS, EXPENSES, OR      DAMAGES. WHERE A LIMITATION OF LIABILITY IS NOT ALLOWED IN FULL OR      IN PART, THIS LIMITATION MAY NOT APPLY TO YOU.</p> <p>c. The disclaimer of warranties and limitation of liability provided      above shall be interpreted in a manner that, to the extent      possible, most closely approximates an absolute disclaimer and      waiver of all liability.</p> <p>Section 6 -- Term and Termination.</p> <p>a. This Public License applies for the term of the Copyright and      Similar Rights licensed here. However, if You fail to comply with      this Public License, then Your rights under this Public License      terminate automatically.</p> <p>b. Where Your right to use the Licensed Material has terminated under      Section 6(a), it reinstates:</p> <pre><code>   1. automatically as of the date the violation is cured, provided\n      it is cured within 30 days of Your discovery of the\n      violation; or\n\n   2. upon express reinstatement by the Licensor.\n\n For the avoidance of doubt, this Section 6(b) does not affect any\n right the Licensor may have to seek remedies for Your violations\n of this Public License.\n</code></pre> <p>c. For the avoidance of doubt, the Licensor may also offer the      Licensed Material under separate terms or conditions or stop      distributing the Licensed Material at any time; however, doing so      will not terminate this Public License.</p> <p>d. Sections 1, 5, 6, 7, and 8 survive termination of this Public      License.</p> <p>Section 7 -- Other Terms and Conditions.</p> <p>a. The Licensor shall not be bound by any additional or different      terms or conditions communicated by You unless expressly agreed.</p> <p>b. Any arrangements, understandings, or agreements regarding the      Licensed Material not stated herein are separate from and      independent of the terms and conditions of this Public License.</p> <p>Section 8 -- Interpretation.</p> <p>a. For the avoidance of doubt, this Public License does not, and      shall not be interpreted to, reduce, limit, restrict, or impose      conditions on any use of the Licensed Material that could lawfully      be made without permission under this Public License.</p> <p>b. To the extent possible, if any provision of this Public License is      deemed unenforceable, it shall be automatically reformed to the      minimum extent necessary to make it enforceable. If the provision      cannot be reformed, it shall be severed from this Public License      without affecting the enforceability of the remaining terms and      conditions.</p> <p>c. No term or condition of this Public License will be waived and no      failure to comply consented to unless expressly agreed to by the      Licensor.</p> <p>d. Nothing in this Public License constitutes or may be interpreted      as a limitation upon, or waiver of, any privileges and immunities      that apply to the Licensor or You, including from the legal      processes of any jurisdiction or authority.</p> <p>=======================================================================</p> <p>Creative Commons is not a party to its public licenses. Notwithstanding, Creative Commons may elect to apply one of its public licenses to material it publishes and in those instances will be considered the \u201cLicensor.\u201d The text of the Creative Commons public licenses is dedicated to the public domain under the CC0 Public Domain Dedication. Except for the limited purpose of indicating that material is shared under a Creative Commons public license or as otherwise permitted by the Creative Commons policies published at creativecommons.org/policies, Creative Commons does not authorize the use of the trademark \"Creative Commons\" or any other trademark or logo of Creative Commons without its prior written consent including, without limitation, in connection with any unauthorized modifications to any of its public licenses or any other arrangements, understandings, or agreements concerning use of licensed material. For the avoidance of doubt, this paragraph does not form part of the public licenses.</p> <p>Creative Commons may be contacted at creativecommons.org</p>"},{"location":"develop/","title":"Develop","text":"<p>Explore and learn how to build in the Polkadot ecosystem, from a custom parachain to smart contracts, supported by robust integrations and developer tools.</p>"},{"location":"develop/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"develop/development-pathways/","title":"Development Pathways","text":""},{"location":"develop/development-pathways/#introduction","title":"Introduction","text":"<p>Developers can choose from different development pathways to build applications and core blockchain functionality. Each pathway caters to different types of projects and developer skill sets, while complementing one another within the broader network.</p> <p>The Polkadot ecosystem provides multiple development pathways:</p> <pre><code>graph TD\n    A[Development Pathways]\n    A --&gt; B[Smart Contract Development]\n    A --&gt; C[Parachain Development]\n    A --&gt; D[Client-Side Development]</code></pre>"},{"location":"develop/development-pathways/#smart-contract-development","title":"Smart Contract Development","text":"<p>Smart contracts are sandboxed programs that run within a virtual machine on the blockchain. These deterministic pieces of code are deployed at specific blockchain addresses and execute predefined logic when triggered by transactions. Because they run in an isolated environment, they provide enhanced security and predictable execution. Smart contracts can be deployed permissionlessly, allowing any developer to create and launch applications without requiring special access or permissions. They enable developers to create trustless applications by encoding rules, conditions, and state transitions that leverage the security and transparency of the underlying blockchain.</p> <p>Some key benefits of developing smart contracts include ease of development, faster time to market, and permissionless deployment. Smart contracts allow developers to quickly build and deploy decentralized applications without complex infrastructure or intermediaries. This accelerates the development lifecycle and enables rapid innovation within the Polkadot ecosystem.</p> <p>For more information on developing smart contracts in the Polkadot ecosystem, check the Smart Contracts section.</p>"},{"location":"develop/development-pathways/#parachain-development","title":"Parachain Development","text":"<p>Runtimes are the core building blocks that define the logic and functionality of Polkadot SDK-based parachains. Developers can customize and extend the features of their blockchain, allowing for tighter integration with critical network tasks such as block production, consensus mechanisms, and governance processes.</p> <p>Runtimes can be upgraded through forkless runtime updates, enabling seamless evolution of the parachain without disrupting existing functionality.</p> <p>Developers can define the parameters, rules, and behaviors that shape their blockchain network. This includes token economics, transaction fees, permissions, and more. Using the Polkadot SDK, teams can iterate on their blockchain designs, experiment with new features, and deploy highly specialized networks tailored to their specific use cases.</p> <p>For those interested in delving deeper into runtime development, explore the dedicated Customize Your Parachain section.</p>"},{"location":"develop/development-pathways/#client-side-development","title":"Client-Side Development","text":"<p>The client-side development path is dedicated to building applications that interact with Polkadot SDK-based blockchains and enhance user engagement with the network. While decentralized applications (dApps) are a significant focus, this pathway also includes developing other tools and interfaces that expand users' interactions with blockchain data and services.</p> <p>Client-side developers can build:</p> <ul> <li> <p>Decentralized applications (dApps) - these applications leverage the blockchain's smart contracts or runtimes to offer a wide range of features, from financial services to gaming and social applications, all accessible directly by end-users</p> </li> <li> <p>Command-line interfaces (CLIs) - CLI tools empower developers and technical users to interact with the blockchain programmatically. These tools enable tasks like querying the blockchain, deploying smart contracts, managing wallets, and monitoring network status</p> </li> <li> <p>Data analytics and visualization tools - developers can create tools that aggregate, analyze, and visualize on-chain data to help users and businesses understand trends, track transactions, and gain insights into the network's health and usage</p> </li> <li> <p>Wallets - securely managing accounts and private keys is crucial for blockchain users. Client-side development includes building user-friendly wallets, account management tools, and extensions that integrate seamlessly with the ecosystem</p> </li> <li> <p>Explorers and dashboards -  blockchain explorers allow users to view and search on-chain data, including blocks, transactions, and accounts. Dashboards provide a more interactive interface for users to monitor critical metrics, such as staking rewards, governance proposals, and network performance</p> </li> </ul> <p>These applications can leverage the Polkadot blockchain's underlying protocol features to create solutions that allow users to interact with the ecosystem. The Client-side development pathway is ideal for developers interested in enhancing user experiences and building applications that bring the power of decentralized networks to a broader audience.</p> <p>Check the API Libraries section for essential tools to interact with Polkadot SDK-based blockchain data and protocol features.</p>"},{"location":"develop/networks/","title":"Networks","text":""},{"location":"develop/networks/#introduction","title":"Introduction","text":"<p>The Polkadot ecosystem consists of multiple networks designed to support different stages of blockchain development, from main networks to test networks. Each network serves a unique purpose, providing developers with flexible environments for building, testing, and deploying blockchain applications.</p> <p>This section includes essential network information such as RPC endpoints, currency symbols and decimals, and how to acquire TestNet tokens for the Polkadot ecosystem of networks.</p>"},{"location":"develop/networks/#production-networks","title":"Production Networks","text":""},{"location":"develop/networks/#polkadot","title":"Polkadot","text":"<p>Polkadot is the primary production blockchain network for high-stakes, enterprise-grade applications. Polkadot MainNet has been running since May 2020 and has implementations in various programming languages ranging from Rust to JavaScript.</p> Network DetailsRPC Endpoints <p>Currency symbol - <code>DOT</code></p> <p>Currency decimals - 10</p> <p>Block explorer - Polkadot Subscan</p> <p>Blockops <pre><code>wss://polkadot-public-rpc.blockops.network/ws\n</code></pre></p> <p>Dwellir <pre><code>wss://polkadot-rpc.dwellir.com\n</code></pre></p> <p>Dwellir Tunisia <pre><code>wss://polkadot-rpc-tn.dwellir.com\n</code></pre></p> <p>IBP1 <pre><code>wss://rpc.ibp.network/polkadot\n</code></pre></p> <p>IBP2 <pre><code>wss://polkadot.dotters.network\n</code></pre></p> <p>LuckyFriday <pre><code>wss://rpc-polkadot.luckyfriday.io\n</code></pre></p> <p>OnFinality <pre><code>wss://polkadot.api.onfinality.io/public-ws\n</code></pre></p> <p>RadiumBlock <pre><code>wss://polkadot.public.curie.radiumblock.co/ws\n</code></pre></p> <p>RockX <pre><code>wss://rockx-dot.w3node.com/polka-public-dot/ws\n</code></pre></p> <p>Stakeworld <pre><code>wss://dot-rpc.stakeworld.io\n</code></pre></p> <p>SubQuery <pre><code>wss://polkadot.rpc.subquery.network/public/ws\n</code></pre></p> <p>Light client <pre><code>light://substrate-connect/polkadot\n</code></pre></p>"},{"location":"develop/networks/#kusama","title":"Kusama","text":"<p>Kusama is a network built as a risk-taking, fast-moving \"canary in the coal mine\" for its cousin Polkadot. As it is built on top of the same infrastructure, Kusama often acts as a final testing ground for new features before they are launched on Polkadot. Unlike true TestNets, however, the Kusama KSM native token does have economic value. This incentive encourages paricipants to maintain this robust and performant structure for the benefit of the community.</p> Network DetailsRPC Endpoints <p>Currency symbol - <code>KSM</code></p> <p>Currency decimals - 12</p> <p>Block explorer - Kusama Subscan</p> <p>Dwellir <pre><code>wss://kusama-rpc.dwellir.com\n</code></pre></p> <p>Dwellir Tunisia <pre><code>wss://kusama-rpc-tn.dwellir.com\n</code></pre></p> <p>IBP1 <pre><code>wss://rpc.ibp.network/kusama\n</code></pre></p> <p>IBP2 <pre><code>wss://kusama.dotters.network\n</code></pre></p> <p>LuckyFriday <pre><code>wss://rpc-kusama.luckyfriday.io\n</code></pre></p> <p>OnFinality <pre><code>wss://kusama.api.onfinality.io/public-ws\n</code></pre></p> <p>RadiumBlock <pre><code>wss://kusama.public.curie.radiumblock.co/ws\n</code></pre></p> <p>RockX <pre><code>wss://rockx-ksm.w3node.com/polka-public-ksm/ws\n</code></pre></p> <p>Stakeworld <pre><code>wss://rockx-ksm.w3node.com/polka-public-ksm/ws\n</code></pre></p> <p>Light client <pre><code>light://substrate-connect/kusama\n</code></pre></p>"},{"location":"develop/networks/#test-networks","title":"Test Networks","text":""},{"location":"develop/networks/#westend","title":"Westend","text":"<p>Westend is the primary test network that mirrors Polkadot's functionality for protocol-level feature development. As a true TestNet, the WND native token intentionally does not have any economic value. Use the faucet information in the following section to obtain WND tokens.</p> Network InformationRPC Endpoints <p>Currency symbol - <code>WND</code></p> <p>Currency decimals - 12</p> <p>Block explorer - Westend Subscan</p> <p>Faucet - Official Westend faucet</p> <p>Dwellir <pre><code>wss://westend-rpc.dwellir.com\n</code></pre></p> <p>Dwellir Tunisia <pre><code>wss://westend-rpc-tn.dwellir.com\n</code></pre></p> <p>IBP1 <pre><code>wss://rpc.ibp.network/westend\n</code></pre></p> <p>IBP2 <pre><code>wss://westend.dotters.network\n</code></pre></p> <p>OnFinality <pre><code>wss://westend.api.onfinality.io/public-ws\n</code></pre></p> <p>Parity <pre><code>wss://westend-rpc.polkadot.io\n</code></pre></p> <p>Light client <pre><code>light://substrate-connect/westend\n</code></pre></p>"},{"location":"develop/networks/#paseo","title":"Paseo","text":"<p>Paseo is a decentralised, community run, stable testnet for parachain and dapp developers to build and test their applications. Unlike Westend, Paseo is not intended for protocol-level testing. As a true TestNet, the PAS native token intentionally does not have any economic value. Use the faucet information in the following section to obtain PAS tokens.</p> Network InformationRPC Endpoints <p>RPC URL <pre><code>wss://paseo.rpc.amforc.com\n</code></pre></p> <p>Currency symbol - <code>PAS</code></p> <p>Currency decimals - 10</p> <p>Block explorer - Paseo Subscan</p> <p>Faucet - Official Paseo faucet</p> <p>Amforc <pre><code>wss://paseo.rpc.amforc.com\n</code></pre></p> <p>Dwellir <pre><code>wss://paseo-rpc.dwellir.com\n</code></pre></p> <p>IBP1 <pre><code>wss://rpc.ibp.network/paseo\n</code></pre></p> <p>IBP2 <pre><code>wss://paseo.dotters.network\n</code></pre></p> <p>StakeWorld <pre><code>wss://pas-rpc.stakeworld.io\n</code></pre></p>"},{"location":"develop/networks/#additional-resources","title":"Additional Resources","text":"<ul> <li>Polkadot Fellowship runtimes repository - find a collection of runtimes for Polkadot, Kusama, and their system-parachains as maintained by the community via the Polkadot Technical Fellowship</li> </ul>"},{"location":"develop/interoperability/","title":"Interoperability","text":"<p>Learn how Polkadot enables blockchain interoperability through XCM (Cross-Consensus Messaging), powering secure cross-chain communication.</p>"},{"location":"develop/interoperability/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"develop/interoperability/intro-to-xcm/","title":"Introduction to XCM","text":""},{"location":"develop/interoperability/intro-to-xcm/#introduction","title":"Introduction","text":"<p>Polkadot\u2019s unique value lies in its ability to enable interoperability between parachains and other blockchain systems. At the core of this capability is XCM (Cross-Consensus Messaging)\u2014a flexible messaging format that facilitates communication and collaboration between independent consensus systems.</p> <p>With XCM, one chain can send intents to another one, fostering a more interconnected ecosystem. Although it was developed specifically for Polkadot, XCM is a universal format, usable in any blockchain environment. This guide provides an overview of XCM\u2019s core principles, design, and functionality, alongside practical examples of its implementation.</p>"},{"location":"develop/interoperability/intro-to-xcm/#messaging-format","title":"Messaging Format","text":"<p>XCM is not a protocol but a standardized messaging format. It defines the structure and behavior of messages but does not handle their delivery. This separation allows developers to focus on crafting instructions for target systems without worrying about transmission mechanics.</p> <p>XCM messages are intent-driven, outlining desired actions for the receiving blockchain to consider and potentially alter its state. These messages do not directly execute changes; instead, they rely on the host chain's environment to interpret and implement them. By utilizing asynchronous composability, XCM facilitates efficient execution where messages can be processed independently of their original order, similar to how RESTful services handle HTTP requests without requiring sequential processing.</p>"},{"location":"develop/interoperability/intro-to-xcm/#the-four-principles-of-xcm","title":"The Four Principles of XCM","text":"<p>XCM adheres to four guiding principles that ensure robust and reliable communication across consensus systems:</p> <ul> <li>Asynchronous - XCM messages operate independently of sender acknowledgment, avoiding delays due to blocked processes</li> <li>Absolute - XCM messages are guaranteed to be delivered and interpreted accurately, in order, and timely. Once a message is sent, one can be sure it will be processed as intended</li> <li>Asymmetric - XCM messages follow the 'fire and forget' paradigm meaning no automatic feedback is provided to the sender. Any results must be communicated separately to the sender with an additional message back to the origin</li> <li>Agnostic - XCM operates independently of the specific consensus mechanisms, making it compatible across diverse systems</li> </ul> <p>These principles guarantee that XCM provides a reliable framework for cross-chain communication, even in complex environments.</p>"},{"location":"develop/interoperability/intro-to-xcm/#the-xcm-tech-stack","title":"The XCM Tech Stack","text":"<p>The XCM tech stack is designed to faciliate seamless interoperable communication between chains that reside within the Polkadot ecosystem. XCM can be used to ecpress the meaning of the messages over each of the communicatio channels.</p>"},{"location":"develop/interoperability/intro-to-xcm/#core-functionalities-of-xcm","title":"Core Functionalities of XCM","text":"<p>XCM enhances cross-consensus communication by introducing several powerful features:</p> <ul> <li>Programmability - supports dynamic message handling, allowing for more comprehensive use cases. Includes branching logic, safe dispatches for version checks, and asset operations like NFT management</li> <li>Functional Multichain Decomposition - enables mechanisms such as remote asset locking, asset namespacing, and inter-chain state referencing, with contextual message identification </li> <li>Bridging - establishes a universal reference framework for multi-hop setups, connecting disparate systems like Ethereum and Bitcoin with the Polkadot relay chain acting as a universal location</li> </ul> <p>The standardized format for messages allows parachains to handle tasks like user balances, governance, and staking, freeing the Polkadot relay chain to focus on shared security. These features make XCM indispensable for implementing scalable and interoperable blockchain applications. </p>"},{"location":"develop/interoperability/intro-to-xcm/#xcm-example","title":"XCM Example","text":"<p>The following is a simplified XCM message demonstrating a token transfer from Alice to Bob on the same chain (ParaA).</p> <pre><code>let message = Xcm(vec![\n    WithdrawAsset((Here, amount).into()),\n    BuyExecution { \n        fees: (Here, amount).into(), \n        weight_limit: WeightLimit::Unlimited \n    },\n    DepositAsset {\n        assets: All.into(),\n        beneficiary: MultiLocation {\n            parents: 0,\n            interior: Junction::AccountId32 {\n                network: None,\n                id: BOB.clone().into()\n            }.into(),\n        }.into()\n    }\n]);\n</code></pre> <p>The message consists of three instructions described as follows:</p> <ul> <li> <p>WithdrawAsset - transfers a specified number of tokens from Alice's account to a holding register <pre><code>WithdrawAsset((Here, amount).into()),\n</code></pre></p> <ul> <li><code>Here</code> - the native parachain token</li> <li><code>amount</code> - the number of tokens that are transferred</li> </ul> <p>The first instruction takes as an input the MultiAsset that should be withdrawn. The MultiAsset describes the native parachain token with the <code>Here</code> keyword. The <code>amount</code> parameter is the number of tokens that are transferred. The withdrawal account depends on the origin of the message. In this example the origin of the message is Alice. The <code>WithdrawAsset</code> instruction moves <code>amount</code> number of native tokens from Alice's account into the holding register.</p> </li> <li> <p>BuyExecution - allocates fees to cover the execution weight of the XCM instructions <pre><code>BuyExecution { \n    fees: (Here, amount).into(), \n    weight_limit: WeightLimit::Unlimited \n},\n</code></pre></p> <ul> <li><code>fees</code> - describes the asset in the holding register that should be used to pay for the weight </li> <li><code>weight_limit</code> - defines the maximum fees that can be used to buy weight</li> </ul> </li> <li> <p>DepositAsset - moves the remaining tokens from the holding register to Bob\u2019s account <pre><code>DepositAsset {\n    assets: All.into(),\n    beneficiary: MultiLocation {\n        parents: 0,\n        interior: Junction::AccountId32 {\n            network: None,\n            id: BOB.clone().into()\n        }.into(),\n    }.into()\n}\n</code></pre></p> <ul> <li><code>All</code> - the wildcard for the asset(s) to be deposited. In this case, all assets in the holding register should be deposited</li> </ul> </li> </ul> <p>This step-by-step process showcases how XCM enables precise state changes within a blockchain system. You can find a complete XCM message example in the XCM repository.</p>"},{"location":"develop/interoperability/intro-to-xcm/#overview","title":"Overview","text":"<p>XCM revolutionizes cross-chain communication by enabling use cases such as:</p> <ul> <li>Token transfers between blockchains</li> <li>Asset locking for cross-chain smart contract interactions</li> <li>Remote execution of functions on other blockchains</li> </ul> <p>These functionalities empower developers to build innovative, multi-chain applications, leveraging the strengths of various blockchain networks. To stay updated on XCM\u2019s evolving format or contribute, visit the XCM repository.</p>"},{"location":"develop/interoperability/send-messages/","title":"Send XCM Messages","text":""},{"location":"develop/interoperability/send-messages/#introduction","title":"Introduction","text":"<p>One of the core FRAME pallets that enables parachains to engage in cross-chain communication using the Cross-Consensus Message (XCM) format is <code>pallet-xcm</code>. It facilitates the sending, execution, and management of XCM messages, thereby allowing parachains to interact with other chains within the ecosystem. Additionally, <code>pallet-xcm</code>, also referred to as the XCM pallet, supports essential operations like asset transfers, version negotiation, and message routing.</p> <p>This page provides a detailed overview of the XCM pallet's key features, its primary roles in XCM operations, and the main extrinsics it offers. Whether aiming to execute XCM messages locally or send them to external chains, this guide covers the foundational concepts and practical applications you need to know.</p>"},{"location":"develop/interoperability/send-messages/#xcm-frame-pallet-overview","title":"XCM Frame Pallet Overview","text":"<p>The <code>pallet-xcm</code> provides a set of pre-defined, commonly used XCVM programs in the form of a set of extrinsics.</p> <p>This pallet provides some default implementations for traits required by <code>XcmConfig</code>. The XCM executor is also included as an associated type within the pallet's configuration.</p> <p>Note</p> <p>For further details on the XCM configuration, refer to the XCM Configuration page.</p> <p>Where the XCM format defines a set of instructions used to construct XCVM programs, <code>pallet-xcm</code> defines a set of extrinsics that can be utilized to build XCVM programs, either to target the local or external chains. The <code>pallet-xcm</code> functionality is divided into three categories:</p> <ul> <li> <p>Primitive - dispatchable functions to execute XCM locally</p> </li> <li> <p>High-level - functions for asset transfers between chains</p> </li> <li> <p>Version negotiation-specific - functions for managing XCM version compability</p> </li> </ul>"},{"location":"develop/interoperability/send-messages/#key-roles-of-the-xcm-pallet","title":"Key Roles of the XCM Pallet","text":"<p>The XCM pallet plays a central role in managing cross-chain messages, with its primary responsibilities including:</p> <ul> <li> <p>Execute XCM messages - interacts with the XCM executor to validate and execute messages, adhering to predefined security and filter criteria</p> </li> <li> <p>Send messages across chains - allows authorized origins to send XCM messages, enabling controlled cross-chain communication</p> </li> <li> <p>Reserve-based transfers and teleports - supports asset movement between chains, governed by filters that restrict operations to authorized origins</p> </li> <li> <p>XCM version negotiation - ensures compatibility by selecting the appropriate XCM version for inter-chain communication</p> </li> <li> <p>Asset trapping and recovery - manages trapped assets, enabling safe reallocation or recovery when issues occur during cross-chain transfers</p> </li> <li> <p>Support for XCVM operations - oversees state and configuration requirements necessary for executing cross-consensus programs within the XCVM framework</p> </li> </ul>"},{"location":"develop/interoperability/send-messages/#primary-extrinsics-of-the-xcm-pallet","title":"Primary Extrinsics of the XCM Pallet","text":"<p>This page will highlight the two Primary Primitive Calls responsible for sending and executing XCVM programs as dispatchable functions within the pallet.</p>"},{"location":"develop/interoperability/send-messages/#execute","title":"Execute","text":"<p>The\u00a0<code>execute</code>\u00a0call directly interacts with the XCM executor, allowing for the execution of XCM messages originating from a locally signed origin. The executor validates the message, ensuring it complies with any configured barriers or filters before executing.</p> <p>Once validated, the message is executed locally, and an event is emitted to indicate the result\u2014whether the message was fully executed or only partially completed. Execution is capped by a maximum weight (<code>max_weight</code>); if the required weight exceeds this limit, the message will not be executed.</p> <pre><code>pub fn execute&lt;T: Config&gt;(\n    message: Box&lt;VersionedXcm&lt;&lt;T as Config&gt;::RuntimeCall&gt;&gt;,\n    max_weight: Weight,\n)\n</code></pre> <p>Note</p> <p>For further details on the <code>execute</code> extrinsic, see the <code>pallet-xcm</code> documentation.</p> <p>Warning</p> <p>Partial execution of messages may occur depending on the constraints or barriers applied.</p>"},{"location":"develop/interoperability/send-messages/#send","title":"Send","text":"<p>The\u00a0<code>send</code>\u00a0call enables XCM messages to be sent to a specified destination. This could be a parachain, smart contract, or any external system governed by consensus. Unlike the execute call, the message is not executed locally but is transported to the destination chain for processing.</p> <p>The destination is defined using a Location, which describes the target chain or system. This ensures precise delivery through the configured XCM transport mechanism.</p> <pre><code>pub fn send&lt;T: Config&gt;(\n    dest: Box&lt;MultiLocation&gt;,\n    message: Box&lt;VersionedXcm&lt;&lt;T as Config&gt;::RuntimeCall&gt;&gt;,\n)\n</code></pre> <p>Note</p> <p>For further information about the <code>send</code> extrinsic, check the <code>pallet-xcm</code> documentation.</p>"},{"location":"develop/interoperability/send-messages/#xcm-router","title":"XCM Router","text":"<p>The <code>XcmRouter</code> is a critical component the XCM pallet requires to facilitate sending XCM messages. It defines where messages can be sent and determines the appropriate XCM transport protocol for the operation.</p> <p>For instance, the Kusama network employs the <code>ChildParachainRouter</code>, which restricts routing to Downward Message Passing (DMP) from the relay chain to parachains, ensuring secure and controlled communication.</p> <pre><code>pub type XcmRouter = WithUniqueTopic&lt;(\n    // Only one router so far - use DMP to communicate with child parachains.\n    ChildParachainRouter&lt;Runtime, XcmPallet, PriceForChildParachainDelivery&gt;,\n)&gt;;\n</code></pre> <p>Note</p> <p>For more details on XCM transport protocols, see the XCM Channels page.</p>"},{"location":"develop/interoperability/test-and-debug/","title":"Testing and Debugging","text":""},{"location":"develop/interoperability/test-and-debug/#introduction","title":"Introduction","text":"<p>Cross-Consensus Messaging (XCM) is a core feature of the Polkadot ecosystem, enabling communication between parachains, relay chains, and system chains. To ensure the reliability of XCM-powered blockchains, thorough testing and debugging are essential before production deployment.</p> <p>This article explores two indispensable tools for XCM testing, the XCM Simulator and  the XCM Emulator, to help developers onboard and test their solutions effectively.</p>"},{"location":"develop/interoperability/test-and-debug/#xcm-simulator","title":"XCM Simulator","text":"<p>Setting up a live network with multiple interconnected parachains for XCM testing can be complex and resource-intensive. To address this, the <code>xcm-simulator</code> was developed. This versatile tool enables developers to test and experiment with XCM in a controlled, simulated network environment.</p> <p>The <code>xcm-simulator</code> offers a fast and efficient way to test XCM instructions against the <code>xcm-executor</code>. It serves as an experimental playground for developers, supporting features such as:</p> <ul> <li>Mocking Downward Message Passing (DMP) - retrieve incoming XCMs from the relay chain using the <code>received_dmp</code> getter</li> <li>Rapid iteration - test XCM messages in isolation without relying on full network simulations</li> </ul> <p>The <code>xcm-simulator</code> achieves this by utilizing mocked runtimes for both the relay chain and connected parachains, enabling developers to focus on message logic and configuration without needing a live network.</p>"},{"location":"develop/interoperability/test-and-debug/#how-does-it-work","title":"How does it work?","text":"<p>The <code>xcm-simulator</code> provides the following macros for building a mocked simulation environment:</p> <ul> <li> <p><code>decl_test_relay_chain</code> - implements upward message passing (UMP) for the specified relay chain struct. The struct must define the XCM configuration for the relay chain:</p> <pre><code>decl_test_relay_chain! {\n    pub struct Relay {\n        Runtime = relay_chain::Runtime,\n        XcmConfig = relay_chain::XcmConfig,\n        new_ext = relay_ext(),\n    }\n}\n</code></pre> <p>The <code>relay_ext()</code> sets up a test environment for the relay chain with predefined storage, then returns a <code>TestExternalities</code> instance for further testing. </p> </li> <li> <p><code>decl_test_parachain</code> - implements the <code>XcmMessageHandlerT</code> and <code>DmpMessageHandlerT</code> traits for the specified parachain struct. Requires the parachain struct to include the <code>XcmpMessageHandler</code> and <code>DmpMessageHandler</code> pallets, which define the logic for processing messages (implemented through <code>mock_message_queue</code>). The patter must be the following: </p> <pre><code>decl_test_parachain! {\n    pub struct ParaA {\n        Runtime = parachain::Runtime,\n        XcmpMessageHandler = parachain::MsgQueue,\n        DmpMessageHandler = parachain::MsgQueue,\n        new_ext = para_ext(1),\n    }\n}\n</code></pre> <p>The <code>para_ext(para_id: u32)</code> function initializes a test environment for a parachain with a specified <code>para_id</code>, sets the initial configuration of the parachain, returning a <code>TestExternalities</code> instance for testing.</p> <p>Note</p> <p>Developers can take this idea and define as many parachains as they want, like <code>ParaA</code>, <code>ParaB</code>, <code>ParaC</code>, etc</p> </li> <li> <p><code>decl_test_network</code> - defines a testing network consisting of a relay chain and multiple parachains. Takes a network struct as input and implements functionalities for testing, including <code>ParachainXcmRouter</code> and <code>RelayChainXcmRouter</code>. The struct must specify the relay chain and an indexed list of parachains to be included in the network:</p> <pre><code>decl_test_network! {\n    pub struct ExampleNet {\n        relay_chain = Relay,\n        parachains = vec![\n            (1, ParaA),\n            (2, ParaB),\n        ],\n    }\n}\n</code></pre> </li> </ul> <p>By leveraging these macros, developers can customize their testing networks by defining relay chains and parachains tailored to their needs.</p> <p>For guidance on implementing a mock runtime for a Polkadot SDK-based chain, refer to the Pallet Testing article. This framework enables thorough testing of runtime and cross-chain interactions.</p> <p>For a complete example of how to use the <code>xcm-simulator</code>, explore the <code>sample</code> provided in the <code>xcm-simulator</code> codebase.</p>"},{"location":"develop/interoperability/test-and-debug/#xcm-emulator","title":"XCM Emulator","text":"<p>The <code>xcm-emulator</code> is a tool designed to simulate the execution of XCM programs using predefined runtime configurations. These configurations include those utilized by live networks like Kusama, Polkadot, and the Asset Hub.</p> <p>This tool enables testing of cross-chain message passing, providing a way to verify outcomes, weights, and side effects efficiently.</p> <p>The <code>xcm-emulator</code> relies on transport layer pallets. However, the messages do not leverage the same messaging infrastructure as live networks since the transport mechanism is mocked. Additionally, consensus-related events are not covered, such as disputes, staking, and ImOnline events. Parachains should use end-to-end (E2E) tests to validate these events.</p>"},{"location":"develop/interoperability/test-and-debug/#pros-and-cons","title":"Pros and Cons","text":"<p>The XCM Emulator provides both advantages and limitations when testing cross-chain communication in simulated environments.</p> <ul> <li> <p>Pros:</p> <ul> <li>Interactive debugging - offers tracing capabilities similar to EVM, enabling detailed analysis of issues</li> <li>Runtime composability - facilitates testing and integration of multiple runtime components</li> <li>Immediate feedback - supports Test-Driven Development (TDD) by providing rapid test results</li> <li>Seamless integration testing - simplifies the process of testing new runtime versions in an isolated environment</li> </ul> </li> <li> <p>Cons:</p> <ul> <li>Simplified emulation - always assumes message delivery, which may not mimic real-world network behavior</li> <li>Dependency challenges - requires careful management of dependency versions and patching. Refer to the Cargo dependency documentation</li> <li>Compilation overhead - testing environments can be resource-intensive, requiring frequent compilation updates</li> </ul> </li> </ul>"},{"location":"develop/interoperability/test-and-debug/#how-does-it-work_1","title":"How Does It Work?","text":"<p>The <code>xcm-emulator</code> package builds upon the functionality provided by the <code>xcm-simulator</code> package, offering the same set of macros while extending their capabilities. In addition to the standard features, <code>xcm-emulator</code> introduces new tools that make testing cross-chain communication more comprehensive.</p> <p>One of the key additions is the <code>decl_test_bridges</code> macro. This macro allows developers to define and implement mock bridges for testing interoperability in the Polkadot ecosystem.</p> <ul> <li> <p><code>decl_test_bridges</code> - enables the creation of multiple bridges between chains, specifying their source chain, target chain, and the handler responsible for processing messages</p> <pre><code>decl_test_bridges! {\n    pub struct BridgeA {\n        source = ChainA,\n        target = ChainB,\n        handler = HandlerA\n    },\n    pub struct BridgeB {\n        source = ChainB,\n        target = ChainC,\n        handler = HandlerB\n    },\n}\n</code></pre> </li> </ul> <p>Utilizing the capabilities of the xcm-emulator, developers can effectively design, test, and optimize cross-chain functionality, fostering interoperability within the Polkadot ecosystem.</p>"},{"location":"develop/interoperability/xcm-channels/","title":"XCM Channels","text":""},{"location":"develop/interoperability/xcm-channels/#introduction","title":"Introduction","text":"<p>Polkadot is designed to enable interoperability between its connected parachains. At the core of this interoperability is the Cross-Consensus Message Format (XCM), a standard language that allows parachains to communicate and interact with each other.</p> <p>The network-layer protocol responsible for delivering XCM-formatted messages between parachains is the Cross-Chain Message Passing (XCMP) protocol. XCMP maintains messaging queues on the relay chain, serving as a bridge to facilitate cross-chain interactions.</p> <p>As XCMP is still under development, Polkadot has implemented a temporary alternative called Horizontal Relay-routed Message Passing (HRMP). HRMP offers the same interface and functionality as the planned XCMP but it has a crucial difference, it stores all messages directly in the relay chain\u2019s storage, which is more resource-intensive.</p> <p>Once XCMP is fully implemented, HRMP will be deprecated in favor of the native XCMP protocol. XCMP will offer a more efficient and scalable solution for cross-chain message passing, as it will not require the relay chain to store all the messages.</p>"},{"location":"develop/interoperability/xcm-channels/#establishing-hrmp-channels","title":"Establishing HRMP Channels","text":"<p>To enable communication between parachains using the HRMP protocol, the parachains must explicitly establish communication channels by registering them on the relay chain.</p> <p>Downward and upward channels from and to the relay chain are implicitly available, meaning they do not need to be explicitly opened.</p> <p>Opening an HRMP channel requires the parachains involved to make a deposit on the relay chain. This deposit serves a specific purpose, it covers the costs associated with using the relay chain's storage for the message queues linked to the channel. The amount of this deposit varies based on parameters defined by the specific relay chain being used.</p>"},{"location":"develop/interoperability/xcm-channels/#relay-chain-parameters","title":"Relay Chain Parameters","text":"<p>Each Polkadot relay chain has a set of configurable parameters that control the behavior of the message channels between parachains. These parameters include <code>hrmpSenderDeposit</code>, <code>hrmpRecipientDeposit</code>, <code>hrmpChannelMaxMessageSize</code>, <code>hrmpChannelMaxCapacity</code>, and more.</p> <p>When a parachain wants to open a new channel, it must consider these parameter values to ensure the channel is configured correctly.</p> <p>To view the current values of these parameters in the Polkadot network:</p> <ol> <li> <p>Visit Polkadot.js Apps, navigate to the Developer dropdown and select the Chain state option</p> <p></p> </li> <li> <p>Query the chain configuration parameters. The result will display the current settings for all the Polkadot network parameters, including the HRMP channel settings</p> <ol> <li>Select <code>configuration</code></li> <li>Choose the <code>activeConfig()</code> call</li> <li>Click the + button to execute the query</li> <li>Check the chain configuration</li> </ol> <p></p> </li> </ol>"},{"location":"develop/interoperability/xcm-channels/#dispatching-extrinsics","title":"Dispatching Extrinsics","text":"<p>Establishing new HRMP channels between parachains requires dispatching specific extrinsic calls on the Polkadot relay chain from the parachain's origin.</p> <p>The most straightforward approach is to implement the channel opening logic off-chain, then use the XCM pallet's <code>send</code> extrinsic to submit the necessary instructions to the relay chain. However, the ability to send arbitrary programs through the <code>Transact</code> instruction in XCM is typically restricted to privileged origins, such as the <code>sudo</code> pallet or governance mechanisms.</p> <p>Parachain developers have a few options for triggering the required extrinsic calls from their parachain's origin, depending on the configuration and access controls defined:</p> <ul> <li>Sudo - if the parachain has a <code>sudo</code> pallet configured, the sudo key holder can use the sudo extrinsic to dispatch the necessary channel opening calls</li> <li>Governance - the parachain's governance system, such as a council or OpenGov, can be used to authorize the channel opening calls</li> <li>Privileged accounts - the parachain may have other designated privileged accounts that are allowed to dispatch the HRMP channel opening extrinsics</li> </ul>"},{"location":"develop/interoperability/xcm-channels/#where-to-go-next","title":"Where to Go Next","text":"<p>Explore the following tutorials for detailed, step-by-step guidance on setting up cross-chain communication channels in Polkadot:</p> <ul> <li>Opening HRMP Channels Between Parachains</li> <li>Opening HRMP Channels with System Parachains</li> </ul>"},{"location":"develop/interoperability/xcm-config/","title":"XCM Config","text":""},{"location":"develop/interoperability/xcm-config/#introduction","title":"Introduction","text":"<p>The XCM executor is a crucial component responsible for interpreting and executing XCM messages (XCMs) with Polkadot SDK-based chains. It processes and manages XCM instructions, ensuring they are executed correctly and in sequentially. Adhering to the Cross-Consensus Virtual Machine (XCVM) specification, the XCM executor can be customized or replaced with an alternative that also complies with the XCVM standards.</p> <p>The <code>XcmExecutor</code> is not a pallet but a struct parameterized by a <code>Config</code> trait. The <code>Config</code> trait is the inner configuration, parameterizing the outer <code>XcmExecutor&lt;Config&gt;</code> struct. Both configurations are set up within the runtime.</p> <p>The executor is highly configurable, with the XCM builder offering building blocks to tailor the configuration to specific needs. While they serve as a foundation, users can easily create custom blocks to suit unique configurations. Users can also create their building blocks to address unique needs. This article examines the XCM configuration process, explains each configurable item, and provides examples of the tools and types available to help customize these settings.</p>"},{"location":"develop/interoperability/xcm-config/#xcm-executor-configuration","title":"XCM Executor Configuration","text":"<p>The <code>Config</code> trait defines the XCM executor\u2019s configuration, which requires several associated types. Each type has specific trait bounds that the concrete implementation must fulfill. Some types, such as <code>RuntimeCall</code>, come with a default implementation in most cases, while others use the unit type <code>()</code> as the default. For many of these types, selecting the appropriate implementation carefully is crucial. Predefined solutions and building blocks can be adapted to your specific needs. These solutions can be found in the <code>xcm-builder</code> folder.</p> <p>Each type is explained below, along with an overview of some of its implementations:</p> <pre><code>pub trait Config {\n    type RuntimeCall: Parameter + Dispatchable&lt;PostInfo = PostDispatchInfo&gt; + GetDispatchInfo;\n    type XcmSender: SendXcm;\n    type AssetTransactor: TransactAsset;\n    type OriginConverter: ConvertOrigin&lt;&lt;Self::RuntimeCall as Dispatchable&gt;::RuntimeOrigin&gt;;\n    type IsReserve: ContainsPair&lt;MultiAsset, MultiLocation&gt;;\n    type IsTeleporter: ContainsPair&lt;MultiAsset, MultiLocation&gt;;\n    type Aliasers: ContainsPair&lt;Location, Location&gt;;\n    type UniversalLocation: Get&lt;InteriorMultiLocation&gt;;\n    type Barrier: ShouldExecute;\n    type Weigher: WeightBounds&lt;Self::RuntimeCall&gt;;\n    type Trader: WeightTrader;\n    type ResponseHandler: OnResponse;\n    type AssetTrap: DropAssets;\n    type AssetClaims: ClaimAssets;\n    type AssetLocker: AssetLock;\n    type AssetExchanger: AssetExchange;\n    type SubscriptionService: VersionChangeNotifier;\n    type PalletInstancesInfo: PalletsInfoAccess;\n    type MaxAssetsIntoHolding: Get&lt;u32&gt;;\n    type FeeManager: FeeManager;\n    type MessageExporter: ExportXcm;\n    type UniversalAliases: Contains&lt;(MultiLocation, Junction)&gt;;\n    type CallDispatcher: CallDispatcher&lt;Self::RuntimeCall&gt;;\n    type SafeCallFilter: Contains&lt;Self::RuntimeCall&gt;;\n    type TransactionalProcessor: ProcessTransaction;\n    type HrmpNewChannelOpenRequestHandler: HandleHrmpNewChannelOpenRequest;\n    type HrmpChannelAcceptedHandler: HandleHrmpChannelAccepted;\n    type HrmpChannelClosingHandler: HandleHrmpChannelClosing;\n    type XcmRecorder: RecordXcm;\n}\n</code></pre>"},{"location":"develop/interoperability/xcm-config/#config-items","title":"Config Items","text":"<p>Each configuration item is explained below, detailing the associated type\u2019s purpose and role in the XCM executor. Many of these types have predefined solutions available in the <code>xcm-builder</code>. Therefore, the available configuration items are:</p> <ul> <li> <p><code>RuntimeCall</code> - defines the runtime's callable functions, created via the <code>frame::runtime</code> macro. It represents an enum listing the callable functions of all implemented pallets     <pre><code>type RuntimeCall: Parameter + Dispatchable&lt;PostInfo = PostDispatchInfo&gt; + GetDispatchInfo\n</code></pre>    The associated traits signify:</p> <ul> <li><code>Parameter</code> - ensures the type is encodable, decodable, and usable as a parameter</li> <li><code>Dispatchable</code> - indicates it can be executed in the runtime</li> <li><code>GetDispatchInfo</code> - provides weight details, determining how long execution takes</li> </ul> </li> <li> <p><code>XcmSender</code> - implements the <code>SendXcm</code> trait, specifying how the executor sends XCMs using transport layers (e.g., UMP for relay chains or XCMP for sibling chains). If a runtime lacks certain transport layers, such as HRMP (or XCMP)     <pre><code>type XcmSender: SendXcm;\n</code></pre></p> </li> <li> <p><code>AssetTransactor</code> - implements the <code>TransactAsset</code> trait, handling the conversion and transfer of MultiAssets between accounts or registers. It can be configured to support native tokens, fungibles, and non-fungibles or multiple tokens using pre-defined adapters like <code>FungibleAdapter</code> or custom solutions     <pre><code>type AssetTransactor: TransactAsset;\n</code></pre></p> </li> <li> <p><code>OriginConverter</code> - implements the <code>ConvertOrigin</code> trait to map <code>MultiLocation</code> origins to <code>RuntimeOrigin</code>. Multiple implementations can be combined, and <code>OriginKind</code> is used to resolve conflicts. Pre-defined converters like <code>SovereignSignedViaLocation</code> and <code>SignedAccountId32AsNative</code> handle sovereign and local accounts respectively     <pre><code>type OriginConverter: ConvertOrigin&lt;&lt;Self::RuntimeCall as Dispatchable&gt;::RuntimeOrigin&gt;;\n</code></pre></p> </li> <li> <p><code>IsReserve</code> - specifies trusted <code>&lt;MultiAsset, MultiLocation&gt;</code> pairs for depositing reserve assets. Using the unit type <code>()</code> blocks reserve deposits. The <code>NativeAsset</code> struct is an example of a reserve implementation     <pre><code>type IsReserve: ContainsPair&lt;MultiAsset, MultiLocation&gt;;\n</code></pre></p> </li> <li> <p><code>IsTeleporter</code> - defines trusted <code>&lt;MultiAsset, MultiLocation&gt;</code> pairs for teleporting assets to the chain. Using <code>()</code> blocks the <code>ReceiveTeleportedAssets</code> instruction. The <code>NativeAsset</code> struct can act as an implementation     <pre><code>type IsTeleporter: ContainsPair&lt;MultiAsset, MultiLocation&gt;;\n</code></pre></p> </li> <li> <p><code>Aliasers</code> - a list of <code>(Origin, Target)</code> pairs enabling each <code>Origin</code> to be replaced with its corresponding <code>Target</code> <pre><code>type Aliasers: ContainsPair&lt;Location, Location&gt;;\n</code></pre></p> </li> <li> <p><code>UniversalLocation</code> - specifies the runtime's location in the consensus universe     <pre><code>type UniversalLocation: Get&lt;InteriorMultiLocation&gt;;\n</code></pre></p> <ul> <li>Some examples are:<ul> <li><code>X1(GlobalConsensus(NetworkId::Polkadot))</code> for Polkadot</li> <li><code>X1(GlobalConsensus(NetworkId::Kusama))</code> for Kusama</li> <li><code>X2(GlobalConsensus(NetworkId::Polkadot), Parachain(1000))</code> for Statemint</li> </ul> </li> </ul> </li> <li> <p><code>Barrier</code> - implements the <code>ShouldExecute</code> trait, functioning as a firewall for XCM execution. Multiple barriers can be combined in a tuple, where execution halts if one succeeds     <pre><code>type Barrier: ShouldExecute;\n</code></pre></p> </li> <li> <p><code>Weigher</code> - calculates the weight of XCMs and instructions, enforcing limits and refunding unused weight. Common solutions include <code>FixedWeightBounds</code>, which uses a base weight and limits on instructions     <pre><code>type Weigher: WeightBounds&lt;Self::RuntimeCall&gt;;\n</code></pre></p> </li> <li> <p><code>Trader</code> - manages asset-based weight purchases and refunds for <code>BuyExecution</code> instructions. The <code>UsingComponents</code> trader is a common implementation     <pre><code>type Trader: WeightTrader;\n</code></pre></p> </li> <li> <p><code>ResponseHandler</code> - handles <code>QueryResponse</code> instructions, implementing the <code>OnResponse</code> trait. FRAME systems typically use the pallet-xcm implementation     <pre><code>type ResponseHandler: OnResponse;\n</code></pre></p> </li> <li> <p><code>AssetTrap</code> - handles leftover assets in the holding register after XCM execution, allowing them to be claimed via <code>ClaimAsset</code>. If unsupported, assets are burned     <pre><code>type AssetTrap: DropAssets;\n</code></pre></p> </li> <li> <p><code>AssetClaims</code> - facilitates the claiming of trapped assets during the execution of the <code>ClaimAsset</code> instruction. Commonly implemented via pallet-xcm     <pre><code>type AssetClaims: ClaimAssets;\n</code></pre></p> </li> <li> <p><code>AssetLocker</code> - handles the locking and unlocking of assets. Can be omitted using <code>()</code> if asset locking is unnecessary     <pre><code>type AssetLocker: AssetLock;\n</code></pre></p> </li> <li> <p><code>AssetExchanger</code> - implements the <code>AssetExchange</code> trait to manage asset exchanges during the <code>ExchangeAsset</code> instruction. The unit type <code>()</code> disables this functionality     <pre><code>type AssetExchanger: AssetExchange;\n</code></pre></p> </li> <li> <p><code>SubscriptionService</code> - manages <code>(Un)SubscribeVersion</code> instructions and returns the XCM version via <code>QueryResponse</code>. Typically implemented by pallet-xcm     <pre><code>type SubscriptionService: VersionChangeNotifier;\n</code></pre></p> </li> <li> <p><code>PalletInstancesInfo</code> - provides runtime pallet information for <code>QueryPallet</code> and <code>ExpectPallet</code> instructions. FRAME-specific systems often use this, or it can be disabled with <code>()</code> <pre><code>type PalletInstancesInfo: PalletsInfoAccess;\n</code></pre> </p> </li> <li> <p><code>MaxAssetsIntoHolding</code> - limits the number of assets in the Holding register. At most, twice this limit can be held under worst-case conditions     <pre><code>type MaxAssetsIntoHolding: Get&lt;u32&gt;;\n</code></pre></p> </li> <li> <p><code>FeeManager</code> - manages fees for XCM instructions, determining whether fees should be paid, waived, or handled in specific ways. Fees can be waived entirely using <code>()</code> <pre><code>type FeeManager: FeeManager;\n</code></pre></p> </li> <li> <p><code>MessageExporter</code> - implements the <code>ExportXcm</code> trait, enabling XCMs export to other consensus systems. It can spoof origins for use in bridges. Use <code>()</code> to disable exporting     <pre><code>type MessageExporter: ExportXcm;\n</code></pre></p> </li> <li> <p><code>UniversalAliases</code> - lists origin locations and universal junctions allowed to elevate themselves in the <code>UniversalOrigin</code> instruction. Using <code>Nothing</code> prevents origin aliasing     <pre><code>type UniversalAliases: Contains&lt;(MultiLocation, Junction)&gt;;\n</code></pre></p> </li> <li> <p><code>CallDispatcher</code> - dispatches calls from the <code>Transact</code> instruction, adapting the origin or modifying the call as needed. Can default to <code>RuntimeCall</code> <pre><code>type CallDispatcher: CallDispatcher&lt;Self::RuntimeCall&gt;;\n</code></pre></p> </li> <li> <p><code>SafeCallFilter</code> - whitelists calls permitted in the <code>Transact</code> instruction. Using <code>Everything</code> allows all calls, though this is temporary until proof size weights are accounted for     <pre><code>type SafeCallFilter: Contains&lt;Self::RuntimeCall&gt;;\n</code></pre></p> </li> <li> <p><code>TransactionalProcessor</code> - implements the <code>ProccessTransaction</code> trait. It ensures that XCM instructions are executed atomically, meaning they either fully succeed or fully fail without any partial effects. This type allows for non-transactional XCM instruction processing by setting the <code>()</code> type     <pre><code>type TransactionalProcessor: ProcessTransaction;\n</code></pre></p> </li> <li> <p><code>HrmpNewChannelOpenRequestHandler</code> - enables optional logic execution in response to the <code>HrmpNewChannelOpenRequest</code> XCM notification     <pre><code>type HrmpNewChannelOpenRequestHandler: HandleHrmpNewChannelOpenRequest;\n</code></pre></p> </li> <li> <p><code>HrmpChannelAcceptedHandler</code> - enables optional logic execution in response to the <code>HrmpChannelAccepted</code> XCM notification     <pre><code>type HrmpChannelAcceptedHandler: HandleHrmpChannelAccepted;\n</code></pre></p> </li> <li><code>HrmpChannelClosingHandler</code> - enables optional logic execution in response to the <code>HrmpChannelClosing</code> XCM notification     <pre><code>type HrmpChannelClosingHandler: HandleHrmpChannelClosing;\n</code></pre></li> <li><code>XcmRecorder</code> - allows tracking of the most recently executed XCM, primarily for use with dry-run runtime APIs     <pre><code>type XcmRecorder: RecordXcm;\n</code></pre></li> </ul>"},{"location":"develop/interoperability/xcm-config/#inner-config","title":"Inner Config","text":"<p>The <code>Config</code> trait underpins the <code>XcmExecutor</code>, defining its core behavior through associated types for asset handling, XCM processing, and permission management. These types are categorized as follows:</p> <ul> <li>Handlers - manage XCMs sending, asset transactions, and special notifications</li> <li>Filters - define trusted combinations, origin substitutions, and execution barriers</li> <li>Converters - handle origin conversion for call execution</li> <li>Accessors - provide weight determination and pallet information</li> <li>Constants - specify universal locations and asset limits</li> <li>Common Configs - include shared settings like <code>RuntimeCall</code></li> </ul> <p>The following diagram outlines this categorization:</p> <pre><code>flowchart LR\n    A[Inner Config] --&gt; B[Handlers]\n    A --&gt; C[Filters]\n    A --&gt; D[Converters]\n    A --&gt; E[Accessors]\n    A --&gt; F[Constants]\n    A --&gt; G[Common Configs]\n\n    B --&gt; H[XcmSender]\n    B --&gt; I[AssetTransactor]\n    B --&gt; J[Trader]\n    B --&gt; K[ResponseHandler]\n    B --&gt; L[AssetTrap]\n    B --&gt; M[AssetLocker]\n    B --&gt; N[AssetExchanger]\n    B --&gt; O[AssetClaims]\n    B --&gt; P[SubscriptionService]\n    B --&gt; Q[FeeManager]\n    B --&gt; R[MessageExporter]\n    B --&gt; S[CallDispatcher]\n    B --&gt; T[HrmpNewChannelOpenRequestHandler]\n    B --&gt; U[HrmpChannelAcceptedHandler]\n    B --&gt; V[HrmpChannelClosingHandler]\n\n    C --&gt; W[IsReserve]\n    C --&gt; X[IsTeleporter]\n    C --&gt; Y[Aliasers]\n    C --&gt; Z[Barrier]\n    C --&gt; AA[UniversalAliases]\n    C --&gt; AB[SafeCallFilter]\n\n    D --&gt; AC[OriginConverter]\n\n    E --&gt; AD[Weigher]\n    E --&gt; AE[PalletInstancesInfo]\n\n    F --&gt; AF[UniversalLocation]\n    F --&gt; AG[MaxAssetsIntoHolding]\n\n    G --&gt; AH[RuntimeCall]</code></pre>"},{"location":"develop/interoperability/xcm-config/#outer-config","title":"Outer Config","text":"<p>The <code>XcmExecutor&lt;Config&gt;</code> struct extends the functionality of the inner config by introducing fields for execution context, asset handling, error tracking, and operational management. For further details, see the documentation for <code>XcmExecutor&lt;Config&gt;</code>.</p>"},{"location":"develop/interoperability/xcm-config/#multiple-implementations","title":"Multiple Implementations","text":"<p>Some associated types in the <code>Config</code> trait are highly configurable and may have multiple implementations (e.g., Barrier). These implementations are organized into a tuple <code>(impl_1, impl_2, ..., impl_n)</code>, and the execution follows a sequential order. Each item in the tuple is evaluated individually, each being checked to see if it fails. If an item passes (e.g., returns <code>Ok</code> or <code>true</code>), the execution stops, and the remaining items are not evaluated. The following example of the <code>Barrier</code> type demonstrates how this grouping operates (understanding each item in the tuple is unnecessary for this explanation).</p> <p>In the following example, the system will first check the <code>TakeWeightCredit</code> type when evaluating the barrier. If it fails, it will check <code>AllowTopLevelPaidExecutionFrom</code>, and so on, until one of them returns a positive result. If all checks fail, a Barrier error will be triggered.</p> <pre><code>pub type Barrier = (\n    TakeWeightCredit,\n    AllowTopLevelPaidExecutionFrom&lt;Everything&gt;,\n    AllowKnownQueryResponses&lt;XcmPallet&gt;,\n    AllowSubscriptionsFrom&lt;Everything&gt;,\n);\n\npub struct XcmConfig;\nimpl xcm_executor::Config for XcmConfig {\n    ...\n    type Barrier = Barrier;\n    ...\n}\n</code></pre>"},{"location":"develop/parachains/","title":"Parachains","text":"<p>Learn how to build, deploy, and maintain your parachain with the Polkadot SDK, from initial setup through customization, testing, runtime upgrades, and network operations.</p>"},{"location":"develop/parachains/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"develop/parachains/customize-parachain/","title":"Customize Your Parachain","text":"<p>Learn how to build a custom parachain with Polkadot SDK's FRAME framework, covering pallet development, testing, smart contracts, and runtime customization.</p>"},{"location":"develop/parachains/customize-parachain/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"develop/parachains/customize-parachain/add-existing-pallets/","title":"Add a Pallet to the Runtime","text":""},{"location":"develop/parachains/customize-parachain/add-existing-pallets/#introduction","title":"Introduction","text":"<p>The Polkadot SDK Solochain Template provides a functional runtime that includes default FRAME development modules (pallets) to help you get started with building a custom blockchain.</p> <p>Each pallet has specific configuration requirements, such as the parameters and types needed to enable the pallet's functionality. In this guide, you'll learn how to add a pallet to a runtime and configure the settings specific to that pallet.</p> <p>The purpose of this article is to help you:</p> <ul> <li>Learn how to update runtime dependencies to integrate a new pallet</li> <li>Understand how to configure pallet-specific Rust traits to enable the pallet's functionality</li> <li>Grasp the entire workflow of integrating a new pallet into your runtime</li> </ul>"},{"location":"develop/parachains/customize-parachain/add-existing-pallets/#configuring-runtime-dependencies","title":"Configuring Runtime Dependencies","text":"<p>For Rust programs, this configuration is defined in the <code>Cargo.toml</code> file, which specifies the settings and dependencies that control what gets compiled into the final binary. Since the Polkadot SDK runtime compiles to both a native binary (which includes standard Rust library functions) and a Wasm binary (which does not include the standard Rust library), the <code>runtime/Cargo.toml</code> file manages two key aspects:</p> <ul> <li>The locations and versions of the pallets that are to be imported as dependencies for the runtime</li> <li>The features in each pallet that should be enabled when compiling the native Rust binary. By enabling the standard (<code>std</code>) feature set from each pallet, you ensure that the runtime includes the functions, types, and primitives necessary for the native build, which are otherwise excluded when compiling the Wasm binary</li> </ul> <p>Note</p> <p>For information about adding dependencies in <code>Cargo.toml</code> files, see the Dependencies page in the Cargo documentation. For information about enabling and managing features from dependent packages, see the Features section in the Cargo documentation.</p>"},{"location":"develop/parachains/customize-parachain/add-existing-pallets/#dependencies-for-a-new-pallet","title":"Dependencies for a New Pallet","text":"<p>To add the dependencies for a new pallet to the runtime, you must modify the <code>Cargo.toml</code> file by adding a new line into the <code>[workspace.dependencies]</code> section with the pallet you want to add. This pallet definition might look like:</p> <pre><code>pallet-example = { version = \"4.0.0-dev\", default-features = false }\n</code></pre> <p>This line imports the <code>pallet-example</code> crate as a dependency and specifies the following:</p> <ul> <li><code>version</code> - the specific version of the crate to import</li> <li><code>default-features</code> - determines the behavior for including pallet features when compiling the runtime with standard Rust libraries</li> </ul> <p>Note</p> <p>If you\u2019re importing a pallet that isn\u2019t available on <code>crates.io</code>, you can specify the pallet's location (either locally or from a remote repository) by using the <code>git</code> or <code>path</code> key. For example:</p> <pre><code>pallet-example = { \n    version = \"4.0.0-dev\",\n    default-features = false,\n    git = \"INSERT_PALLET_REMOTE_URL\",\n}\n</code></pre> <p>In this case, replace <code>INSERT_PALLET_REMOTE_URL</code> with the correct repository URL. For local paths, use the path key like so:</p> <pre><code>pallet-example = { \n    version = \"4.0.0-dev\",\n    default-features = false,\n    path = \"INSERT_PALLET_RELATIVE_PATH\",\n}\n</code></pre> <p>Ensure that you substitute <code>INSERT_PALLET_RELATIVE_PATH</code> with the appropriate local path to the pallet.</p> <p>Next, add this dependency to the <code>[dependencies]</code> section of the <code>runtime/Cargo.toml</code> file, so it inherits from the main <code>Cargo.toml</code> file:</p> <pre><code>pallet-examples.workspace = true\n</code></pre> <p>To enable the <code>std</code> feature of the pallet, add the pallet to the following section:</p> <pre><code>[features]\ndefault = [\"std\"]\nstd = [\n    ...\n    \"pallet-example/std\",\n    ...\n]\n</code></pre> <p>This section specifies the default feature set for the runtime, which includes the <code>std</code> features for each pallet. When the runtime is compiled with the <code>std</code> feature set, the standard library features for all listed pallets are enabled. For more details on how the runtime is compiled as both a native binary (using <code>std</code>) and a Wasm binary (using <code>no_std</code>), refer to the Wasm build section in the Polkadot SDK documentation.</p> <p>Note</p> <p>If you forget to update the features section in the <code>Cargo.toml</code> file, you might encounter <code>cannot find function</code> errors when compiling the runtime.</p> <p>To ensure that the new dependencies resolve correctly for the runtime, you can run the following command:</p> <pre><code>cargo check --release\n</code></pre>"},{"location":"develop/parachains/customize-parachain/add-existing-pallets/#config-trait-for-pallets","title":"Config Trait for Pallets","text":"<p>Every Polkadot SDK pallet defines a Rust trait called <code>Config</code>. This trait specifies the types and parameters that the pallet needs to integrate with the runtime and perform its functions. The primary purpose of this trait is to act as an interface between this pallet and the runtime in which it is embedded. A type, function, or constant in this trait is essentially left to be configured by the runtime that includes this pallet.</p> <p>Consequently, a runtime that wants to include this pallet must implement this trait.</p> <p>You can inspect any pallet\u2019s <code>Config</code> trait by reviewing its Rust documentation or source code. The <code>Config</code> trait ensures the pallet has access to the necessary types (like events, calls, or origins) and integrates smoothly with the rest of the runtime.</p> <p>At its core, the <code>Config</code> trait typically looks like this:</p> <pre><code>#[pallet::config]\npub trait Config: frame_system::Config {\n    /// Event type used by the pallet.\n    type RuntimeEvent: From&lt;Event&gt; + IsType&lt;&lt;Self as frame_system::Config&gt;::RuntimeEvent&gt;;\n\n    /// Weight information for controlling extrinsic execution costs.\n    type WeightInfo: WeightInfo;\n}\n</code></pre> <p>This basic structure shows that every pallet must define certain types, such as <code>RuntimeEvent</code> and <code>WeightInfo</code>, to function within the runtime. The actual implementation can vary depending on the pallet\u2019s specific needs.</p> Example - Utility Pallet <p>For instance, in the\u00a0<code>utility pallet</code>, the <code>Config</code> trait is implemented with the following types:</p> <pre><code>#[pallet::config]\npub trait Config: frame_system::Config {\n    /// The overarching event type.\n    type RuntimeEvent: From&lt;Event&gt; + IsType&lt;&lt;Self as frame_system::Config&gt;::RuntimeEvent&gt;;\n\n    /// The overarching call type.\n    type RuntimeCall: Parameter\n    + Dispatchable&lt;RuntimeOrigin = Self::RuntimeOrigin, PostInfo = PostDispatchInfo&gt;\n    + GetDispatchInfo\n    + From&lt;frame_system::Call&lt;Self&gt;&gt;\n    + UnfilteredDispatchable&lt;RuntimeOrigin = Self::RuntimeOrigin&gt;\n    + IsSubType&lt;Call&lt;Self&gt;&gt;\n    + IsType&lt;&lt;Self as frame_system::Config&gt;::RuntimeCall&gt;;\n\n    /// The caller origin, overarching type of all pallets origins.\n    type PalletsOrigin: Parameter +\n    Into&lt;&lt;Self as frame_system::Config&gt;::RuntimeOrigin&gt; +\n    IsType&lt;&lt;&lt;Self as frame_system::Config&gt;::RuntimeOrigin as frame_support::traits::OriginTrait&gt;::PalletsOrigin&gt;;\n\n    /// Weight information for extrinsics in this pallet.\n    type WeightInfo: WeightInfo;\n}\n</code></pre> <p>This example shows how the <code>Config</code> trait defines types like <code>RuntimeEvent</code>, <code>RuntimeCall</code>, <code>PalletsOrigin</code>, and <code>WeightInfo</code>, which the pallet will use when interacting with the runtime.</p>"},{"location":"develop/parachains/customize-parachain/add-existing-pallets/#parameter-configuration-for-pallets","title":"Parameter Configuration for Pallets","text":"<p>Traits in Rust define shared behavior, and within the Polkadot SDK, they allow runtimes to integrate and utilize a pallet's functionality by implementing its associated configuration trait and parameters. Some of these parameters may require constant values, which can be defined using the <code>parameter_types!</code> macro. This macro simplifies development by expanding the constants into the appropriate struct types with functions that the runtime can use to access their types and values in a consistent manner.</p> <p>For example, the following code snippet shows how the solochain template configures certain parameters through the <code>parameter_types!</code> macro in the <code>runtime/lib.rs</code> file:</p> <pre><code>parameter_types! {\n    pub const BlockHashCount: BlockNumber = 2400;\n    pub const Version: RuntimeVersion = VERSION;\n    /// We allow for 2 seconds of compute with a 6 second average block time.\n    pub BlockWeights: frame_system::limits::BlockWeights =\n        frame_system::limits::BlockWeights::with_sensible_defaults(\n            Weight::from_parts(2u64 * WEIGHT_REF_TIME_PER_SECOND, u64::MAX),\n            NORMAL_DISPATCH_RATIO,\n        );\n    pub BlockLength: frame_system::limits::BlockLength = frame_system::limits::BlockLength\n        ::max_with_normal_ratio(5 * 1024 * 1024, NORMAL_DISPATCH_RATIO);\n    pub const SS58Prefix: u8 = 42;\n}\n</code></pre>"},{"location":"develop/parachains/customize-parachain/add-existing-pallets/#pallet-config-in-the-runtime","title":"Pallet Config in the Runtime","text":"<p>To integrate a new pallet into the runtime, you must implement its <code>Config</code> trait in the <code>runtime/lib.rs</code> file. This is done by specifying the necessary types and parameters in Rust, as shown below:</p> <pre><code>impl pallet_example::Config for Runtime {\n    type RuntimeEvent = RuntimeEvent;\n    type WeightInfo = pallet_template::weights::SubstrateWeight&lt;Runtime&gt;;\n    ...\n}\n</code></pre> <p>Finally, to compose the runtime, update the list of pallets in the same file by modifying the <code>#[frame_support::runtime]</code> section. This Rust macro constructs the runtime with a specified name and the pallets you want to include. Use the following format when adding your pallet:</p> <pre><code>#[frame_support::runtime]\nmod runtime {\n    #[runtime::runtime]\n    #[runtime::derive(\n        RuntimeCall,\n        RuntimeEvent,\n        RuntimeError,\n        RuntimeOrigin,\n        RuntimeFreezeReason,\n        RuntimeHoldReason,\n        RuntimeSlashReason,\n        RuntimeLockId,\n        RuntimeTask\n    )]\n    pub struct Runtime;\n\n    #[runtime::pallet_index(0)]\n    pub type System = frame_system;\n\n    #[runtime::pallet_index(1)]\n    pub type Example = pallet_example;\n</code></pre> <p>Note</p> <p>The <code>#[frame_support::runtime]</code> macro wraps the runtime's configuration, automatically generating boilerplate code for pallet inclusion.</p>"},{"location":"develop/parachains/customize-parachain/add-existing-pallets/#where-to-go-next","title":"Where to Go Next","text":"<p>With the pallet successfully added and configured, the runtime is ready to be compiled and used. Following this guide\u2019s steps, you\u2019ve integrated a new pallet into the runtime, set up its dependencies, and ensured proper configuration. You can now proceed to any of the following points:</p> <ul> <li>Dive deeper by creating your custom pallet to expand the functionality of your blockchain</li> <li>Ensure robustness with Pallet Testing to verify the accuracy and behavior of your code</li> </ul>"},{"location":"develop/parachains/customize-parachain/add-smart-contract-functionality/","title":"Add Smart Contract Functionality","text":""},{"location":"develop/parachains/customize-parachain/add-smart-contract-functionality/#introduction","title":"Introduction","text":"<p>When building your custom blockchain with the Polkadot SDK, you have the flexibility to add smart contract capabilities through specialized pallets. These pallets allow blockchain users to deploy and execute smart contracts, enhancing your chain's functionality and programmability.</p> <p>Polkadot SDK-based blockchains support two distinct smart contract execution environments: EVM (Ethereum Virtual Machine) and Wasm (WebAssembly). Each environment allows developers to deploy and execute different types of smart contracts, providing flexibility in choosing the most suitable solution for their needs.</p>"},{"location":"develop/parachains/customize-parachain/add-smart-contract-functionality/#evm-smart-contracts","title":"EVM Smart Contracts","text":"<p>To enable Ethereum-compatible smart contracts in your blockchain, you'll need to integrate Frontier, the Ethereum compatibility layer for Polkadot SDK-based chains. This requires adding two essential pallets to your runtime:</p> <ul> <li><code>pallet-evm</code> - provides the EVM execution environment</li> <li><code>pallet-ethereum</code> - handles Ethereum-formatted transactions and RPC capabilities</li> </ul> <p>For step-by-step guidance on adding these pallets to your runtime, refer to Add a Pallet to the Runtime.</p> <p>For a real-world example of how these pallets are implemented in production, you can check Moonbeam's implementation of <code>pallet-evm</code> and <code>pallet-ethereum</code>.</p>"},{"location":"develop/parachains/customize-parachain/add-smart-contract-functionality/#wasm-smart-contracts","title":"Wasm Smart Contracts","text":"<p>To support Wasm-based smart contracts, you'll need to integrate:</p> <ul> <li><code>pallet-contracts</code> - provides the Wasm smart contract execution environment</li> </ul> <p>This pallet enables the deployment and execution of Wasm-based smart contracts on your blockchain. For detailed instructions on adding this pallet to your runtime, see Add a Pallet to the Runtime.</p> <p>For a real-world example of how this pallet is implemented in production, you can check Astar's implementation of <code>pallet-contracts</code>.</p>"},{"location":"develop/parachains/customize-parachain/add-smart-contract-functionality/#where-to-go-next","title":"Where to Go Next","text":"<p>Now that you understand how to enable smart contract functionality in your blockchain, you might want to:</p> <ul> <li>Take a step back and learn more about EVM and Wasm contracts by visiting the Smart Contracts guide</li> <li>Start building with Wasm (ink!) contracts</li> <li>Start building with EVM contracts</li> </ul>"},{"location":"develop/parachains/customize-parachain/benchmarking/","title":"Benchmark Testing","text":""},{"location":"develop/parachains/customize-parachain/benchmarking/#introduction","title":"Introduction","text":"<p>Benchmark testing is a critical component of developing efficient and secure blockchain runtimes. In the Polkadot ecosystem, accurately benchmark testing your custom pallets ensures that each extrinsic has a precise weight, representing its computational and storage demands. This process is vital for maintaining the blockchain's performance and preventing potential vulnerabilities, such as Denial of Service (DoS) attacks.</p> <p>The Polkadot SDK leverages the FRAME benchmarking framework, offering tools to measure and assign weights to extrinsics. These weights help determine the maximum number of transactions or system-level calls processed within a block. This guide covers how to use FRAME's benchmarking framework, from setting up your environment to writing and running benchmarks for your custom pallets. You'll understand how to generate accurate weights by the end, ensuring your runtime remains performant and secure.</p>"},{"location":"develop/parachains/customize-parachain/benchmarking/#the-case-for-benchmark-testing","title":"The Case for Benchmark Testing","text":"<p>Benchmark testing helps validate that the required execution time for different functions is within reasonable boundaries to ensure your blockchain runtime can handle transactions efficiently and securely. By accurately measuring the weight of each extrinsic, you can prevent service interruptions caused by computationally intensive calls that exceed block time limits. Without benchmark testing, runtime performance could be vulnerable to DoS attacks, where malicious users exploit functions with unoptimized weights.</p> <p>Benchmark testing also ensures predictable transaction fees. Weights derived from benchmark tests accurately reflect the resource usage of function calls, allowing fair fee calculation. This approach discourages abuse while maintaining network reliability.</p>"},{"location":"develop/parachains/customize-parachain/benchmarking/#benchmark-testing-and-weight","title":"Benchmark Testing and Weight","text":"<p>In Polkadot SDK-based chains, weight quantifies the computational effort needed to process transactions. This weight includes factors such as:</p> <ul> <li>Computational complexity</li> <li>Storage complexity (proof size)</li> <li>Database reads and writes </li> <li>Hardware specifications</li> </ul> <p>Benchmark testing uses real-world testing to simulate worst-case scenarios for extrinsics. The framework generates a linear model for weight calculation by running multiple iterations with varied parameters. These worst-case weights ensure blocks remain within execution limits, enabling the runtime to maintain throughput under varying loads. Excess fees can be refunded if a call uses fewer resources than expected, offering users a fair cost model.</p> <p>Because weight is a generic unit of measurement based on computation time for a specific physical machine, the weight of any function can change based on the specifications of hardware used for benchmark testing. By modeling the expected weight of each runtime function, the blockchain can calculate the number of transactions or system-level calls it can execute within a certain period of time.</p> <p>Within FRAME, each function call that is dispatched must have a <code>#[pallet::weight]</code> annotation that can return the expected weight for the worst-case scenario execution of that function given its inputs:</p> <pre><code>#[pallet::call_index(0)]\n#[pallet::weight(T::WeightInfo::do_something())]\npub fn do_something(origin: OriginFor&lt;T&gt;) -&gt; DispatchResultWithPostInfo { Ok(()) }\n</code></pre> <p>The <code>WeightInfo</code> file is automatically generated during benchmark testing. Based on these tests, this file provides accurate weights for each extrinsic.</p>"},{"location":"develop/parachains/customize-parachain/benchmarking/#benchmark-process","title":"Benchmark Process","text":"<p>Benchmark testing a pallet involves the following steps: </p> <ol> <li>Creating a <code>benchmarking.rs</code> file within your pallet's structure</li> <li>Writing a benchmarking test for each extrinsic</li> <li>Executing the benchmarking tool to calculate weights based on performance metrics</li> </ol> <p>The benchmarking tool runs multiple iterations to model worst-case execution times and determine the appropriate weight. By default, the benchmark testing pipeline is deactivated. To activate it, compile your runtime with the <code>runtime-benchmarks</code> feature flag.</p>"},{"location":"develop/parachains/customize-parachain/benchmarking/#prepare-your-environment","title":"Prepare Your Environment","text":"<p>Before writing benchmark tests, you need to ensure the <code>frame-benchmarking</code> crate is included in your pallet's <code>Cargo.toml</code> similar to the following:</p> Cargo.toml<pre><code>frame-benchmarking = { version = \"37.0.0\", default-features = false }\n</code></pre> <p>You must also ensure that you add the <code>runtime-benchmarks</code> feature flag as follows under the <code>[features]</code> section of your pallet's <code>Cargo.toml</code>:</p> Cargo.toml<pre><code>runtime-benchmarks = [\n  \"frame-benchmarking/runtime-benchmarks\",\n  \"frame-support/runtime-benchmarks\",\n  \"frame-system/runtime-benchmarks\",\n  \"sp-runtime/runtime-benchmarks\",\n]\n</code></pre> <p>Lastly, ensure that <code>frame-benchmarking</code> is included in <code>std = []</code>: </p> Cargo.toml<pre><code>std = [\n  # ...\n  \"frame-benchmarking?/std\",\n  # ...\n]\n</code></pre> <p>Once complete, you have the required dependencies for writing benchmark tests for your pallet.</p>"},{"location":"develop/parachains/customize-parachain/benchmarking/#write-benchmark-tests","title":"Write Benchmark Tests","text":"<p>Create a <code>benchmarking.rs</code> file in your pallet's <code>src/</code>. Your directory structure should look similar to the following:</p> <pre><code>my-pallet/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 lib.rs          # Main pallet implementation\n\u2502   \u2514\u2500\u2500 benchmarking.rs # Benchmarking\n\u2514\u2500\u2500 Cargo.toml\n</code></pre> <p>With the directory structure set, you can use the <code>polkadot-sdk-parachain-template</code> to get started as follows:</p> benchmarking.rs (starter template)<pre><code>//! Benchmarking setup for pallet-template\n#![cfg(feature = \"runtime-benchmarks\")]\n\nuse super::*;\nuse frame_benchmarking::v2::*;\n\n#[benchmarks]\nmod benchmarks {\n    use super::*;\n    #[cfg(test)]\n    use crate::pallet::Pallet as Template;\n    use frame_system::RawOrigin;\n\n    #[benchmark]\n    fn do_something() {\n        let caller: T::AccountId = whitelisted_caller();\n        #[extrinsic_call]\n        do_something(RawOrigin::Signed(caller), 100);\n\n        assert_eq!(Something::&lt;T&gt;::get().map(|v| v.block_number), Some(100u32.into()));\n    }\n\n    #[benchmark]\n    fn cause_error() {\n        Something::&lt;T&gt;::put(CompositeStruct { block_number: 100u32.into() });\n        let caller: T::AccountId = whitelisted_caller();\n        #[extrinsic_call]\n        cause_error(RawOrigin::Signed(caller));\n\n        assert_eq!(Something::&lt;T&gt;::get().map(|v| v.block_number), Some(101u32.into()));\n    }\n\n    impl_benchmark_test_suite!(Template, crate::mock::new_test_ext(), crate::mock::Test);\n}\n</code></pre> <p>In your benchmarking tests, employ these best practices:</p> <ul> <li>Write custom testing functions - the function <code>do_something</code> in the preceding example is a placeholder. Similar to writing unit tests, you must write custom functions to benchmark test your extrinsics. Access the mock runtime and use functions such as <code>whitelisted_caller()</code> to sign transactions and facilitate testing</li> <li>Use the <code>#[extrinsic_call]</code> macro - this macro is used when calling the extrinsic itself and is a required part of a benchmark testing function. See the `extrinsic_call Rust docs for more details</li> <li>Validate extrinsic behavior - the <code>assert_eq</code> expression ensures that the extrinsic is working properly within the benchmark context</li> </ul>"},{"location":"develop/parachains/customize-parachain/benchmarking/#add-benchmarks-to-runtime","title":"Add Benchmarks to Runtime","text":"<p>Before running the benchmarking tool, you must integrate benchmarks with your runtime as follows:</p> <ol> <li> <p>Create a <code>benchmarks.rs</code> file. This file should contain the following macro, which registers all pallets for benchmarking, as well as their respective configurations:      benchmarks.rs<pre><code>frame_benchmarking::define_benchmarks!(\n    [frame_system, SystemBench::&lt;Runtime&gt;]\n    [pallet_parachain_template, TemplatePallet]\n    [pallet_balances, Balances]\n    [pallet_session, SessionBench::&lt;Runtime&gt;]\n    [pallet_timestamp, Timestamp]\n    [pallet_message_queue, MessageQueue]\n    [pallet_sudo, Sudo]\n    [pallet_collator_selection, CollatorSelection]\n    [cumulus_pallet_parachain_system, ParachainSystem]\n    [cumulus_pallet_xcmp_queue, XcmpQueue]\n);\n</code></pre>     For example, to register a pallet named <code>pallet_parachain_template</code> for benchmark testing, add it as follows:      benchmarks.rs<pre><code>frame_benchmarking::define_benchmarks!(\n    [frame_system, SystemBench::&lt;Runtime&gt;]\n    [pallet_parachain_template, TemplatePallet]\n);\n</code></pre></p> <p>Updating <code>define_benchmarks!</code> macro is required</p> <p>If the pallet isn't included in the <code>define_benchmarks!</code> macro, the CLI cannot access and benchmark it later.</p> </li> <li> <p>Navigate to the runtime's <code>lib.rs</code> file and add the import for <code>benchmarks.rs</code> as follows: </p> lib.rs<pre><code>#[cfg(feature = \"runtime-benchmarks\")]\nmod benchmarks;\n</code></pre> <p>The <code>runtime-benchmarks</code> feature gate ensures benchmark tests are isolated from production runtime code.</p> </li> </ol>"},{"location":"develop/parachains/customize-parachain/benchmarking/#run-benchmarks","title":"Run Benchmarks","text":"<p>You can now compile your runtime with the <code>runtime-benchmarks</code> feature flag. This feature flag is crucial as the benchmarking tool will look for this feature being enabled to know when it should run benchmark tests. Follow these steps to compile the runtime with benchmarking enabled:</p> <ol> <li> <p>Run <code>build</code> with the feature flag included</p> <pre><code>cargo build --features runtime-benchmarks --release\n</code></pre> </li> <li> <p>Once compiled, run the benchmarking tool to measure extrinsic weights</p> <pre><code>./target/release/INSERT_NODE_BINARY_NAME benchmark pallet \\\n--runtime INSERT_PATH_TO_WASM_RUNTIME \\\n--pallet INSERT_NAME_OF_PALLET \\\n--extrinsic '*' \\\n--steps 20 \\\n--repeat 10 \\\n--output weights.rs\n</code></pre> <p>Flag definitions</p> <ul> <li><code>--runtime</code> - the path to your runtime's Wasm</li> <li><code>--pallet</code> - the name of the pallet you wish to benchmark. This pallet must be configured in your runtime and defined in <code>define_benchmarks</code></li> <li><code>--extrinsic</code> - which extrinsic to test. Using <code>'*'</code> implies all extrinsics will be benchmarked</li> <li><code>--output</code> - where the output of the auto-generated weights will reside</li> </ul> </li> </ol> <p>The generated <code>weights.rs</code> file contains weight annotations for your extrinsics, ready to be added to your pallet. The output should be similar to the following. Some output is omitted for brevity: </p> ./target/release/INSERT_NODE_BINARY_NAME benchmark pallet \\ --runtime INSERT_PATH_TO_WASM_RUNTIME \\ --pallet INSERT_PALLET_NAME \\ --extrinsic '*' \\ --steps 20 \\ --repeat 10 \\ --output weights.rs 2024-10-28 11:07:25 Loading WASM from ./target/release/wbuild/educhain-runtime/educhain_runtime.wasm 2024-10-28 11:07:26 Could not find genesis preset 'development'. Falling back to default. 2024-10-28 11:07:26 assembling new collators for new session 0 at #0 2024-10-28 11:07:26 assembling new collators for new session 1 at #0 2024-10-28 11:07:26 Loading WASM from ./target/release/wbuild/educhain-runtime/educhain_runtime.wasm Pallet: \"pallet_parachain_template\", Extrinsic: \"do_something\", Lowest values: [], Highest values: [], Steps: 20, Repeat: 10 ... Created file: \"weights.rs\" 2024-10-28 11:07:27 [ 0 % ] Starting benchmark: pallet_parachain_template::do_something I2024-10-28 11:07:27 [ 50 % ] Starting benchmark: pallet_parachain_template::cause_error"},{"location":"develop/parachains/customize-parachain/benchmarking/#add-benchmark-weights-to-pallet","title":"Add Benchmark Weights to Pallet","text":"<p>Once the <code>weights.rs</code> is generated, you may add the generated weights to your pallet. It is common that <code>weights.rs</code> become part of your pallet's root in <code>src/</code>:</p> <pre><code>use crate::weights::WeightInfo;\n\n/// Configure the pallet by specifying the parameters and types on which it depends.\n#[pallet::config]\npub trait Config: frame_system::Config {\n    /// A type representing the weights required by the dispatchables of this pallet.\n    type WeightInfo: WeightInfo;\n}\n</code></pre> <p>After which, you may add this to the <code>#[pallet::weight]</code> annotation in the extrinsic via the <code>Config</code>: </p> <pre><code>#[pallet::call_index(0)]\n#[pallet::weight(T::WeightInfo::do_something())]\npub fn do_something(origin: OriginFor&lt;T&gt;) -&gt; DispatchResultWithPostInfo { Ok(()) }\n</code></pre>"},{"location":"develop/parachains/customize-parachain/benchmarking/#where-to-go-next","title":"Where to Go Next","text":"<ul> <li>View the Rust Docs for a more comprehensive, low-level view of the FRAME V2 Benchmarking Suite</li> <li>Read the FRAME Benchmarking and Weights reference document, a concise guide which details how weights and benchmarking work</li> </ul>"},{"location":"develop/parachains/customize-parachain/make-custom-pallet/","title":"Make a Custom Pallet","text":""},{"location":"develop/parachains/customize-parachain/make-custom-pallet/#introduction","title":"Introduction","text":"<p>FRAME provides a powerful set of tools for blockchain development, including a library of pre-built pallets. However, its true strength lies in the ability to create custom pallets tailored to your specific needs. This section will guide you through creating your own custom pallet, allowing you to extend your blockchain's functionality in unique ways.</p> <p>To get the most out of this guide, ensure you're familiar with FRAME concepts.</p> <p>Creating custom pallets offers several advantages over relying on pre-built pallets:</p> <ul> <li>Flexibility - define runtime behavior that precisely matches your project requirements</li> <li>Modularity - combine pre-built and custom pallets to achieve the desired blockchain functionality</li> <li>Scalability - add or modify features as your project evolves</li> </ul> <p>As you follow this guide to create your custom pallet, you'll work with the following key sections:</p> <ol> <li>Imports and dependencies - bring in necessary FRAME libraries and external modules</li> <li>Runtime configuration trait - specify the types and constants required for your pallet to interact with the runtime</li> <li>Runtime events - define events that your pallet can emit to communicate state changes</li> <li>Runtime errors - define the error types that can be returned from the function calls dispatched to the runtime</li> <li>Runtime storage - declare on-chain storage items for your pallet's state</li> <li>Extrinsics (function calls) - create callable functions that allow users to interact with your pallet and execute transactions</li> </ol> <p>For additional macros you can include in a pallet, beyond those covered in this guide, refer to the pallet_macros section of the Polkadot SDK Docs.</p>"},{"location":"develop/parachains/customize-parachain/make-custom-pallet/#initial-setup","title":"Initial Setup","text":"<p>This section will guide you through the initial steps of creating the foundation for your custom FRAME pallet. You'll create a new Rust library project and set up the necessary dependencies.</p> <ol> <li> <p>Create a new Rust library project using the following <code>cargo</code> command:</p> <pre><code>cargo new --lib custom-pallet \\\n&amp;&amp; cd custom-pallet\n</code></pre> <p>This command creates a new library project named <code>custom-pallet</code> and navigates into its directory.</p> </li> <li> <p>Configure the dependencies required for FRAME pallet development in the <code>Cargo.toml</code> file as follows:</p> <pre><code>[package]\nname = \"custom-pallet\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nframe-support = { version = \"37.0.0\", default-features = false }\nframe-system = { version = \"37.0.0\", default-features = false }\ncodec = { version = \"3.6.12\", default-features = false, package = \"parity-scale-codec\", features = [\n  \"derive\",\n] }\nscale-info = { version = \"2.11.1\", default-features = false, features = [\n  \"derive\",\n] }\nsp-runtime = { version = \"39.0.0\", default-features = false }\n\n[features]\ndefault = [\"std\"]\nstd = [\n  \"frame-support/std\",\n  \"frame-system/std\",\n  \"codec/std\",\n  \"scale-info/std\",\n  \"sp-runtime/std\",\n]\n</code></pre> <p>Note</p> <p>Proper version management is crucial for ensuring compatibility and reducing potential conflicts in your project. Carefully select the versions of the packages according to your project's specific requirements:</p> <ul> <li>When developing for a specific Polkadot SDK runtime, ensure that your pallet's dependency versions match those of the target runtime</li> <li> <p>If you're creating this pallet within a Polkadot SDK workspace:</p> <ul> <li>Define the actual versions in the root <code>Cargo.toml</code> file</li> <li>Use workspace inheritance in your pallet's <code>Cargo.toml</code> to maintain consistency across your project</li> </ul> </li> <li> <p>Regularly check for updates to FRAME and Polkadot SDK dependencies to benefit from the latest features, performance improvements, and security patches</p> </li> </ul> <p>For detailed information on workspace inheritance and how to properly integrate your pallet with the runtime, refer to the Add an Existing Pallet to the Runtime page.</p> </li> <li> <p>Initialize the pallet structure by replacing the contents of <code>src/lib.rs</code> with the following scaffold code:</p> <pre><code>pub use pallet::*;\n\n#[frame_support::pallet]\npub mod pallet {\n    use frame_support::pallet_prelude::*;\n    use frame_system::pallet_prelude::*;\n\n    #[pallet::pallet]\n    pub struct Pallet&lt;T&gt;(_);\n\n    #[pallet::config]  // snip\n    #[pallet::event]   // snip\n    #[pallet::error]   // snip\n    #[pallet::storage] // snip\n    #[pallet::call]    // snip\n}\n</code></pre> <p>With this scaffold in place, you're ready to start implementing your custom pallet's specific logic and features. The subsequent sections of this guide will walk you through populating each of these components with the necessary code for your pallet's functionality.</p> </li> </ol>"},{"location":"develop/parachains/customize-parachain/make-custom-pallet/#pallet-configuration","title":"Pallet Configuration","text":"<p>Every pallet includes a Rust trait called\u00a0<code>Config</code>, which exposes configurable options and links your pallet to other parts of the runtime. All types and constants the pallet depends on must be declared within this trait. These types are defined generically and made concrete when the pallet is instantiated in the <code>runtime/src/lib.rs</code> file of your blockchain.</p> <p>In this step, you'll only configure the common types used by all pallets:</p> <ul> <li><code>RuntimeEvent</code> - since this pallet emits events, the runtime event type is required to handle them. This ensures that events generated by the pallet can be correctly processed and interpreted by the runtime</li> <li><code>WeightInfo</code> - this type defines the weights associated with the pallet's callable functions (also known as dispatchables). Weights help measure the computational cost of executing these functions. However, the <code>WeightInfo</code> type will be left unconfigured since setting up custom weights is outside the scope of this guide</li> </ul> <p>Replace the line containing the <code>#[pallet::config]</code> macro with the following code block:</p> <pre><code>#[pallet::config]\npub trait Config: frame_system::Config {\n    /// The overarching runtime event type.\n    type RuntimeEvent: From&lt;Event&lt;Self&gt;&gt; + IsType&lt;&lt;Self as frame_system::Config&gt;::RuntimeEvent&gt;;\n    /// A type representing the weights required by the dispatchables of this pallet.\n    type WeightInfo;\n}\n</code></pre>"},{"location":"develop/parachains/customize-parachain/make-custom-pallet/#pallet-events","title":"Pallet Events","text":"<p>After configuring the pallet to emit events, the next step is to define the events that can be triggered by functions within the pallet. Events provide a straightforward way to inform external entities, such as dApps, chain explorers, or users, that a significant change has occurred in the runtime. In a FRAME pallet, the details of each event and its parameters are included in the node\u2019s metadata, making them accessible to external tools and interfaces.</p> <p>The <code>generate_deposit</code> macro generates a <code>deposit_event</code> function on the <code>Pallet</code>, which converts the pallet\u2019s event type into the <code>RuntimeEvent</code> (as specified in the <code>Config</code> trait) and deposits it using <code>frame_system::Pallet::deposit_event</code>.</p> <p>This step adds an event called <code>SomethingStored</code>, which is triggered when a user successfully stores a value in the pallet. The event records both the value and the account that performed the action.</p> <p>To define events, replace the <code>#[pallet::event]</code> line with the following code block:</p> <pre><code>#[pallet::event]\n#[pallet::generate_deposit(pub(super) fn deposit_event)]\npub enum Event&lt;T: Config&gt; {\n    /// A user has successfully set a new value.\n    SomethingStored {\n        /// The new value set.\n        something: u32,\n        /// The account who set the new value.\n        who: T::AccountId,\n    },\n}\n</code></pre>"},{"location":"develop/parachains/customize-parachain/make-custom-pallet/#pallet-errors","title":"Pallet Errors","text":"<p>While events signal the successful completion of calls, errors indicate when and why a call has failed. It's essential to use informative names for errors to clearly communicate the cause of failure. Like events, error documentation is included in the node's metadata, so providing helpful descriptions is crucial.</p> <p>Errors are defined as an enum named <code>Error</code> with a generic type. Variants can have fields or be fieldless. Any field type specified in the error must implement the <code>TypeInfo</code> trait, and the encoded size of each field should be as small as possible. Runtime errors can be up to 4 bytes in size, allowing the return of additional information when needed.</p> <p>This step defines two basic errors: one for handling cases where no value has been set and another for managing arithmetic overflow.</p> <p>To define errors, replace the <code>#[pallet::error]</code> line with the following code block:</p> <pre><code>#[pallet::error]\npub enum Error&lt;T&gt; {\n    /// The value retrieved was `None` as no value was previously set.\n    NoneValue,\n    /// There was an attempt to increment the value in storage over `u32::MAX`.\n    StorageOverflow,\n}\n</code></pre>"},{"location":"develop/parachains/customize-parachain/make-custom-pallet/#pallet-storage","title":"Pallet Storage","text":"<p>To persist and store state/data within the pallet (and subsequently, the blockchain you are building), the <code>#[pallet::storage]</code> macro is used. This macro allows the definition of abstract storage within the runtime and sets metadata for that storage. It can be applied multiple times to define different storage items. Several types are available for defining storage, which you can explore in the Polkadot SDK documentation.</p> <p>This step adds a simple storage item, <code>Something</code>, which stores a single <code>u32</code> value in the pallet's runtime storage</p> <p>To define storage, replace the <code>#[pallet::storage]</code> line with the following code block:</p> <pre><code>#[pallet::storage]\npub type Something&lt;T&gt; = StorageValue&lt;_, u32&gt;;\n</code></pre>"},{"location":"develop/parachains/customize-parachain/make-custom-pallet/#pallet-dispatchable-extrinsics","title":"Pallet Dispatchable Extrinsics","text":"<p>Dispatchable functions enable users to interact with the pallet and trigger state changes. These functions are represented as \"extrinsics,\" which are similar to transactions. They must return a <code>DispatchResult</code> and be annotated with a weight and a call index.</p> <p>The <code>#[pallet::call_index]</code> macro is used to explicitly define an index for calls in the <code>Call</code> enum. This is useful for maintaining backward compatibility in the event of new dispatchables being introduced, as changing the order of dispatchables would otherwise alter their index.</p> <p>The <code>#[pallet::weight]</code> macro assigns a weight to each call, determining its execution cost.</p> <p>This section adds two dispatchable functions:</p> <ul> <li><code>do_something</code> - takes a single <code>u32</code> value, stores it in the pallet's storage, and emits an event</li> <li><code>cause_error</code> - checks if a value exists in storage. If the value is found, it increments and is stored back. If no value is present or an overflow occurs, a custom error is returned</li> </ul> <p>To implement these calls, replace the <code>#[pallet::call]</code> line with the following code block:</p> <pre><code>#[pallet::call]\nimpl&lt;T: Config&gt; Pallet&lt;T&gt; {\n    #[pallet::call_index(0)]\n    #[pallet::weight(Weight::default())]\n    pub fn do_something(origin: OriginFor&lt;T&gt;, something: u32) -&gt; DispatchResult {\n        // Check that the extrinsic was signed and get the signer.\n        let who = ensure_signed(origin)?;\n\n        // Update storage.\n        Something::&lt;T&gt;::put(something);\n\n        // Emit an event.\n        Self::deposit_event(Event::SomethingStored { something, who });\n\n        // Return a successful `DispatchResult`\n        Ok(())\n    }\n\n    #[pallet::call_index(1)]\n    #[pallet::weight(Weight::default())]\n    pub fn cause_error(origin: OriginFor&lt;T&gt;) -&gt; DispatchResult {\n        let _who = ensure_signed(origin)?;\n\n        // Read a value from storage.\n        match Something::&lt;T&gt;::get() {\n            // Return an error if the value has not been set.\n            None =&gt; Err(Error::&lt;T&gt;::NoneValue.into()),\n            Some(old) =&gt; {\n                // Increment the value read from storage. This will cause an error in the event\n                // of overflow.\n                let new = old.checked_add(1).ok_or(Error::&lt;T&gt;::StorageOverflow)?;\n                // Update the value in storage with the incremented result.\n                Something::&lt;T&gt;::put(new);\n                Ok(())\n            },\n        }\n    }\n}\n</code></pre>"},{"location":"develop/parachains/customize-parachain/make-custom-pallet/#pallet-implementation-overview","title":"Pallet Implementation Overview","text":"<p>After following all the previous steps, the pallet is now fully implemented. Below is the complete code, combining the configuration, events, errors, storage, and dispatchable functions:</p> Code <pre><code>pub use pallet::*;\n\n#[frame_support::pallet]\npub mod pallet {\n    use frame_support::pallet_prelude::*;\n    use frame_system::pallet_prelude::*;\n\n    #[pallet::pallet]\n    pub struct Pallet&lt;T&gt;(_);\n\n    #[pallet::config]\n    pub trait Config: frame_system::Config {\n        /// The overarching runtime event type.\n        type RuntimeEvent: From&lt;Event&lt;Self&gt;&gt; + IsType&lt;&lt;Self as frame_system::Config&gt;::RuntimeEvent&gt;;\n        /// A type representing the weights required by the dispatchables of this pallet.\n        type WeightInfo;\n    }\n\n    #[pallet::event]\n    #[pallet::generate_deposit(pub(super) fn deposit_event)]\n    pub enum Event&lt;T: Config&gt; {\n        /// A user has successfully set a new value.\n        SomethingStored {\n            /// The new value set.\n            something: u32,\n            /// The account who set the new value.\n            who: T::AccountId,\n        },\n    }\n\n    #[pallet::error]\n    pub enum Error&lt;T&gt; {\n        /// The value retrieved was `None` as no value was previously set.\n        NoneValue,\n        /// There was an attempt to increment the value in storage over `u32::MAX`.\n        StorageOverflow,\n    }\n\n    #[pallet::storage]\n    pub type Something&lt;T&gt; = StorageValue&lt;_, u32&gt;;\n\n    #[pallet::call]\n    impl&lt;T: Config&gt; Pallet&lt;T&gt; {\n        #[pallet::call_index(0)]\n        #[pallet::weight(Weight::default())]\n        pub fn do_something(origin: OriginFor&lt;T&gt;, something: u32) -&gt; DispatchResult {\n            // Check that the extrinsic was signed and get the signer.\n            let who = ensure_signed(origin)?;\n\n            // Update storage.\n            Something::&lt;T&gt;::put(something);\n\n            // Emit an event.\n            Self::deposit_event(Event::SomethingStored { something, who });\n\n            // Return a successful `DispatchResult`\n            Ok(())\n        }\n\n        #[pallet::call_index(1)]\n        #[pallet::weight(Weight::default())]\n        pub fn cause_error(origin: OriginFor&lt;T&gt;) -&gt; DispatchResult {\n            let _who = ensure_signed(origin)?;\n\n            // Read a value from storage.\n            match Something::&lt;T&gt;::get() {\n                // Return an error if the value has not been set.\n                None =&gt; Err(Error::&lt;T&gt;::NoneValue.into()),\n                Some(old) =&gt; {\n                    // Increment the value read from storage. This will cause an error in the event\n                    // of overflow.\n                    let new = old.checked_add(1).ok_or(Error::&lt;T&gt;::StorageOverflow)?;\n                    // Update the value in storage with the incremented result.\n                    Something::&lt;T&gt;::put(new);\n                    Ok(())\n                },\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"develop/parachains/customize-parachain/make-custom-pallet/#where-to-go-next","title":"Where to Go Next","text":"<p>With the pallet implemented, the next steps involve ensuring its reliability and performance before integrating it into a runtime. Check the following sections:</p> <ul> <li> <p>Testing - learn how to effectively test the functionality and reliability of your pallet to ensure it behaves as expected</p> </li> <li> <p>Benchmarking - explore methods to measure the performance and execution cost of your pallet</p> </li> <li> <p>Add a Pallet to the Runtime - follow this guide to include your pallet in a Polkadot SDK-based runtime, making it ready for use in your blockchain</p> </li> </ul>"},{"location":"develop/parachains/customize-parachain/overview/","title":"Overview","text":""},{"location":"develop/parachains/customize-parachain/overview/#introduction","title":"Introduction","text":"<p>The runtime is the heart of any Polkadot SDK-based blockchain, handling the essential logic that governs state changes and transaction processing. With Polkadot SDK\u2019s FRAME (Framework for Runtime Aggregation of Modularized Entities), developers gain access to a powerful suite of tools for building custom blockchain runtimes. FRAME offers a modular architecture, featuring reusable pallets and support libraries, to streamline development.</p> <p>This guide provides an overview of FRAME, its core components like pallets and system libraries, and demonstrates how to compose a runtime tailored to your specific blockchain use case. Whether you\u2019re integrating pre-built modules or designing custom logic, FRAME equips you with the tools to create scalable, feature-rich blockchains.</p>"},{"location":"develop/parachains/customize-parachain/overview/#frame-runtime-architecture","title":"FRAME Runtime Architecture","text":"<p>The following diagram illustrates how FRAME components integrate into the runtime:</p> <p></p> <p>All transactions sent to the runtime are handled by the <code>frame_executive</code> pallet, which dispatches them to the appropriate pallet for execution. These runtime modules contain the logic for specific blockchain features. The <code>frame_system</code> module provides core functions, while <code>frame_support</code> libraries offer useful tools to simplify pallet development. Together, these components form the backbone of a FRAME-based blockchain's runtime.</p>"},{"location":"develop/parachains/customize-parachain/overview/#pallets","title":"Pallets","text":"<p>Pallets are modular components within the FRAME ecosystem that encapsulate specific blockchain functionalities. These modules offer customizable business logic for various use cases and features that can be integrated into a runtime.</p> <p>Developers have the flexibility to implement any desired behavior in the core logic of the blockchain, such as:</p> <ul> <li>Exposing new transactions</li> <li>Storing information</li> <li>Enforcing business rules</li> </ul> <p>Pallets also include necessary wiring code to ensure proper integration and functionality within the runtime. FRAME provides a range of pre-built pallets for standard and common blockchain functionalities, including consensus algorithms, staking mechanisms, governance systems, and more. These pre-existing pallets serve as building blocks or templates, which developers can use as-is, modify, or reference when creating custom functionalities. </p>"},{"location":"develop/parachains/customize-parachain/overview/#pallet-structure","title":"Pallet Structure","text":"<p>Polkadot SDK heavily utilizes Rust macros, allowing developers to focus on specific functional requirements when writing pallets instead of dealing with technicalities and scaffolding code.</p> <p>A typical pallet skeleton looks like this:</p> <pre><code>pub use pallet::*;\n\n#[frame_support::pallet]\npub mod pallet {\n  use frame_support::pallet_prelude::*;\n  use frame_system::pallet_prelude::*;\n\n  #[pallet::pallet]\n  #[pallet::generate_store(pub(super) trait Store)]\n  pub struct Pallet&lt;T&gt;(_);\n\n  #[pallet::config]  // snip\n  #[pallet::event]   // snip\n  #[pallet::error]   // snip\n  #[pallet::storage] // snip\n  #[pallet::call]    // snip\n}\n</code></pre> <p>All pallets, including custom ones, can implement these attribute macros:</p> <ul> <li><code>#[frame_support::pallet]</code> - marks the module as usable in the runtime</li> <li><code>#[pallet::pallet]</code> - applied to a structure used to retrieve module information easily</li> <li><code>#[pallet::config]</code> - defines the configuration for the pallets's data types</li> <li><code>#[pallet::event]</code> - defines events to provide additional information to users</li> <li><code>#[pallet::error]</code> - lists possible errors in an enum to be returned upon unsuccessful execution</li> <li><code>#[pallet::storage]</code> - defines elements to be persisted in storage</li> <li><code>#[pallet::call]</code> - defines functions exposed as transactions, allowing dispatch to the runtime</li> </ul> <p>These macros are applied as attributes to Rust modules, functions, structures, enums, and types. They enable the pallet to be built and added to the runtime, exposing the custom logic to the outer world.</p> <p>Note</p> <p>The macros above are the core components of a pallet. For a comprehensive guide on these and additional macros, refer to the <code>pallet_macros</code> section in the Polkadot SDK documentation.</p>"},{"location":"develop/parachains/customize-parachain/overview/#support-libraries","title":"Support Libraries","text":"<p>In addition to purpose-specific pallets, FRAME offers services and core libraries that facilitate composing and interacting with the runtime:</p> <ul> <li><code>frame_system</code> pallet - provides low-level types, storage, and functions for the runtime</li> <li><code>frame_executive</code> pallet - orchestrates the execution of incoming function calls to the respective pallets in the runtime</li> <li><code>frame_support</code> crate - is a collection of Rust macros, types, traits, and modules that simplify the development of Substrate pallets</li> <li><code>frame_benchmarking</code> crate - contains common runtime patterns for benchmarking and testing purposes</li> </ul>"},{"location":"develop/parachains/customize-parachain/overview/#compose-a-runtime-with-pallets","title":"Compose a Runtime with Pallets","text":"<p>The Polkadot SDK allows developers to construct a runtime by combining various pallets, both built-in and custom-made. This modular approach enables the creation of unique blockchain behaviors tailored to specific requirements.</p> <p>The following diagram illustrates the process of selecting and combining FRAME pallets to compose a runtime:</p> <p></p> <p>This modular design allows developers to:</p> <ul> <li>Rapidly prototype blockchain systems</li> <li>Easily add or remove features by including or excluding pallets</li> <li>Customize blockchain behavior without rebuilding core components</li> <li>Leverage tested and optimized code from built-in pallets</li> </ul> <p>For more detailed information on implementing this process, refer to the following sections:</p> <ul> <li>Add a Pallet to Your Runtime</li> <li>Create a Custom Pallet</li> </ul>"},{"location":"develop/parachains/customize-parachain/pallet-testing/","title":"Pallet Testing","text":""},{"location":"develop/parachains/customize-parachain/pallet-testing/#introduction","title":"Introduction","text":"<p>Unit testing in the Polkadot SDK helps ensure that the functions provided by a pallet behave as expected. It also confirms that data and events associated with a pallet are processed correctly during interactions. The Polkadot SDK offers a set of APIs to create a test environment that can simulate runtime and mock transaction execution for both extrinsic and queries.</p> <p>This guide will explore how to mock a runtime and test a pallet. For that, the Polkadot SDK pallets use the <code>mock.rs</code> and <code>test.rs</code> files as a basis for testing pallet processes. The <code>mock.rs</code> file allows the mock runtime to be tested, and the <code>test.rs</code> file allows writing unit test functions to check the functionality of isolated pieces of code within the pallet.</p>"},{"location":"develop/parachains/customize-parachain/pallet-testing/#mocking-the-runtime","title":"Mocking the Runtime","text":"<p>To test a pallet, a mock runtime is created to simulate the behavior of the blockchain environment where the pallet will be included. This involves defining a minimal runtime configuration that only provides for the required dependencies for the tested pallet. </p> <p>For a complete example of a mocked runtime, check out the <code>mock.rs</code> file in the Solochain Template.</p> <p>A <code>mock.rs</code> file defines the mock runtime in a typical Polkadot SDK project. It includes the elements described below.</p>"},{"location":"develop/parachains/customize-parachain/pallet-testing/#runtime-composition","title":"Runtime Composition","text":"<p>This section describes the pallets included for the mocked runtime. For example, the following code snippet shows how to build a mocked runtime called <code>Test</code> that consists of the <code>frame_system</code> pallet and the <code>pallet_template</code>:</p> <pre><code>frame_support::construct_runtime!(\n    pub enum Test {\n        System: frame_system,\n        TemplateModule: pallet_template,\n    }\n);\n</code></pre>"},{"location":"develop/parachains/customize-parachain/pallet-testing/#pallets-configurations","title":"Pallets Configurations","text":"<p>This section outlines the types linked to each pallet in the mocked runtime. For testing, many of these types are simple or primitive, replacing more complex, abstract types to streamline the process.</p> <pre><code>impl frame_system::Config for Test {\n    ...\n    type Index = u64;\n    type BlockNumber = u64;\n    type Hash = H256;\n    type Hashing = BlakeTwo256;\n    type AccountId = u64;\n    ...\n}\n</code></pre> <p>The configuration should be set for each pallet existing in the mocked runtime.</p> <p>Note</p> <p>The simplification of types is for simplifying the testing process. For example, <code>AccountId</code> is <code>u64</code>, meaning a valid account address can be an unsigned integer:</p> <pre><code>let alice_account: u64 = 1;\n</code></pre>"},{"location":"develop/parachains/customize-parachain/pallet-testing/#genesis-config-initialization","title":"Genesis Config Initialization","text":"<p>To initialize the genesis storage according to the mocked runtime, the following function can be used:</p> <pre><code>pub fn new_test_ext() -&gt; sp_io::TestExternalities {\n    frame_system::GenesisConfig::&lt;Test&gt;::default()\n        .build_storage()\n        .unwrap()\n        .into()\n}\n</code></pre>"},{"location":"develop/parachains/customize-parachain/pallet-testing/#pallet-unit-testing","title":"Pallet Unit Testing","text":"<p>Once the mock runtime is in place, the next step is to write unit tests that evaluate the functionality of your pallet. Unit tests allow you to test specific pallet features in isolation, ensuring that each function behaves correctly under various conditions. These tests typically reside in your pallet\u2019s module\u2019s <code>test.rs</code> file.</p>"},{"location":"develop/parachains/customize-parachain/pallet-testing/#writing-unit-tests","title":"Writing Unit Tests","text":"<p>Unit tests in the Polkadot SDK use the Rust testing framework, and the mock runtime you\u2019ve defined earlier will serve as the test environment. Below are the typical steps involved in writing unit tests for a pallet.</p>"},{"location":"develop/parachains/customize-parachain/pallet-testing/#test-initialization","title":"Test Initialization","text":"<p>Each test starts by initializing the runtime environment, typically using the <code>new_test_ext()</code> function, which sets up the mock storage and environment.</p> <pre><code>#[test]\nfn test_pallet_functionality() {\n    new_test_ext().execute_with(|| {\n        // Test logic goes here\n    });\n}\n</code></pre>"},{"location":"develop/parachains/customize-parachain/pallet-testing/#function-call-testing","title":"Function Call Testing","text":"<p>Call the pallet\u2019s extrinsics or functions to simulate user interaction or internal logic. Use the <code>assert_ok!</code> macro to check for successful execution and <code>assert_err!</code> to verify that errors are handled properly.</p> <pre><code>#[test]\nfn it_works_for_valid_input() {\n    new_test_ext().execute_with(|| {\n        // Call an extrinsic or function\n        assert_ok!(TemplateModule::some_function(Origin::signed(1), valid_param));\n    });\n}\n\n#[test]\nfn it_fails_for_invalid_input() {\n    new_test_ext().execute_with(|| {\n        // Call an extrinsic with invalid input and expect an error\n        assert_err!(\n            TemplateModule::some_function(Origin::signed(1), invalid_param),\n            Error::&lt;Test&gt;::InvalidInput\n        );\n    });\n}\n</code></pre>"},{"location":"develop/parachains/customize-parachain/pallet-testing/#storage-testing","title":"Storage Testing","text":"<p>After calling a function or extrinsic in your pallet, it's important to verify that the state changes in the pallet's storage match the expected behavior. This ensures that data is updated correctly based on the actions taken.</p> <p>The following example shows how to test the storage behavior before and after the function call:</p> <pre><code>#[test]\nfn test_storage_update_on_extrinsic_call() {\n    new_test_ext().execute_with(|| {\n        // Check the initial storage state (before the call)\n        assert_eq!(Something::&lt;Test&gt;::get(), None);\n\n        // Dispatch a signed extrinsic, which modifies storage\n        assert_ok!(TemplateModule::do_something(RuntimeOrigin::signed(1), 42));\n\n        // Validate that the storage has been updated as expected (after the call)\n        assert_eq!(Something::&lt;Test&gt;::get(), Some(42));\n    });\n}\n</code></pre>"},{"location":"develop/parachains/customize-parachain/pallet-testing/#event-testing","title":"Event Testing","text":"<p>It\u2019s also crucial to test the events that your pallet emits during execution. By default, events generated in a pallet using the <code>#generate_deposit</code> macro are stored under the system's event storage key (system/events) as <code>EventRecord</code> entries. These can be accessed using <code>System::events()</code> or verified with specific helper methods provided by the system pallet, such as <code>assert_has_event</code> and <code>assert_last_event</code>.</p> <p>Here\u2019s an example of testing events in a mock runtime:</p> <pre><code>#[test]\nfn it_emits_events_on_success() {\n    new_test_ext().execute_with(|| {\n        // Call an extrinsic or function\n        assert_ok!(TemplateModule::some_function(Origin::signed(1), valid_param));\n\n        // Verify that the expected event was emitted\n        assert!(System::events().iter().any(|record| {\n            record.event == Event::TemplateModule(TemplateEvent::SomeEvent)\n        }));\n    });\n}\n</code></pre> <p>Some key considerations are:</p> <ul> <li>Block number - events are not emitted on the genesis block, so you need to set the block number using <code>System::set_block_number()</code> to ensure events are triggered</li> <li>Converting events - use <code>.into()</code> when instantiating your pallet\u2019s event to convert it into a generic event type, as required by the system\u2019s event storage</li> </ul>"},{"location":"develop/parachains/customize-parachain/pallet-testing/#where-to-go-next","title":"Where to Go Next","text":"<ul> <li>Dive into the full implementation of the <code>mock.rs</code> and <code>test.rs</code> files in the Solochain Template</li> <li>To evaluate the resource usage of your pallet operations, refer to the Benchmarking documentation for guidance on measuring efficiency</li> </ul>"},{"location":"develop/parachains/deployment/","title":"Deployment","text":"<p>Learn how to prepare your blockchain for deployment using the Polkadot SDK, including building deterministic Wasm runtimes and generating chain specifications.</p>"},{"location":"develop/parachains/deployment/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"develop/parachains/deployment/build-deterministic-runtime/","title":"Build a Deterministic Runtime","text":""},{"location":"develop/parachains/deployment/build-deterministic-runtime/#introduction","title":"Introduction","text":"<p>By default, the Rust compiler produces optimized Wasm binaries. These binaries are suitable for working in an isolated environment, such as local development. However, the Wasm binaries the compiler builds by default aren't guaranteed to be deterministically reproducible. Each time the compiler generates the Wasm runtime, it might produce a slightly different Wasm byte code. This is problematic in a blockchain network where all nodes must use exactly the same raw chain specification file.</p> <p>Working with builds that aren't guaranteed to be deterministically reproducible can cause other problems, too. For example, for automating the build processes for a blockchain, it is ideal that the same code always produces the same result (in terms of bytecode). Compiling the Wasm runtime with every push would produce inconsistent and unpredictable results without a deterministic build, making it difficult to integrate with any automation and likely to break a CI/CD pipeline continuously. Deterministic builds\u2014code that always compiles to exactly the same bytecode\u2014ensure that the Wasm runtime can be inspected, audited, and independently verified.</p>"},{"location":"develop/parachains/deployment/build-deterministic-runtime/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have Docker installed.</p>"},{"location":"develop/parachains/deployment/build-deterministic-runtime/#tooling-for-wasm-runtime","title":"Tooling for Wasm Runtime","text":"<p>To compile the Wasm runtime deterministically, the same tooling that produces the runtime for Polkadot, Kusama, and other Polkadot SDK-based chains can be used. This tooling, referred to collectively as the Substrate Runtime Toolbox or\u00a0<code>srtool</code>, ensures that the same source code consistently compiles to an identical Wasm blob.</p> <p>The core component of <code>srtool</code> is a Docker container executed as part of a Docker image. The name of the <code>srtool</code> Docker image specifies the version of the Rust compiler used to compile the code included in the image. For example, the image <code>paritytech/srtool:1.62.0</code> indicates that the code in the image was compiled with version <code>1.62.0</code> of the <code>rustc</code> compiler.</p>"},{"location":"develop/parachains/deployment/build-deterministic-runtime/#working-with-the-docker-container","title":"Working with the Docker Container","text":"<p>The <code>srtool-cli</code> package is a command-line utility written in Rust that installs an executable program called <code>srtool</code>. This program simplifies the interactions with the <code>srtool</code> Docker container.</p> <p>Over time, the tooling around the <code>srtool</code> Docker image has expanded to include the following tools and helper programs:</p> <ul> <li><code>srtool-cli</code> - provides a command-line interface to pull the srtool Docker image, get information about the image and tooling used to interact with it, and build the runtime using the <code>srtool</code> Docker container</li> <li><code>subwasm</code> - provides command-line options for working with the metadata and Wasm runtime built using srtool. The <code>subwasm</code> program is also used internally to perform tasks in the <code>srtool</code> image</li> <li><code>srtool-actions</code> - provides GitHub actions to integrate builds produced using the <code>srtool</code> image with your GitHub CI/CD pipelines</li> <li><code>srtool-app</code> - provides a simple graphical user interface for building the runtime using the <code>srtool</code> Docker image</li> </ul>"},{"location":"develop/parachains/deployment/build-deterministic-runtime/#prepare-the-environment","title":"Prepare the Environment","text":"<p>It is recommended to install the <code>srtool-cli</code> program to work with the Docker image using a simple command-line interface.</p> <p>To prepare the environment:</p> <ol> <li> <p>Verify that Docker is installed by running the following command:</p> <pre><code>docker --version\n</code></pre> <p>If Docker is installed, the command will display version information:</p> <p> docker --version Docker version 20.10.17, build 100c701 </p> </li> <li> <p>Install the <code>srtool</code> command-line interface by running the following command:</p> <pre><code>cargo install --git https://github.com/chevdor/srtool-cli\n</code></pre> </li> <li> <p>View usage information for the <code>srtool</code> command-line interface by running the following command:</p> <pre><code>srtool help\n</code></pre> </li> <li> <p>Download the latest <code>srtool</code> Docker image by running the following command:</p> <pre><code>srtool pull\n</code></pre> </li> </ol>"},{"location":"develop/parachains/deployment/build-deterministic-runtime/#start-a-deterministic-build","title":"Start a Deterministic Build","text":"<p>After preparing the environment, the Wasm runtime can be compiled using the\u00a0<code>srtool</code>\u00a0Docker image.</p> <p>To build the runtime, you need to open your Polkadot SDK-based project in a terminal shell and run the following command:</p> <pre><code>srtool build --app --package INSERT_RUNTIME_PACKAGE_NAME --runtime-dir INSERT_RUNTIME_PATH \n</code></pre> <ul> <li>The name specified for the <code>--package</code> should be the name defined in the <code>Cargo.toml</code> file for the runtime</li> <li> <p>The path specified for the <code>--runtime-dir</code> should be the path to the <code>Cargo.toml</code> file for the runtime. For example:</p> <pre><code>node/\npallets/\nruntime/\n\u251c\u2500\u2500lib.rs\n\u2514\u2500\u2500Cargo.toml # INSERT_RUNTIME_PATH should be the path to this file\n...\n</code></pre> </li> <li> <p>If the <code>Cargo.toml</code> file for the runtime is located in a <code>runtime</code> subdirectory, for example, <code>runtime/kusama</code>, the <code>--runtime-dir</code> parameter can be omitted</p> </li> </ul>"},{"location":"develop/parachains/deployment/build-deterministic-runtime/#use-srtool-in-github-actions","title":"Use srtool in GitHub Actions","text":"<p>To add a GitHub workflow for building the runtime:</p> <ol> <li>Create a <code>.github/workflows</code> directory in the chain's directory</li> <li>In the <code>.github/workflows</code> directory, click Add file, then select Create new file</li> <li> <p>Copy the sample GitHub action from <code>basic.yml</code> example in the <code>srtools-actions</code> repository and paste it into the file you created in the previous step</p> <code>basic.yml</code> <pre><code>name: Srtool build\n\non: push\n\njobs:\n  srtool:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        chain: [\"asset-hub-kusama\", \"asset-hub-westend\"]\n    steps:\n      - uses: actions/checkout@v3\n      - name: Srtool build\n        id: srtool_build\n        uses: chevdor/srtool-actions@v0.8.0\n        with:\n          chain: ${{ matrix.chain }}\n          runtime_dir: polkadot-parachains/${{ matrix.chain }}-runtime\n      - name: Summary\n        run: |\n          echo '${{ steps.srtool_build.outputs.json }}' | jq . &gt; ${{ matrix.chain }}-srtool-digest.json\n          cat ${{ matrix.chain }}-srtool-digest.json\n          echo \"Runtime location: ${{ steps.srtool_build.outputs.wasm }}\"\n</code></pre> </li> <li> <p>Modify the settings in the sample action</p> <p>For example, modify the following settings:</p> <ul> <li>The name of the chain</li> <li>The name of the runtime package</li> <li>The location of the runtime</li> </ul> </li> <li> <p>Type a name for the action file and commit</p> </li> </ol>"},{"location":"develop/parachains/deployment/build-deterministic-runtime/#use-the-srtool-image-via-docker-hub","title":"Use the srtool Image via Docker Hub","text":"<p>If utilizing <code>srtool-cli</code> or <code>srtool-app</code> isn't an option, the <code>paritytech/srtool</code> container image can be used directly via Docker Hub.</p> <p>To pull the image from Docker Hub:</p> <ol> <li>Sign in to Docker Hub</li> <li>Type <code>paritytech/srtool</code> in the search field and press enter</li> <li>Click paritytech/srtool, then click Tags</li> <li>Copy the command for the image you want to pull</li> <li>Open a terminal shell on your local computer</li> <li> <p>Paste the command you copied from the Docker Hub. For example, you might run a command similar to the following, which downloads and unpacks the image:</p> <pre><code>docker pull paritytech/srtool:1.62.0\n</code></pre> </li> </ol>"},{"location":"develop/parachains/deployment/build-deterministic-runtime/#naming-convention-for-images","title":"Naming Convention for Images","text":"<p>Keep in mind that there is no <code>latest</code> tag for the <code>srtool</code> image. Ensure that the image selected is compatible with the locally available version of the Rust compiler.</p> <p>The naming convention for <code>paritytech/srtool</code> Docker images specifies the version of the Rust compiler used to compile the code included in the image. Some images specify both a compiler version and the version of the build script used. For example, an image named <code>paritytech/srtool:1.62.0-0.9.19</code> was compiled with version <code>1.62.0</code> of the <code>rustc</code> compiler and version <code>0.9.19</code> of the build script. Images that only specify the compiler version always contain the software's latest version.</p>"},{"location":"develop/parachains/deployment/generate-chain-specs/","title":"Generate Chain Specs","text":""},{"location":"develop/parachains/deployment/generate-chain-specs/#introduction","title":"Introduction","text":"<p>A chain specification collects information that describes a Polkadot SDK-based network. A chain specification is a crucial parameter when starting a node, providing the genesis configurations, bootnodes, and other parameters relating to that particular network. It identifies the network a blockchain node connects to, the other nodes it initially communicates with, and the initial state that nodes must agree on to produce blocks.</p> <p>The chain specification is defined using the <code>ChainSpec</code> struct. This struct separates the information required for a chain into two parts:</p> <ul> <li> <p>Client specification - contains information the node uses to communicate with network participants and send data to telemetry endpoints. Many of these chain specification settings can be overridden by command-line options when starting a node or can be changed after the blockchain has started</p> </li> <li> <p>Initial genesis state - agreed upon by all nodes in the network. It must be set when the blockchain is first started and cannot be changed after that without starting a whole new blockchain</p> </li> </ul>"},{"location":"develop/parachains/deployment/generate-chain-specs/#node-settings-customization","title":"Node Settings Customization","text":"<p>For the node, the chain specification controls information such as:</p> <ul> <li>The bootnodes the node will communicate with</li> <li>The server endpoints for the node to send telemetry data to</li> <li>The human and machine-readable names for the network the node will connect to</li> </ul> <p>The chain specification can be customized to include additional information. For example, you can configure the node to connect to specific blocks at specific heights to prevent long-range attacks when syncing a new node from genesis.</p> <p>Note that you can customize node settings after genesis. However, nodes only add peers that use the same <code>protocolId</code>.</p>"},{"location":"develop/parachains/deployment/generate-chain-specs/#genesis-configuration-customization","title":"Genesis Configuration Customization","text":"<p>All nodes in the network must agree on the genesis state before they can agree on any subsequent blocks. The information configured in the genesis portion of a chain specification is used to create a genesis block. When you start the first node, it takes effect and cannot be overridden with command-line options. However, you can configure some information in the genesis section of a chain specification. For example, you can customize it to include information such as:</p> <ul> <li>Initial account balances</li> <li>Accounts that are initially part of a governance council</li> <li>The account that controls the <code>sudo</code> key</li> <li>Any other genesis state for a pallet</li> </ul> <p>Nodes also require the compiled Wasm to execute the runtime logic on the chain, so the initial runtime must also be supplied in the chain specification. For a more detailed look at customizing the genesis chain specification, be sure to check out the Polkadot SDK Docs.</p>"},{"location":"develop/parachains/deployment/generate-chain-specs/#declaring-storage-items-for-a-runtime","title":"Declaring Storage Items for a Runtime","text":"<p>A runtime usually requires some storage items to be configured at genesis. This includes the initial state for pallets, for example, how much balance\u00a0specific accounts\u00a0have, or which account will have sudo permissions.</p> <p>These storage values are configured in the genesis portion of the chain specification. You can create a patch file and ingest it using the <code>chain-spec-builder</code> utility, that is explained in the Creating a Custom Chain Specification section.</p>"},{"location":"develop/parachains/deployment/generate-chain-specs/#chain-specification-json-format","title":"Chain Specification JSON Format","text":"<p>Users generally work with the JSON format of the chain specification. Internally, the chain specification is embedded in the <code>GenericChainSpec</code> struct, with specific properties accessible through the <code>ChainSpec</code> struct. The chain specification includes the following keys:</p> <ul> <li><code>name</code> - the human-readable name for the network</li> <li><code>id</code> - the machine-readable identifier for the network</li> <li><code>chainType</code> - the type of chain to start (refer to <code>ChainType</code> for more details)</li> <li><code>bootNodes</code> - a list of multiaddresses belonging to the chain's boot nodes</li> <li><code>telemetryEndpoints</code> - an optional list of multiaddresses for telemetry endpoints with verbosity levels ranging from 0 to 9 (0 being the lowest verbosity)</li> <li><code>protocolId</code> - the optional protocol identifier for the network</li> <li><code>forkId</code> - an optional fork ID that should typically be left empty; it can be used to signal a fork at the network level when two chains share the same genesis hash</li> <li><code>properties</code> - custom properties provided as a key-value JSON object</li> <li><code>codeSubstitutes</code> - an optional mapping of block numbers to Wasm code</li> <li><code>genesis</code> - the genesis configuration for the chain</li> </ul> <p>For example, the following JSON shows a basic chain specification file:</p> <pre><code>{\n    \"name\": \"chainName\",\n    \"id\": \"chainId\",\n    \"chainType\": \"Local\",\n    \"bootNodes\": [],\n    \"telemetryEndpoints\": null,\n    \"protocolId\": null,\n    \"properties\": null,\n    \"codeSubstitutes\": {},\n    \"genesis\": {\n        \"code\": \"0x...\"\n    }\n}\n</code></pre>"},{"location":"develop/parachains/deployment/generate-chain-specs/#creating-a-custom-chain-specification","title":"Creating a Custom Chain Specification","text":"<p>To create a custom chain specification, you can use the <code>chain-spec-builder</code> tool. This is a CLI tool that is used to generate chain specifications from the runtime of a node. To install the tool, run the following command:</p> <pre><code>cargo install staging-chain-spec-builder\n</code></pre> <p>To verify the installation, run the following:</p> <pre><code>chain-spec-builder --help\n</code></pre>"},{"location":"develop/parachains/deployment/generate-chain-specs/#plain-chain-specifications","title":"Plain Chain Specifications","text":"<p>To create a plain chain specification, you can use the following utility within your project:</p> <pre><code>chain-spec-builder create -r &lt;INSERT_RUNTIME_WASM_PATH&gt; &lt;INSERT_COMMAND&gt; \n</code></pre> <p>Note</p> <p>Before running the command, ensure that the runtime has been compiled and is available at the specified path.</p> <p>Ensure to replace <code>&lt;INSERT_RUNTIME_WASM_PATH&gt;</code> with the path to the runtime Wasm file and <code>&lt;INSERT_COMMAND&gt;</code> with the command to insert the runtime into the chain specification. The available commands are:</p> <ul> <li><code>patch</code> - overwrites the runtime's default genesis config with the provided patch. You can check the following patch file as a reference</li> <li><code>full</code> - build the genesis config for runtime using the JSON file. No defaults will be used. As a reference, you can check the following full file</li> <li><code>default</code> - gets the default genesis config for the runtime and uses it in <code>ChainSpec</code>. Please note that the default genesis config may not be valid. For some runtimes, initial values should be added there (e.g., session keys, BABE epoch)</li> <li><code>named-preset</code> - uses named preset provided by the runtime to build the chain spec</li> </ul>"},{"location":"develop/parachains/deployment/generate-chain-specs/#raw-chain-specifications","title":"Raw Chain Specifications","text":"<p>With runtime upgrades, the blockchain's runtime can be upgraded with newer business logic. Chain specifications contain information structured in a way that the node's runtime can understand. For example, consider this excerpt of a common entry for a chain specification:</p> <pre><code>\"sudo\": {\n    \"key\": \"5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY\"\n}\n</code></pre> <p>In the plain chain spec JSON file, the keys and associated values are in a human-readable format, which can be used to initialize the genesis storage. When the chain specification is loaded, the runtime converts these readable values into storage items within the trie. However, for long-lived networks like testnets or production chains, using the raw format for storage initialization is preferred. This avoids the need for conversion by the runtime and ensures that storage items remain consistent, even when runtime upgrades occur.</p> <p>To enable a node with an upgraded runtime to synchronize with a chain from genesis, the plain chain specification is encoded in a raw format. The raw format allows the distribution of chain specifications that all nodes can use to synchronize the chain even after runtime upgrades.</p> <p>To convert a plain chain specification to a raw chain specification, you can use the following utility:</p> <pre><code>chain-spec-builder convert-to-raw chain_spec.json\n</code></pre> <p>After the conversion to the raw format, the <code>sudo key</code> snippet looks like this:</p> <pre><code>\"0x50a63a871aced22e88ee6466fe5aa5d9\": \"0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d\",\n</code></pre> <p>The raw chain specification can be used to initialize the genesis storage for a node.</p>"},{"location":"develop/parachains/deployment/generate-chain-specs/#where-to-go-next","title":"Where to Go Next","text":"<p>After generating a chain specification, you can use it to initialize the genesis storage for a node. Refer to the following guides to learn how to proceed with the deployment of your blockchain:</p> <ul> <li>Obtain Coretime - learn how to obtain the necessary coretime configuration to synchronize your blockchain\u2019s timestamping and enhance its performance</li> <li>Deployment - explore the steps required to deploy your chain specification, ensuring a smooth launch of your network and proper node operation</li> <li>Maintenance - discover best practices for maintaining your blockchain post-deployment, including how to manage upgrades and monitor network health</li> </ul>"},{"location":"develop/parachains/deployment/obtain-coretime/","title":"Obtain Coretime","text":""},{"location":"develop/parachains/deployment/obtain-coretime/#introduction","title":"Introduction","text":"<p>Securing coretime is essential for operating a parachain on Polkadot. It provides your parachain with guaranteed computational resources and access to Polkadot's shared security model, ensuring your blockchain can process transactions, maintain its state, and interact securely with other parachains in the network. Without coretime, a parachain cannot participate in the ecosystem or leverage the relay chain's validator set for security.</p> <p>Coretime represents the computational resources allocated to your parachain on the Polkadot network. It determines when and how often your parachain can produce blocks and have them validated by the relay chain.</p> <p>There are two primary methods to obtain coretime:</p> <ul> <li>Bulk coretime - purchase computational resources in advance for a full month</li> <li>On-demand coretime - buy computational resources as needed for individual block production</li> </ul> <p>This guide explains the different methods of obtaining coretime and walks through the necessary steps to get your parachain running. </p>"},{"location":"develop/parachains/deployment/obtain-coretime/#prerequisites","title":"Prerequisites","text":"<p>Before obtaining coretime, ensure you have:</p> <ul> <li>Developed your parachain runtime using the Polkadot SDK</li> <li>Set up and configured a parachain collator for your target relay chain</li> <li>Successfully compiled your parachain collator node</li> <li>Generated and exported your parachain's genesis state</li> <li>Generated and exported your parachain's validation code (Wasm)</li> </ul>"},{"location":"develop/parachains/deployment/obtain-coretime/#initial-setup-steps","title":"Initial Setup Steps","text":"<ol> <li> <p>Reserve a unique identifier, <code>ParaID</code>, for your parachain:</p> <ol> <li>Connect to the relay chain</li> <li>Submit the <code>registrar.reserve</code> extrinsic</li> </ol> <p>Upon success, you'll receive a registered <code>ParaID</code></p> </li> <li> <p>Register your parachain's essential information by submitting the <code>registrar.register</code> extrinsic with the following parameters:</p> <ul> <li><code>id</code> - your reserved <code>ParaID</code></li> <li><code>genesisHead</code> - your exported genesis state</li> <li><code>validationCode</code> - your exported Wasm validation code</li> </ul> </li> <li> <p>Start your parachain collator and begin synchronization with the relay chain</p> </li> </ol>"},{"location":"develop/parachains/deployment/obtain-coretime/#obtaining-coretime","title":"Obtaining Coretime","text":""},{"location":"develop/parachains/deployment/obtain-coretime/#bulk-coretime","title":"Bulk Coretime","text":"<p>Bulk coretime provides several advantages:</p> <ul> <li>Monthly allocation of resources</li> <li>Guaranteed block production slots (every 12 seconds, or 6 seconds with Asynchronous Backing)</li> <li>Priority renewal rights</li> <li>Protection against price fluctuations</li> <li>Ability to split and resell unused coretime</li> </ul> <p>To purchase bulk coretime:</p> <ol> <li>Access the Coretime system parachain</li> <li>Interact with the Broker pallet</li> <li>Purchase your desired amount of coretime</li> <li>Assign the purchased core to your registered <code>ParaID</code></li> </ol> <p>After successfully obtaining coretime, your parachain will automatically start producing blocks at regular intervals.</p> <p>For current marketplaces and pricing, consult the Coretime Marketplaces page on the Polkadot Wiki.</p>"},{"location":"develop/parachains/deployment/obtain-coretime/#on-demand-coretime","title":"On-demand Coretime","text":"<p>On-demand coretime allows for flexible, as-needed block production. To purchase:</p> <ol> <li>Ensure your collator node is fully synchronized with the relay chain</li> <li> <p>From the account that registered the <code>ParaID</code>, submit the <code>onDemand.placeOrderAllowDeath</code> extrinsic with:</p> <ul> <li><code>maxAmountFor</code> - sufficient funds for the transaction</li> <li><code>paraId</code> - your registered <code>ParaID</code></li> </ul> </li> </ol> <p>After succesfully executing the extrinsic, your parachain will produce a block.</p>"},{"location":"develop/parachains/get-started/","title":"Get Started","text":"<p>Learn how to start building with the Polkadot SDK, from installation and basic concepts to creating and deploying your own custom blockchain.</p>"},{"location":"develop/parachains/get-started/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"develop/parachains/get-started/build-custom-parachains/","title":"Build Custom Parachains","text":""},{"location":"develop/parachains/get-started/build-custom-parachains/#introduction","title":"Introduction","text":"<p>Building custom parachains with the Polkadot SDK allows developers to create specialized blockchain solutions tailored to unique requirements. By leveraging Substrate\u2014a Rust-based, modular blockchain development framework\u2014the Polkadot SDK provides powerful tools to construct chains that can either stand-alone or connect to Polkadot\u2019s shared security network as parachains. This flexibility empowers projects across various sectors to launch blockchains that meet specific functional, security, and scalability needs.</p> <p>This guide covers the core steps for building a custom blockchain using the Polkadot SDK, starting from pre-built chain templates. These templates simplify development, providing an efficient starting point that can be further customized, allowing you to focus on implementing the features and modules that set your blockchain apart.</p>"},{"location":"develop/parachains/get-started/build-custom-parachains/#starting-from-templates","title":"Starting from Templates","text":"<p>Using pre-built templates is an efficient way to begin building a custom blockchain. Templates provide a foundational setup with pre-configured modules, letting developers avoid starting from scratch and instead focus on customization. Depending on your project\u2019s goals\u2014whether you want a simple test chain, a standalone chain, or a parachain that integrates with Polkadot\u2019s relay chains\u2014there are templates designed to suit different levels of complexity and scalability.</p> <p>Within the Polkadot SDK, the following templates are available to get you started:</p> <ul> <li> <p><code>minimal-template</code> - includes only the essential components necessary for a functioning blockchain. It\u2019s ideal for developers who want to gain familiarity with blockchain basics and test simple customizations before scaling up</p> </li> <li> <p><code>solochain-template</code> - provides a foundation for creating standalone blockchains with moderate features, including a simple consensus mechanism and several core FRAME pallets. It\u2019s a solid starting point for developers who want a fully functional chain that doesn\u2019t depend on a relay chain</p> </li> <li> <p><code>parachain-template</code> - designed for connecting to relay chains like Polkadot, Kusama, or Paseo, this template enables a chain to operate as a parachain. For projects aiming to integrate with Polkadot\u2019s ecosystem, this template offers a great starting point</p> </li> </ul> <p>In addition, several external templates offer unique features and can align with specific use cases or developer familiarity:</p> <ul> <li> <p><code>OpenZeppelin</code> - offers two flexible starting points:</p> <ul> <li>The <code>generic-runtime-template</code> provides a minimal setup with essential pallets and secure defaults, creating a reliable foundation for custom blockchain development</li> <li>The <code>evm-runtime-template</code> enables EVM compatibility, allowing developers to migrate Solidity contracts and EVM-based dApps. This template is ideal for Ethereum developers looking to leverage Substrate's capabilities</li> </ul> </li> <li> <p><code>Tanssi</code> - provides developers with pre-built templates that can help accelerate the process of creating appchain</p> </li> <li> <p><code>Pop Network</code> - designed with user-friendliness in mind, Pop Network offers an approachable starting point for new developers, with a simple CLI interface for creating appchains </p> </li> </ul> <p>Choosing a suitable template depends on your project\u2019s unique requirements, level of customization, and integration needs. Starting from a template speeds up development and lets you focus on implementing your chain\u2019s unique features rather than the foundational blockchain setup.</p>"},{"location":"develop/parachains/get-started/build-custom-parachains/#high-level-steps-to-build-a-custom-chain","title":"High-Level Steps to Build a Custom Chain","text":"<p>Building a custom blockchain with the Polkadot SDK involves several core steps, from environment setup to deployment. Here\u2019s a breakdown of each stage:</p> <ol> <li> <p>Set up the development environment - install Rust and configure all necessary dependencies to work with the Polkadot SDK (for more information, check the Install Polkadot SDK dependencies page). Ensuring your environment is correctly set up from the start is crucial for avoiding compatibility issues later</p> </li> <li> <p>Clone the chain template - start by downloading the code for one of the pre-built templates that best aligns with your project needs. Each template offers a different configuration, so select one based on your chain\u2019s intended functionality</p> </li> <li> <p>Define your chain's custom logic - with your chosen template, check the runtime configuration to customize the chain\u2019s functionality. Polkadot\u2019s modular \u201cpallet\u201d system lets you easily add or modify features like account balances, transaction handling, and staking. Creating custom pallets to implement unique features and combining them with existing ones enables you to define the unique aspects of your chain</p> </li> <li> <p>Test and debug - testing is essential to ensure your custom chain works as intended. Conduct unit tests for individual pallets and integration tests for interactions between pallets</p> </li> <li> <p>Compile - after finalizing and testing your custom configurations, compile the blockchain to generate the necessary executable files for running a node. Run the node locally to validate that your customizations work as expected and that your chain is stable and responsive</p> </li> </ol> <p>Each of these steps is designed to build on the last, helping ensure that your custom blockchain is functional, optimized, and ready for deployment within the Polkadot ecosystem or beyond.</p>"},{"location":"develop/parachains/get-started/build-custom-parachains/#where-to-go-next","title":"Where to Go Next","text":"<p>Once your chain is functional locally, depending on your project\u2019s goals, you can deploy to a TestNet to monitor performance and gather feedback or launch directly on a MainNet. To learn more about this process, check the Deploy a Parachain section of the documentation.</p> <p>After deployment, regular monitoring and maintenance are essential to ensure that the chain is functioning as expected. Developers need to be able to monitor the chain's performance, identify issues, and troubleshoot problems. Key activities include tracking network health, node performance, and transaction throughput. It's also essential to test the blockchain\u2019s scalability under high load and perform security audits regularly to prevent vulnerabilities. For more information on monitoring and maintenance, refer to the Maintenance section.</p>"},{"location":"develop/parachains/get-started/deploy-parachain-to-polkadot/","title":"Deploy a Parachain","text":""},{"location":"develop/parachains/get-started/deploy-parachain-to-polkadot/#introduction","title":"Introduction","text":"<p>Deploying a blockchain with the Polkadot SDK is a critical step in transforming a locally developed network into a secure, fully functioning system for public or private use. It involves more than just launching a runtime; you'll need to prepare the chain specification, ensure ecosystem compatibility, and plan for long-term maintenance and updates.</p> <p>Whether deploying a test network for development or a mainnet for production, this guide highlights the essential steps to get your blockchain operational. It provides an overview of the deployment process, introducing key concepts, tools, and best practices for a smooth transition from development to production.</p>"},{"location":"develop/parachains/get-started/deploy-parachain-to-polkadot/#deployment-process","title":"Deployment Process","text":"<p>Taking your Polkadot SDK-based blockchain from a local environment to production involves several steps, ensuring your network is stable, secure, and ready for real-world use. The following diagram outlines the process at a high level:</p> <pre><code>flowchart TD\n    %% Group 1: Pre-Deployment\n    subgraph group1 [Pre-Deployment]\n        direction LR\n        A(\"Local \\nDevelopment \\nand Testing\") --&gt; B(\"Runtime \\nCompilation\")\n        B --&gt; C(\"Generate \\nChain \\nSpecifications\")\n        C --&gt; D(\"Prepare \\nDeployment \\nEnvironment\")\n        D --&gt; E(\"Acquire \\nCoretime\")\n    end\n\n    %% Group 2: Deployment\n    subgraph group2 [Deployment]\n        F(\"Launch \\nand \\nMonitor\")\n    end\n\n    %% Group 3: Post-Deployment\n    subgraph group3 [Post-Deployment]\n        G(\"Maintenance \\nand \\nUpgrades\")\n    end\n\n    %% Connections Between Groups\n    group1 --&gt; group2\n    group2 --&gt; group3\n\n    %% Styling\n    style group1 fill:#ffffff,stroke:#6e7391,stroke-width:1px\n    style group2 fill:#ffffff,stroke:#6e7391,stroke-width:1px\n    style group3 fill:#ffffff,stroke:#6e7391,stroke-width:1px</code></pre> <ul> <li> <p>Local development and testing - the process begins with local development and testing. Developers focus on building the runtime by selecting and configuring the necessary pallets while refining network features. In this phase, it's essential to run a local TestNet to verify transactions and ensure the blockchain behaves as expected. Unit and integration tests are also crucial for ensuring the network works as expected before launch. Thorough testing is conducted, not only for individual components but also for interactions between pallets</p> </li> <li> <p>Runtime compilation - Polkadot SDK-based blockchains are built with Wasm, a highly portable and efficient format. Compiling your blockchain's runtime into Wasm ensures it can be executed reliably across various environments, guaranteeing network-wide compatibility and security. The srtool is helpful for this purpose since it allows you to compile deterministic runtimes</p> </li> <li> <p>Generate chain specifications - the chain spec file defines the structure and configuration of your blockchain. It includes initial node identities, session keys, and other parameters. Defining a well thought-out chain specification ensures that your network will operate smoothly and according to your intended design</p> </li> <li> <p>Deployment environment - whether launching a local test network or a production-grade blockchain, selecting the proper infrastructure is vital. For further information about these topics, see the Infrastructure section</p> </li> <li> <p>Acquire coretime - to build on top of the Polkadot network, users need to acquire coretime (either on-demand or in bulk) to access the computational resources of the relay chain. This allows for the secure validation of parachain blocks through a randomized selection of relay chain validators</p> <p>Note</p> <p>If you\u2019re building a standalone blockchain (solochain) that won\u2019t connect to Polkadot as a parachain, you can skip this step, as there\u2019s no need to acquire coretime or implement Cumulus .</p> </li> <li> <p>Launch and monitor - once everything is configured, you can launch the blockchain, initiating the network with your chain spec and Wasm runtime. Validators or collators will begin producing blocks, and the network will go live. Post-launch, monitoring is vital to ensuring network health\u2014tracking block production, node performance, and overall security</p> </li> <li> <p>Maintenance and upgrade - a blockchain continues to evolve post-deployment. As the network expands and adapts, it may require runtime upgrades, governance updates, coretime renewals, and even modifications to the underlying code. For an in-depth guide on this topic, see the Maintenance section</p> </li> </ul>"},{"location":"develop/parachains/get-started/deploy-parachain-to-polkadot/#where-to-go-next","title":"Where to Go Next","text":"<p>Deploying a Polkadot SDK-based blockchain is a multi-step process that requires careful planning, from generating chain specs and compiling the runtime to managing post-launch updates. By understanding the deployment process and utilizing the right tools, developers can confidently take their blockchain from development to production. For more on this topic, check out the following resources:</p> <ul> <li>Generate Chain Specifications - learn how to generate a chain specification for your blockchain</li> <li>Building Deterministic Runtimes - learn how to build deterministic runtimes for your blockchain</li> <li>Infrastructure - learn about the different infrastructure options available for your blockchain</li> <li>Maintenance - discover how to manage updates on your blockchain to ensure smooth operation</li> </ul>"},{"location":"develop/parachains/get-started/install-polkadot-sdk/","title":"Install Polkadot SDK Dependencies","text":"<p>This guide provides step-by-step instructions for installing the dependencies you need to work with the Polkadot SDK-based chains on macOS, Linux, and Windows. Follow the appropriate section for your operating system to ensure all necessary tools are installed and configured properly.</p>"},{"location":"develop/parachains/get-started/install-polkadot-sdk/#macos","title":"macOS","text":"<p>You can install Rust and set up a Substrate development environment on Apple macOS computers with Intel or Apple M1 processors.</p>"},{"location":"develop/parachains/get-started/install-polkadot-sdk/#before-you-begin","title":"Before You Begin","text":"<p>Before you install Rust and set up your development environment on macOS, verify that your computer meets the following basic requirements:</p> <ul> <li>Operating system version is 10.7 Lion or later</li> <li>Processor speed of at least 2 GHz. Note that 3 GHz is recommended</li> <li>Memory of at least 8 GB RAM. Note that 16 GB is recommended</li> <li>Storage of at least 10 GB of available space</li> <li>Broadband Internet connection</li> </ul>"},{"location":"develop/parachains/get-started/install-polkadot-sdk/#install-homebrew","title":"Install Homebrew","text":"<p>In most cases, you should use Homebrew to install and manage packages on macOS computers. If you don't already have Homebrew installed on your local computer, you should download and install it before continuing.</p> <p>To install Homebrew:</p> <ol> <li> <p>Open the Terminal application</p> </li> <li> <p>Download and install Homebrew by running the following command:</p> <pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\"\n</code></pre> </li> <li> <p>Verify Homebrew has been successfully installed by running the following command:</p> <pre><code>brew --version\n</code></pre> <p>The command displays output similar to the following:</p> <p> brew --version Homebrew 4.3.15 </p> </li> </ol>"},{"location":"develop/parachains/get-started/install-polkadot-sdk/#support-for-apple-silicon","title":"Support for Apple Silicon","text":"<p>Protobuf must be installed before the build process can begin. To install it, run the following command:</p> <pre><code>brew install protobuf\n</code></pre>"},{"location":"develop/parachains/get-started/install-polkadot-sdk/#install-required-packages-and-rust","title":"Install Required Packages and Rust","text":"<p>Because the blockchain requires standard cryptography to support the generation of public/private key pairs and the validation of transaction signatures, you must also have a package that provides cryptography, such as <code>openssl</code>.</p> <p>To install <code>openssl</code> and the Rust toolchain on macOS:</p> <ol> <li> <p>Open the Terminal application</p> </li> <li> <p>Ensure you have an updated version of Homebrew by running the following command:</p> <pre><code>brew update\n</code></pre> </li> <li> <p>Install the <code>openssl</code> package by running the following command:</p> <pre><code>brew install openssl\n</code></pre> </li> <li> <p>Download the <code>rustup</code> installation program and use it to install Rust by running the following    command:</p> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre> </li> <li> <p>Follow the prompts displayed to proceed with a default installation</p> </li> <li> <p>Update your current shell to include Cargo by running the following command:</p> <pre><code>source ~/.cargo/env\n</code></pre> </li> <li> <p>Configure the Rust toolchain to default to the latest stable version by running the following    commands:</p> <pre><code>rustup default stable\nrustup update\nrustup target add wasm32-unknown-unknown\n</code></pre> </li> <li> <p>Add the <code>nightly</code> release and the <code>nightly</code> Wasm targets to your development    environment by running the following commands:</p> <pre><code>rustup update nightly\nrustup target add wasm32-unknown-unknown --toolchain nightly\n</code></pre> </li> <li> <p>Verify your installation</p> </li> <li> <p>Install <code>cmake</code> using the following command:</p> <pre><code>brew install cmake\n</code></pre> </li> </ol>"},{"location":"develop/parachains/get-started/install-polkadot-sdk/#linux","title":"Linux","text":"<p>Rust supports most Linux distributions. Depending on the specific distribution and version of the operating system you use, you might need to add some software dependencies to your environment. In general, your development environment should include a linker or C-compatible compiler, such as <code>clang</code> and an appropriate integrated development environment (IDE).</p>"},{"location":"develop/parachains/get-started/install-polkadot-sdk/#before-you-begin-linux","title":"Before You Begin","text":"<p>Check the documentation for your operating system for information about the installed packages and how to download and install any additional packages you might need. For example, if you use Ubuntu, you can use the Ubuntu Advanced Packaging Tool (<code>apt</code>) to install the <code>build-essential</code> package:</p> <pre><code>sudo apt install build-essential\n</code></pre> <p>At a minimum, you need the following packages before you install Rust:</p> <pre><code>clang curl git make\n</code></pre> <p>Because the blockchain requires standard cryptography to support the generation of public/private key pairs and the validation of transaction signatures, you must also have a package that provides cryptography, such as <code>libssl-dev</code> or <code>openssl-devel</code>.</p>"},{"location":"develop/parachains/get-started/install-polkadot-sdk/#install-required-packages-and-rust-linux","title":"Install Required Packages and Rust","text":"<p>To install the Rust toolchain on Linux:</p> <ol> <li> <p>Open a terminal shell</p> </li> <li> <p>Check the packages you have installed on the local computer by running an appropriate package management command for your Linux distribution</p> </li> <li> <p>Add any package dependencies you are missing to your local development environment by running the appropriate package management command for your Linux distribution:</p> UbuntuDebianArchFedoraOpenSUSE <pre><code>sudo apt install --assume-yes git clang curl libssl-dev protobuf-compiler\n</code></pre> <pre><code>sudo apt install --assume-yes git clang curl libssl-dev llvm libudev-dev make protobuf-compiler\n</code></pre> <pre><code>pacman -Syu --needed --noconfirm curl git clang make protobuf\n</code></pre> <pre><code>sudo dnf update\nsudo dnf install clang curl git openssl-devel make protobuf-compiler\n</code></pre> <pre><code>sudo zypper install clang curl git openssl-devel llvm-devel libudev-devel make protobuf\n</code></pre> <p>Remember that different distributions might use different package managers and bundle packages in different ways. For example, depending on your installation selections, Ubuntu Desktop and Ubuntu Server might have different packages and different requirements. However, the packages listed in the command-line examples are applicable for many common Linux distributions, including Debian, Linux Mint, MX Linux, and Elementary OS.</p> </li> <li> <p>Download the <code>rustup</code> installation program and use it to install Rust by running the following command:</p> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre> </li> <li> <p>Follow the prompts displayed to proceed with a default installation</p> </li> <li> <p>Update your current shell to include Cargo by running the following command:</p> <pre><code>source $HOME/.cargo/env\n</code></pre> </li> <li> <p>Verify your installation by running the following command:</p> <pre><code>rustc --version\n</code></pre> </li> <li> <p>Configure the Rust toolchain to default to the latest stable version by running the following commands:</p> <pre><code>rustup default stable\nrustup update\n</code></pre> </li> <li> <p>Add the <code>nightly</code> release and the <code>nightly</code> Wasm targets to your development environment by running the following commands:</p> <pre><code>rustup update nightly\nrustup target add wasm32-unknown-unknown --toolchain nightly\n</code></pre> </li> <li> <p>Verify your installation</p> </li> </ol>"},{"location":"develop/parachains/get-started/install-polkadot-sdk/#windows-wsl","title":"Windows (WSL)","text":"<p>In general, UNIX-based operating systems\u2014like macOS or Linux\u2014provide a better development environment for building Substrate-based blockchains.</p> <p>However, suppose your local computer uses Microsoft Windows instead of a UNIX-based operating system. In that case, you can configure it with additional software to make it a suitable development environment for building Substrate-based blockchains. To prepare a development environment on a Microsoft Windows computer, you can use Windows Subsystem for Linux (WSL) to emulate a UNIX operating environment.</p>"},{"location":"develop/parachains/get-started/install-polkadot-sdk/#before-you-begin-windows","title":"Before You Begin","text":"<p>Before installing on Microsoft Windows, verify the following basic requirements:</p> <ul> <li>You have a computer running a supported Microsoft Windows operating system:<ul> <li>For Windows desktop - you must be running Microsoft Windows 10, version 2004 or later, or Microsoft Windows 11 to install WSL</li> <li>For Windows server - you must be running Microsoft Windows Server 2019, or later, to install WSL on a server operating system</li> </ul> </li> <li>You have good internet connection and access to a shell terminal on your local computer</li> </ul>"},{"location":"develop/parachains/get-started/install-polkadot-sdk/#set-up-windows-subsystem-for-linux","title":"Set Up Windows Subsystem for Linux","text":"<p>WSL enables you to emulate a Linux environment on a computer that uses the Windows operating system. The primary advantage of this approach for Substrate development is that you can use all of the code and command-line examples as described in the Substrate documentation. For example, you can run common commands\u2014such as <code>ls</code> and <code>ps</code>\u2014unmodified. By using WSL, you can avoid configuring a virtual machine image or a dual-boot operating system.</p> <p>To prepare a development environment using WSL:</p> <ol> <li> <p>Check your Windows version and build number to see if WSL is enabled by default.</p> <p>If you have Microsoft Windows 10, version 2004 (Build 19041 and higher), or Microsoft Windows 11, WSL is available by default and you can continue to the next step.</p> <p>If you have an older version of Microsoft Windows installed, see the WSL manual installation steps for older versions. If you are installing on an older version of Microsoft Windows, you can download and install WLS 2 if your computer has Windows 10, version 1903 or higher</p> </li> <li> <p>Select Windows PowerShell or Command Prompt from the Start menu, right-click, then Run as administrator</p> </li> <li> <p>In the PowerShell or Command Prompt terminal, run the following command:</p> <pre><code>wsl --install\n</code></pre> <p>This command enables the required WSL 2 components that are part of the Windows operating system, downloads the latest Linux kernel, and installs the Ubuntu Linux distribution by default.</p> <p>If you want to review the other Linux distributions available, run the following command:</p> <pre><code>wsl --list --online\n</code></pre> </li> <li> <p>After the distribution is downloaded, close the terminal</p> </li> <li> <p>Click the Start menu, select Shut down or sign out, then click Restart to restart the    computer.</p> <p>Restarting the computer is required to start the installation of the Linux distribution. It can take a few minutes for the installation to complete after you restart.</p> <p>For more information about setting up WSL as a development environment, see the Set up a WSL development environment docs</p> </li> </ol>"},{"location":"develop/parachains/get-started/install-polkadot-sdk/#install-required-packages-and-rust-windows","title":"Install Required Packages and Rust","text":"<p>To install the Rust toolchain on WSL:</p> <ol> <li> <p>Click the Start menu, then select Ubuntu</p> </li> <li> <p>Type a UNIX user name to create user account</p> </li> <li> <p>Type a password for your UNIX user, then retype the password to confirm it</p> </li> <li> <p>Download the latest updates for the Ubuntu distribution using the Ubuntu Advanced Packaging Tool (<code>apt</code>) by running the following command:</p> <pre><code>sudo apt update\n</code></pre> </li> <li> <p>Add the required packages for the Ubuntu distribution by running the following command:</p> <pre><code>sudo apt install --assume-yes git clang curl libssl-dev llvm libudev-dev make protobuf-compiler\n</code></pre> </li> <li> <p>Download the <code>rustup</code> installation program and use it to install Rust for the Ubuntu distribution by running the following command:</p> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre> </li> <li> <p>Follow the prompts displayed to proceed with a default installation</p> </li> <li> <p>Update your current shell to include Cargo by running the following command:</p> <pre><code>source ~/.cargo/env\n</code></pre> </li> <li> <p>Verify your installation by running the following command:</p> <pre><code>rustc --version\n</code></pre> </li> <li> <p>Configure the Rust toolchain to use the latest stable version as the default toolchain by running the following commands:</p> <pre><code>rustup default stable\nrustup update\n</code></pre> </li> <li> <p>Add the <code>nightly</code> version of the toolchain and the <code>nightly</code> Wasm target to your development environment by running the following commands:</p> <pre><code>rustup update nightly\nrustup target add wasm32-unknown-unknown --toolchain nightly\n</code></pre> </li> <li> <p>Verify your installation</p> </li> </ol>"},{"location":"develop/parachains/get-started/install-polkadot-sdk/#verifying-installation","title":"Verifying Installation","text":"<p>Verify the configuration of your development environment by running the following command:</p> <pre><code>rustup show\nrustup +nightly show\n</code></pre> <p>The command displays output similar to the following:</p> rustup show ... active toolchain ---------------- stable-x86_64-apple-darwin (default) rustc 1.81.0 (eeb90cda1 2024-09-04) ... active toolchain ---------------- nightly-x86_64-apple-darwin (overridden by +toolchain on the command line) rustc 1.83.0-nightly (6c6d21008 2024-09-22)"},{"location":"develop/parachains/get-started/intro-polkadot-sdk/","title":"Introduction to Polkadot SDK","text":""},{"location":"develop/parachains/get-started/intro-polkadot-sdk/#introduction","title":"Introduction","text":"<p>The Polkadot SDK is a powerful and versatile developer kit designed to facilitate building on the Polkadot network. It provides the necessary components for creating custom blockchains, parachains, generalized rollups, and more. Written in the Rust programming language, it puts security and robustness at the forefront of its design.</p> <p>Whether you're building a standalone chain or deploying a parachain on Polkadot, this SDK equips developers with the libraries and tools needed to manage runtime logic, compile the codebase, and utilize core features like staking, governance, and Cross-Consensus Messaging (XCM). It also provides a means for building generalized peer-to-peer systems beyond blockchains. The Polkadot SDK houses the following overall functionality:</p> <ul> <li>Networking and peer-to-peer communication (powered by Libp2p)</li> <li>Consensus protocols, such as BABE, GRANDPA, or Aura</li> <li>Cryptography</li> <li>The ability to create portable Wasm runtimes</li> <li>A selection of pre-built modules, called pallets</li> <li>Benchmarking and testing suites</li> </ul> <p>Note</p> <p>For an in-depth dive into the monorepo, the Polkadot SDK Rust documentation is highly recommended.</p>"},{"location":"develop/parachains/get-started/intro-polkadot-sdk/#polkadot-sdk-overview","title":"Polkadot SDK Overview","text":"<p>The Polkadot SDK is composed of five major components:</p> <p></p> <ul> <li>Substrate - a set of libraries and primitives for building blockchains</li> <li>FRAME - a blockchain development framework built on top of Substrate</li> <li>Cumulus - a set of libraries and pallets to add parachain capabilities to a Substrate/FRAME runtime</li> <li>XCM (Cross Consensus Messaging) - the primary format for conveying messages between parachains</li> <li>Polkadot - the node implementation for the Polkadot protocol</li> </ul>"},{"location":"develop/parachains/get-started/intro-polkadot-sdk/#substrate","title":"Substrate","text":"<p>Substrate is a Software Development Kit (SDK) that uses Rust-based libraries and tools to enable you to build application-specific blockchains from modular and extensible components. Application-specific blockchains built with Substrate can run as standalone services or in parallel with other chains to take advantage of the shared security provided by the Polkadot ecosystem. Substrate includes default implementations of the core components of the blockchain infrastructure to allow you to focus on the application logic.</p> <p>Every blockchain platform relies on a decentralized network of computers\u2014called nodes\u2014that communicate with each other about transactions and blocks. In general, a node in this context is the software running on the connected devices rather than the physical or virtual machine in the network. As software, Substrate-based nodes consist of two main parts with separate responsibilities:</p> <ul> <li>Client - services to handle network and blockchain infrastructure activity<ul> <li>Native binary</li> <li>Executes the Wasm runtime</li> <li>Manages components like database, networking, mempool, consensus, and others</li> <li>Also known as \"Host\"</li> </ul> </li> <li>Runtime - business logic for state transitions<ul> <li>Application logic</li> <li>Compiled to Wasm</li> <li>Stored as a part of the chain state</li> <li>Also known as State Transition Function (STF)</li> </ul> </li> </ul>"},{"location":"develop/parachains/get-started/intro-polkadot-sdk/#frame","title":"FRAME","text":"<p>FRAME provides the core modular and extensible components that make the Substrate SDK flexible and adaptable to different use cases. FRAME includes Rust-based libraries that simplify the development of application-specific logic. Most of the functionality that FRAME provides takes the form of plug-in modules called pallets that you can add and configure to suit your requirements.</p>"},{"location":"develop/parachains/get-started/intro-polkadot-sdk/#cumulus","title":"Cumulus","text":"<p>Cumulus provides utilities and libraries to turn FRAME-based runtimes into runtimes that can be a parachain on Polkadot. Cumulus runtimes are still FRAME runtimes but contain the necessary functionality that allows that runtime to become a parachain on a relay chain.</p>"},{"location":"develop/parachains/get-started/intro-polkadot-sdk/#why-use-polkadot-sdk","title":"Why Use Polkadot SDK?","text":"<p>Using the Polkadot SDK, you can build application-specific blockchains without the complexity of building a blockchain from scratch or the limitations of building on a general-purpose blockchain. You can focus on crafting the business logic that makes your chain unique and innovative with the additional benefits of flexibility, upgradeability, open-source licensing, and cross-consensus interoperability.</p>"},{"location":"develop/parachains/get-started/intro-polkadot-sdk/#create-a-custom-blockchain-using-the-sdk","title":"Create a Custom Blockchain Using the SDK","text":"<p>Before starting your blockchain development journey, you'll need to decide whether you want to build a standalone chain or a parachain that connects to the Polkadot network. Each path has its considerations and requirements. Once you've made this decision, follow these development stages:</p> <pre><code>graph LR\n    A[Install the Polkadot SDK] --&gt; B[Build the Chain]\n    B --&gt; C[Deploy the Chain]</code></pre> <ol> <li>Install the Polkadot SDK - set up your development environment with all necessary dependencies and tools</li> <li>Build the chain - learn how to create and customize your blockchain's runtime, configure pallets, and implement your chain's unique features</li> <li>Deploy the chain - follow the steps to launch your blockchain, whether as a standalone network or as a parachain on Polkadot</li> </ol> <p>Each stage is covered in detail in its respective guide, walking you through the process from initial setup to final deployment.</p>"},{"location":"develop/parachains/maintenance/","title":"Maintenance","text":"<p>Learn how to maintain Polkadot SDK-based networks, covering runtime monitoring, upgrades, and storage migrations for optimal blockchain performance.</p>"},{"location":"develop/parachains/maintenance/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"develop/parachains/maintenance/runtime-metrics-monitoring/","title":"Runtime Metrics and Monitoring","text":""},{"location":"develop/parachains/maintenance/runtime-metrics-monitoring/#introduction","title":"Introduction","text":"<p>Maintaining a stable, secure, and efficient network requires continuous monitoring. Polkadot SDK-based nodes are equipped with built-in telemetry components that automatically collect and transmit detailed data about node performance in real-time. This telemetry system is a core feature of the Substrate framework, allowing for easy monitoring of network health without complex setup.</p> <p>Substrate's client telemetry enables real-time data ingestion, which can be visualized on a client dashboard. The telemetry process uses tracing and logging to gather operational data. This data is sent through a tracing layer to a background task called the <code>TelemetryWorker</code>, which then forwards it to configured remote telemetry servers.</p> <p>If multiple Substrate nodes run within the same process, the telemetry system uses a <code>tracing::Span</code> to distinguish data from each node. This ensures that each task, managed by the <code>sc-service</code>'s <code>TaskManager</code>, inherits a span for data consistency, making it easy to track parallel node operations. Each node can be monitored for basic metrics, such as block height, peer connections, CPU usage, and memory. Substrate nodes expose these metrics at the <code>host:9615/metrics</code> endpoint, accessible locally by default. To expose metrics on all interfaces, start a node with the <code>--prometheus-external</code> flag.</p> <p>As a developer or node operator, the telemetry system handles most of the technical setup. Collected data is automatically sent to a default telemetry server, where it\u2019s aggregated and displayed on a dashboard, making it easy to monitor network performance and identify issues.</p>"},{"location":"develop/parachains/maintenance/runtime-metrics-monitoring/#runtime-metrics","title":"Runtime Metrics","text":"<p>Substrate exposes a variety of metrics about the operation of your network, such as the number of peer connections, memory usage, and block production. To capture and visualize these metrics, you can configure and use tools like Prometheus and Grafana. At a high level, Substrate exposes telemetry data that can be consumed by the Prometheus endpoint and then presented as visual information in a Grafana dashboard or graph. The provided diagram offers a simplified overview of how the interaction between Substrate, Prometheus, and Grafana can be configured to display information about node operations.</p> <pre><code>graph TD\n  subNode([Substrate Node]) --&gt; telemetryStream[Exposed Telemetry Stream]\n  telemetryStream --&gt; prometheus[Prometheus]\n  prometheus --&gt; endpoint[Endpoint: Every 1 minute]\n  endpoint --&gt; grafana[Grafana]\n  grafana --&gt; userOpen[User Opens a Graph]\n  prometheus --&gt; localData[Local Prometheus Data]\n  localData --&gt; getmetrics[Get Metrics]</code></pre> <p>The diagram shows the flow of data from the Substrate node to the monitoring and visualization components. The Substrate node exposes a telemetry stream, which is consumed by Prometheus. Prometheus is configured to collect data every minute and store it. Grafana is then used to visualize the data, allowing the user to open graphs and retrieve specifc metrics from the telemetry stream.</p>"},{"location":"develop/parachains/maintenance/runtime-metrics-monitoring/#visual-monitoring","title":"Visual Monitoring","text":"<p>The Polkadot telemetry dashboard provides a real-time view of how currently online nodes are performing. This dashboard, allows users to select the network you need to check on, and also the information you want to display by turning visible columns on and off from the list of columns available. The monitoring dashboard provides the following indicators and metrics:</p> <ul> <li>Validator - identifies whether the node is a validator node or not</li> <li>Location - displays the geographical location of the node</li> <li>Implementation - shows the version of the software running on the node</li> <li>Network ID - displays the public network identifier for the node</li> <li>Peer count - indicates the number of peers connected to the node</li> <li>Transactions in queue - shows the number of transactions waiting in the <code>Ready</code> queue for a block author</li> <li>Upload bandwidth - graphs the node's recent upload activity in MB/s</li> <li>Download bandwidth - graphs the node's recent download activity in MB/s</li> <li>State cache size - graphs the size of the node's state cache in MB</li> <li>Block - displays the current best block number to ensure synchronization with peers</li> <li>Block hash - shows the block hash for the current best block number</li> <li>Finalized block - displays the most recently finalized block number to ensure synchronization with peers</li> <li>Finalized block hash - shows the block hash for the most recently finalized block</li> <li>Block time - indicates the time between block executions</li> <li>Block propagation time - displays the time it took to import the most recent block</li> <li>Last block time - shows the time it took to author the most recent block</li> <li>Node uptime - indicates the number of days the node has been online without restarting</li> </ul>"},{"location":"develop/parachains/maintenance/runtime-metrics-monitoring/#displaying-network-wide-statistics","title":"Displaying Network-Wide Statistics","text":"<p>In addition to the details available for individual nodes, you can view statistics that provide insights into the broader network. The network statistics provide detailed information about the hardware and software configurations of the nodes in the network, including:</p> <ul> <li>Software version</li> <li>Operating system</li> <li>CPU architecture and model</li> <li>Number of physical CPU cores</li> <li>Total memory</li> <li>Whether the node is a virtual machine</li> <li>Linux distribution and kernel version</li> <li>CPU and memory speed</li> <li>Disk speed</li> </ul>"},{"location":"develop/parachains/maintenance/runtime-metrics-monitoring/#customizing-monitoring-tools","title":"Customizing Monitoring Tools","text":"<p>The default telemetry dashboard offers core metrics without additional setup. However, many projects prefer custom telemetry setups with more advanced monitoring and alerting policies.</p> <p>Typically, setting up a custom telemetry solution involves establishing monitoring and alerting policies for both on-chain events and individual node operations. This allows for more tailored monitoring and reporting compared to the default telemetry setup.</p>"},{"location":"develop/parachains/maintenance/runtime-metrics-monitoring/#on-chain-activity","title":"On-Chain Activity","text":"<p>You can monitor specific on-chain events like transactions from certain addresses or changes in the validator set. Connecting to RPC nodes allows tracking for delays or specific event timings. Running your own RPC servers is recommended for reliable queries, as public RPC nodes may occasionally be unreliable.</p>"},{"location":"develop/parachains/maintenance/runtime-metrics-monitoring/#monitoring-tools","title":"Monitoring Tools","text":"<p>To implement customized monitoring and alerting, consider using the following stack:</p> <ul> <li>Prometheus - collects metrics at intervals, stores data in a time series database, and applies rules for evaluation</li> <li>Grafana - visualizes collected data through customizable dashboards</li> <li>Node exporter - reports host metrics, including CPU, memory, and bandwidth usage</li> <li>Alert manager - manages alerts, routing them based on defined rules</li> <li>Loki - scalable log aggregator for searching and viewing logs across infrastructure</li> </ul>"},{"location":"develop/parachains/maintenance/runtime-metrics-monitoring/#change-the-telemetry-server","title":"Change the Telemetry Server","text":"<p>Once backend monitoring is configured, use the <code>--telemetry-url</code> flag when starting a node to specify telemetry endpoints and verbosity levels. Multiple telemetry URLs can be provided, and verbosity ranges from 0 (least verbose) to 9 (most verbose).</p> <p>For instance, setting a custom telemetry server with verbosity level 5 would look like:</p> <pre><code>./target/release/node-template --dev \\\n  --telemetry-url \"wss://192.168.48.1:9616 5\" \\\n  --prometheus-port 9616 \\\n  --prometheus-external\n</code></pre> <p>For more information on the backend components for telemetry or configuring your own server, you can refer to the <code>substrate-telemetry</code> project or the Substrate Telemetry Helm Chart for Kubernetes deployments.</p>"},{"location":"develop/parachains/maintenance/runtime-upgrades/","title":"Runtime Upgrades","text":""},{"location":"develop/parachains/maintenance/runtime-upgrades/#introduction","title":"Introduction","text":"<p>One of the defining features of Polkadot SDK-based blockchains is the ability to perform forkless runtime upgrades. Unlike traditional blockchains, which require hard forks and node coordination for upgrades, Polkadot networks enable seamless updates without network disruption.</p> <p>Forkless upgrades are achieved through WebAssembly (Wasm) runtimes stored on-chain, which can be securely swapped and upgraded as part of the blockchain's state. By leveraging decentralized consensus, runtime updates can be happen trustlessly, ensuring continuous improvement and evolution without halting operations.</p> <p>This guide explains how Polkadot's runtime versioning, Wasm deployment, and storage migrations enable these upgrades, ensuring the blockchain evolves smoothly and securely. You'll also learn how different upgrade processes apply to solo chains and parachains, depending on the network setup.</p>"},{"location":"develop/parachains/maintenance/runtime-upgrades/#how-runtime-upgrades-work","title":"How Runtime Upgrades Work","text":"<p>In FRAME, the <code>system</code> pallet uses the <code>set_code</code> extrinsic to update the Wasm code for the runtime. This method allows solo chains to upgrade without disruption. </p> <p>For parachains, upgrades are more complex. Parachains must first call <code>authorize_upgrade</code>, followed by <code>apply_authorized_upgrade</code>, to ensure the relay chain approves and applies the changes. Additionally, changes to current functionality that impact storage often require a storage migration.</p>"},{"location":"develop/parachains/maintenance/runtime-upgrades/#runtime-versioning","title":"Runtime Versioning","text":"<p>The executor is the component that selects the runtime execution environment to communicate with. Although you can override the default execution strategies for custom scenarios, in most cases, the executor selects the appropriate binary to use by evaluating and comparing key parameters from the native and Wasm runtime binaries.</p> <p>The runtime includes a runtime version struct to provide the needed parameter information to the executor process. A sample runtime version struct might look as follows:</p> <pre><code>pub const VERSION: RuntimeVersion = RuntimeVersion {\n    spec_name: create_runtime_str!(\"node-template\"),\n    impl_name: create_runtime_str!(\"node-template\"),\n    authoring_version: 1,\n    spec_version: 1,\n    impl_version: 1,\n    apis: RUNTIME_API_VERSIONS,\n    transaction_version: 1,\n};\n</code></pre> <p>The struct provides the following parameter information to the executor:</p> <ul> <li><code>spec_name</code> - the identifier for the different runtimes</li> <li><code>impl_name</code> - the name of the implementation of the spec. Serves only to differentiate code of different implementation teams</li> <li><code>authoring_version</code> - the version of the authorship interface. An authoring node won't attempt to author blocks unless this is equal to its native runtime</li> <li><code>spec_version</code> - the version of the runtime specification. A full node won't attempt to use its native runtime in substitute for the on-chain Wasm runtime unless the <code>spec_name</code>, <code>spec_version</code>, and <code>authoring_version</code> are all the same between the Wasm and native binaries. Updates to the <code>spec_version</code> can be automated as a CI process, as is done for the Polkadot network. This parameter is typically incremented when there's an update to the <code>transaction_version</code></li> <li><code>impl_version</code> - the version of the implementation of the specification. Nodes can ignore this. It is only used to indicate that the code is different. As long as the <code>authoring_version</code> and the <code>spec_version</code> are the same, the code might have changed, but the native and Wasm binaries do the same thing. In general, only non-logic-breaking optimizations would result in a change of the <code>impl_version</code></li> <li><code>transaction_version</code> - the version of the interface for handling transactions. This parameter can be useful to synchronize firmware updates for hardware wallets or other signing devices to verify that runtime transactions are valid and safe to sign. This number must be incremented if there is a change in the index of the pallets in the <code>construct_runtime!</code> macro or if there are any changes to dispatchable functions, such as the number of parameters or parameter types. If <code>transaction_version</code> is updated, then the <code>spec_version</code> must also be updated</li> <li><code>apis</code> - a list of supported runtime APIs along with their versions                                                    </li> </ul> <p>The executor follows the same consensus-driven logic for both the native runtime and the Wasm runtime before deciding which to execute. Because runtime versioning is a manual process, there is a risk that the executor could make incorrect decisions if the runtime version is misrepresented or incorrectly defined.</p>"},{"location":"develop/parachains/maintenance/runtime-upgrades/#accessing-the-runtime-version","title":"Accessing the Runtime Version","text":"<p>The runtime version can be accessed through the <code>state.getRuntimeVersion</code> RPC endpoint, which accepts an optional block identifier. It can also be accessed through the runtime metadata to understand the APIs the runtime exposes and how to interact with them.</p> <p>The runtime metadata should only change when the chain's runtime <code>spec_version</code> changes.</p>"},{"location":"develop/parachains/maintenance/runtime-upgrades/#storage-migrations","title":"Storage Migrations","text":"<p>Storage migrations are custom, one-time functions that allow you to update storage to adapt to changes in the runtime.</p> <p>For example, if a runtime upgrade changes the data type used to represent user balances from an unsigned integer to a signed integer, the storage migration would read the existing value as an unsigned integer and write back an updated value that has been converted to a signed integer.</p> <p>If you don't make changes to how data is stored when needed, the runtime can't properly interpret the storage values to include in the runtime state and is likely to lead to undefined behavior.</p>"},{"location":"develop/parachains/maintenance/runtime-upgrades/#storage-migrations-with-frame","title":"Storage Migrations with FRAME","text":"<p>FRAME storage migrations are implemented using the <code>OnRuntimeUpgrade</code> trait. The <code>OnRuntimeUpgrade</code> trait specifies a single function, <code>on_runtime_upgrade</code>, that allows you to specify logic to run immediately after a runtime upgrade but before any <code>on_initialize</code> functions or transactions are executed.</p> <p>For further details about this process, see the Storage Migrations page.</p>"},{"location":"develop/parachains/maintenance/runtime-upgrades/#ordering-migrations","title":"Ordering Migrations","text":"<p>By default, FRAME orders the execution of <code>on_runtime_upgrade</code> functions based on the order in which the pallets appear in the <code>construct_runtime!</code> macro. The functions run in reverse order for upgrades, starting with the last pallet executed first. You can impose a custom order if needed.</p> <p>FRAME storage migrations run in this order:</p> <ol> <li>Custom <code>on_runtime_upgrade</code> functions if using a custom order</li> <li>System <code>frame_system::on_runtime_upgrade</code> functions</li> <li>All <code>on_runtime_upgrade</code> functions defined in the runtime starting with the last pallet in the <code>construct_runtime!</code> macro</li> </ol>"},{"location":"develop/parachains/maintenance/storage-migrations/","title":"Storage Migrations","text":""},{"location":"develop/parachains/maintenance/storage-migrations/#introduction","title":"Introduction","text":"<p>Storage migrations are a crucial part of the runtime upgrade process. They allow you to update the storage items of your blockchain, adapting to changes in the runtime. Whenever you change the encoding or data types used to represent data in storage, you'll need to provide a storage migration to ensure the runtime can correctly interpret the existing stored values in the new runtime state.</p> <p>Storage migrations must be executed precisely during the runtime upgrade process to ensure data consistency and prevent runtime panics. The migration code needs to run as follows:</p> <ul> <li>After the new runtime is deployed</li> <li>Before any other code from the new runtime executes</li> <li>Before any <code>on_initialize</code> hooks run</li> <li>Before any transactions are processed</li> </ul> <p>This timing is critical because the new runtime expects data to be in the updated format. Any attempt to decode the old data format without proper migration could result in runtime panics or undefined behavior.</p>"},{"location":"develop/parachains/maintenance/storage-migrations/#storage-migration-scenarios","title":"Storage Migration Scenarios","text":"<p>A storage migration is necessary whenever a runtime upgrade changes the storage layout or the encoding/interpretation of existing data. Even if the underlying data type appears to still \"fit\" the new storage representation, a migration may be required if the interpretation of the stored values has changed.</p> <p>Storage migrations ensure data consistency and prevent corruption during runtime upgrades. Below are common scenarios categorized by their impact on storage and migration requirements:</p> <ul> <li> <p>Migration required:</p> <ul> <li>Reordering or mutating fields of an existing data type to change the encoded/decoded data representation</li> <li>Removal of a pallet or storage item warrants cleaning up storage via a migration to avoid state bloat</li> </ul> </li> <li> <p>Migration not required:</p> <ul> <li>Adding a new storage item would not require any migration since no existing data needs transformation</li> <li>Adding or removing an extrinsic introduces no new interpretation of preexisting data, so no migration is required</li> </ul> </li> </ul> <p>The following are some common scenarios where a storage migration is needed:</p> <ul> <li> <p>Changing data types - changing the underlying data type requires a migration to convert the existing values</p> <pre><code>#[pallet::storage]\npub type FooValue = StorageValue&lt;_, Foo&gt;;\n// old\npub struct Foo(u32)\n// new\npub struct Foo(u64)\n</code></pre> </li> <li> <p>Changing data representation - modifying the representation of the stored data, even if the size appears unchanged, requires a migration to ensure the runtime can correctly interpret the existing values</p> <pre><code>#[pallet::storage]\npub type FooValue = StorageValue&lt;_, Foo&gt;;\n// old\npub struct Foo(u32)\n// new\npub struct Foo(i32)\n// or\npub struct Foo(u16, u16)\n</code></pre> </li> <li> <p>Extending an enum - adding new variants to an enum requires a migration if you reorder existing variants, insert new variants between existing ones, or change the data type of existing variants. No migration is required when adding new variants at the end of the enum</p> <pre><code>#[pallet::storage]\npub type FooValue = StorageValue&lt;_, Foo&gt;;\n// old\npub enum Foo { A(u32), B(u32) }\n// new (New variant added at the end. No migration required)\npub enum Foo { A(u32), B(u32), C(u128) }\n// new (Reordered variants. Requires migration)\npub enum Foo { A(u32), C(u128), B(u32) }\n</code></pre> </li> <li> <p>Changing the storage key - modifying the storage key, even if the underlying data type remains the same, requires a migration to ensure the runtime can locate the correct stored values.</p> <pre><code>#[pallet::storage]\npub type FooValue = StorageValue&lt;_, u32&gt;;\n// new\n#[pallet::storage]\npub type BarValue = StorageValue&lt;_, u32&gt;;\n</code></pre> </li> </ul> <p>Warning</p> <p>In general, any change to the storage layout or data encoding used in your runtime requires careful consideration of the need for a storage migration. Overlooking a necessary migration can lead to undefined behavior or data loss during a runtime upgrade.</p>"},{"location":"develop/parachains/maintenance/storage-migrations/#implement-storage-migrations","title":"Implement Storage Migrations","text":"<p>The <code>OnRuntimeUpgrade</code> trait provides the foundation for implementing storage migrations in your runtime. Here's a detailed look at its essential functions:</p> <pre><code>pub trait OnRuntimeUpgrade {\n    fn on_runtime_upgrade() -&gt; Weight { ... }\n    fn try_on_runtime_upgrade(checks: bool) -&gt; Result&lt;Weight, TryRuntimeError&gt; { ... }\n    fn pre_upgrade() -&gt; Result&lt;Vec&lt;u8&gt;, TryRuntimeError&gt; { ... }\n    fn post_upgrade(_state: Vec&lt;u8&gt;) -&gt; Result&lt;(), TryRuntimeError&gt; { ... }\n}\n</code></pre>"},{"location":"develop/parachains/maintenance/storage-migrations/#core-migration-function","title":"Core Migration Function","text":"<p>The <code>on_runtime_upgrade</code> function executes when the FRAME Executive pallet detects a runtime upgrade. Important considerations when using this function include:</p> <ul> <li>It runs before any pallet's <code>on_initialize</code> hooks</li> <li>Critical storage items (like <code>block_number</code>) may not be set</li> <li>Execution is mandatory and must be completed</li> <li>Careful weight calculation is required to prevent bricking the chain</li> </ul> <p>When implementing the migration logic, your code must handle several vital responsibilities. A migration implementation must do the following to operate correctly:</p> <ul> <li>Read existing storage values in their original format</li> <li>Transform data to match the new format</li> <li>Write updated values back to storage</li> <li>Calculate and return consumed weight</li> </ul>"},{"location":"develop/parachains/maintenance/storage-migrations/#migration-testing-hooks","title":"Migration Testing Hooks","text":"<p>The <code>OnRuntimeUpgrade</code> trait provides some functions designed specifically for testing migrations. These functions never execute on-chain but are essential for validating migration behavior in test environments. The migration test hooks are as follows:</p> <ul> <li> <p><code>try_on_runtime_upgrade</code> - this function serves as the primary orchestrator for testing the complete migration process. It coordinates the execution flow from <code>pre-upgrade</code> checks through the actual migration to <code>post-upgrade</code> verification. Handling the entire migration sequence ensures that storage modifications occur correctly and in the proper order. Preserving this sequence is particularly valuable when testing multiple dependent migrations, where the execution order matters</p> </li> <li> <p><code>pre_upgrade</code> - before a runtime upgrade begins, the <code>pre_upgrade</code> function performs preliminary checks and captures the current state. It returns encoded state data that can be used for <code>post-upgrade</code> verification. This function must never modify storage - it should only read and verify the existing state. The data it returns includes critical state values that should remain consistent or transform predictably during migration</p> </li> <li> <p><code>post_upgrade</code> - after the migration completes, <code>post_upgrade</code> validates its success. It receives the state data captured by <code>pre_upgrade</code> to verify that the migration was executed correctly. This function checks for storage consistency and ensures all data transformations are completed as expected. Like <code>pre_upgrade</code>, it operates exclusively in testing environments and should not modify storage</p> </li> </ul>"},{"location":"develop/parachains/maintenance/storage-migrations/#migration-structure","title":"Migration Structure","text":"<p>There are two approaches to implementing storage migrations. The first method involves directly implementing <code>OnRuntimeUpgrade</code> on structs. This approach requires manually checking the on-chain storage version against the new <code>StorageVersion</code> and executing the transformation logic only when the check passes. This version verification prevents multiple executions of the migration during subsequent runtime upgrades.</p> <p>The recommended approach is to implement <code>UncheckedOnRuntimeUpgrade</code> and wrap it with <code>VersionedMigration</code>. <code>VersionedMigration</code> implements <code>OnRuntimeUpgrade</code> and handles storage version management automatically, following best practices and reducing potential errors.</p> <p><code>VersionedMigration</code> requires five type parameters:</p> <ul> <li><code>From</code> - the source version for the upgrade</li> <li><code>To</code> - the target version for the upgrade</li> <li><code>Inner</code> - the <code>UncheckedOnRuntimeUpgrade</code> implementation</li> <li><code>Pallet</code> - the pallet being upgraded</li> <li><code>Weight</code> - the runtime's <code>RuntimeDbWeight</code> implementation</li> </ul> <p>Examine the following migration example that transforms a simple <code>StorageValue</code> storing a <code>u32</code> into a more complex structure that tracks both current and previous values using the <code>CurrentAndPreviousValue</code> struct:</p> <ul> <li> <p>Old <code>StorageValue</code> format: <pre><code>#[pallet::storage]\npub type Value&lt;T: Config&gt; = StorageValue&lt;_, u32&gt;;\n</code></pre></p> </li> <li> <p>New <code>StorageValue</code> format: <pre><code>/// Example struct holding the most recently set [`u32`] and the\n/// second most recently set [`u32`] (if one existed).\n#[docify::export]\n#[derive(\n    Clone, Eq, PartialEq, Encode, Decode, RuntimeDebug, scale_info::TypeInfo, MaxEncodedLen,\n)]\npub struct CurrentAndPreviousValue {\n    /// The most recently set value.\n    pub current: u32,\n    /// The previous value, if one existed.\n    pub previous: Option&lt;u32&gt;,\n}\n\n#[pallet::storage]\npub type Value&lt;T: Config&gt; = StorageValue&lt;_, CurrentAndPreviousValue&gt;;\n</code></pre></p> </li> <li> <p>Migration: <pre><code>use frame_support::{\n    storage_alias,\n    traits::{Get, UncheckedOnRuntimeUpgrade},\n};\n\n#[cfg(feature = \"try-runtime\")]\nuse alloc::vec::Vec;\n\n/// Collection of storage item formats from the previous storage version.\n///\n/// Required so we can read values in the v0 storage format during the migration.\nmod v0 {\n    use super::*;\n\n    /// V0 type for [`crate::Value`].\n    #[storage_alias]\n    pub type Value&lt;T: crate::Config&gt; = StorageValue&lt;crate::Pallet&lt;T&gt;, u32&gt;;\n}\n\n/// Implements [`UncheckedOnRuntimeUpgrade`], migrating the state of this pallet from V0 to V1.\n///\n/// In V0 of the template [`crate::Value`] is just a `u32`. In V1, it has been upgraded to\n/// contain the struct [`crate::CurrentAndPreviousValue`].\n///\n/// In this migration, update the on-chain storage for the pallet to reflect the new storage\n/// layout.\npub struct InnerMigrateV0ToV1&lt;T: crate::Config&gt;(core::marker::PhantomData&lt;T&gt;);\n\nimpl&lt;T: crate::Config&gt; UncheckedOnRuntimeUpgrade for InnerMigrateV0ToV1&lt;T&gt; {\n    /// Return the existing [`crate::Value`] so we can check that it was correctly set in\n    /// `InnerMigrateV0ToV1::post_upgrade`.\n    #[cfg(feature = \"try-runtime\")]\n    fn pre_upgrade() -&gt; Result&lt;Vec&lt;u8&gt;, sp_runtime::TryRuntimeError&gt; {\n        use codec::Encode;\n\n        // Access the old value using the `storage_alias` type\n        let old_value = v0::Value::&lt;T&gt;::get();\n        // Return it as an encoded `Vec&lt;u8&gt;`\n        Ok(old_value.encode())\n    }\n\n    /// Migrate the storage from V0 to V1.\n    ///\n    /// - If the value doesn't exist, there is nothing to do.\n    /// - If the value exists, it is read and then written back to storage inside a\n    /// [`crate::CurrentAndPreviousValue`].\n    fn on_runtime_upgrade() -&gt; frame_support::weights::Weight {\n        // Read the old value from storage\n        if let Some(old_value) = v0::Value::&lt;T&gt;::take() {\n            // Write the new value to storage\n            let new = crate::CurrentAndPreviousValue { current: old_value, previous: None };\n            crate::Value::&lt;T&gt;::put(new);\n            // One read + write for taking the old value, and one write for setting the new value\n            T::DbWeight::get().reads_writes(1, 2)\n        } else {\n            // No writes since there was no old value, just one read for checking\n            T::DbWeight::get().reads(1)\n        }\n    }\n\n    /// Verifies the storage was migrated correctly.\n    ///\n    /// - If there was no old value, the new value should not be set.\n    /// - If there was an old value, the new value should be a [`crate::CurrentAndPreviousValue`].\n    #[cfg(feature = \"try-runtime\")]\n    fn post_upgrade(state: Vec&lt;u8&gt;) -&gt; Result&lt;(), sp_runtime::TryRuntimeError&gt; {\n        use codec::Decode;\n        use frame_support::ensure;\n\n        let maybe_old_value = Option::&lt;u32&gt;::decode(&amp;mut &amp;state[..]).map_err(|_| {\n            sp_runtime::TryRuntimeError::Other(\"Failed to decode old value from storage\")\n        })?;\n\n        match maybe_old_value {\n            Some(old_value) =&gt; {\n                let expected_new_value =\n                    crate::CurrentAndPreviousValue { current: old_value, previous: None };\n                let actual_new_value = crate::Value::&lt;T&gt;::get();\n\n                ensure!(actual_new_value.is_some(), \"New value not set\");\n                ensure!(\n                    actual_new_value == Some(expected_new_value),\n                    \"New value not set correctly\"\n                );\n            },\n            None =&gt; {\n                ensure!(crate::Value::&lt;T&gt;::get().is_none(), \"New value unexpectedly set\");\n            },\n        };\n        Ok(())\n    }\n}\n\n/// [`UncheckedOnRuntimeUpgrade`] implementation [`InnerMigrateV0ToV1`] wrapped in a\n/// [`VersionedMigration`](frame_support::migrations::VersionedMigration), which ensures that:\n/// - The migration only runs once when the on-chain storage version is 0\n/// - The on-chain storage version is updated to `1` after the migration executes\n/// - Reads/Writes from checking/settings the on-chain storage version are accounted for\npub type MigrateV0ToV1&lt;T&gt; = frame_support::migrations::VersionedMigration&lt;\n    0, // The migration will only execute when the on-chain storage version is 0\n    1, // The on-chain storage version will be set to 1 after the migration is complete\n    InnerMigrateV0ToV1&lt;T&gt;,\n    crate::pallet::Pallet&lt;T&gt;,\n    &lt;T as frame_system::Config&gt;::DbWeight,\n&gt;;\n</code></pre></p> </li> </ul>"},{"location":"develop/parachains/maintenance/storage-migrations/#migration-organization","title":"Migration Organization","text":"<p>Best practices recommend organizing migrations in a separate module within your pallet. Here's the recommended file structure:</p> <pre><code>my-pallet/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 lib.rs       # Main pallet implementation\n\u2502   \u2514\u2500\u2500 migrations/  # All migration-related code\n\u2502       \u251c\u2500\u2500 mod.rs   # Migrations module definition\n\u2502       \u251c\u2500\u2500 v1.rs    # V0 -&gt; V1 migration\n\u2502       \u2514\u2500\u2500 v2.rs    # V1 -&gt; V2 migration\n\u2514\u2500\u2500 Cargo.toml\n</code></pre> <p>This structure provides several benefits:</p> <ul> <li>Separates migration logic from core pallet functionality</li> <li>Makes migrations easier to test and maintain</li> <li>Provides explicit versioning of storage changes</li> <li>Simplifies the addition of future migrations</li> </ul>"},{"location":"develop/parachains/maintenance/storage-migrations/#scheduling-migrations","title":"Scheduling Migrations","text":"<p>To execute migrations during a runtime upgrade, you must configure them in your runtime's Executive pallet. Add your migrations in <code>runtime/src/lib.rs</code>:</p> <pre><code>/// Tuple of migrations (structs that implement `OnRuntimeUpgrade`)\ntype Migrations = (\n    pallet_my_pallet::migrations::v1::Migration,\n    // More migrations can be added here\n);\npub type Executive = frame_executive::Executive&lt;\n    Runtime,\n    Block,\n    frame_system::ChainContext&lt;Runtime&gt;,\n    Runtime,\n    AllPalletsWithSystem,\n    Migrations, // Include migrations here\n&gt;;\n</code></pre>"},{"location":"develop/parachains/maintenance/storage-migrations/#single-block-migrations","title":"Single-Block Migrations","text":"<p>Single-block migrations execute their logic within one block immediately following a runtime upgrade. They run as part of the runtime upgrade process through the <code>OnRuntimeUpgrade</code> trait implementation and must be completed before any other runtime logic executes.</p> <p>While single-block migrations are straightforward to implement and provide immediate data transformation, they carry significant risks. The most critical consideration is that they must complete within one block's weight limits. This is especially crucial for parachains, where exceeding block weight limits will brick the chain.</p> <p>Use single-block migrations only when you can guarantee:</p> <ul> <li>The migration has a bounded execution time</li> <li>Weight calculations are thoroughly tested</li> <li>Total weight will never exceed block limits</li> </ul> <p>For a complete implementation example of a single-block migration, refer to the single-block migration example in the Polkadot SDK documentation.</p>"},{"location":"develop/parachains/maintenance/storage-migrations/#multi-block-migrations","title":"Multi Block Migrations","text":"<p>Multi-block migrations distribute the migration workload across multiple blocks, providing a safer approach for production environments. The migration state is tracked in storage, allowing the process to pause and resume across blocks.</p> <p>This approach is essential for production networks and parachains as the risk of exceeding block weight limits is eliminated. Multi-block migrations can safely handle large storage collections, unbounded data structures, and complex nested data types where weight consumption might be unpredictable.</p> <p>Multi-block migrations are ideal when dealing with:</p> <ul> <li>Large-scale storage migrations</li> <li>Unbounded storage items or collections</li> <li>Complex data structures with uncertain weight costs</li> </ul> <p>The primary trade-off is increased implementation complexity, as you must manage the migration state and handle partial completion scenarios. However, multi-block migrations' significant safety benefits and operational reliability are typically worth the increased complexity.</p> <p>For a complete implementation example of multi-block migrations, refer to the official example in the Polkadot SDK.</p>"},{"location":"develop/parachains/testing/","title":"Testing Your Polkadot SDK-Based Blockchain","text":"<p>Explore comprehensive testing strategies for Polkadot SDK-based blockchains, from setting up test environments to verifying runtime and pallet interactions.</p>"},{"location":"develop/parachains/testing/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"develop/parachains/testing/runtime/","title":"Runtime Testing","text":""},{"location":"develop/parachains/testing/runtime/#introduction","title":"Introduction","text":"<p>In the Polkadot SDK, it's important to test individual pallets in isolation and how they interact within the runtime. Once unit tests for specific pallets are complete, the next step is integration testing to verify that multiple pallets work together correctly within the blockchain system. This testing ensures that the entire runtime functions as expected under real-world conditions.</p> <p>This article extends the Testing Setup guide by illustrating how to test interactions between different pallets within the same runtime.</p>"},{"location":"develop/parachains/testing/runtime/#testing-pallets-interactions","title":"Testing Pallets Interactions","text":"<p>Once the test environment is ready, you can write tests to simulate interactions between multiple pallets in the runtime. Below is an example of how to test the interaction between two generic pallets, referred to here as <code>pallet_a</code> and <code>pallet_b</code>. In this scenario, assume that <code>pallet_b</code> depends on <code>pallet_a</code>. The configuration of <code>pallet_b</code> is the following:</p> <pre><code>use pallet_a::Config as PalletAConfig;\n\n...\n\n#[pallet::config]\npub trait Config: frame_system::Config + PalletAConfig {\n    type RuntimeEvent: From&lt;Event&lt;Self&gt;&gt; + IsType&lt;&lt;Self as frame_system::Config&gt;::RuntimeEvent&gt;;\n    type WeightInfo: WeightInfo;\n}\n</code></pre> <p>And also, <code>pallet_b</code> exposes a call that interacts with <code>pallet_a</code>:</p> <pre><code>#[pallet::call]\nimpl&lt;T: Config&gt; Pallet&lt;T&gt; {\n    #[pallet::call_index(0)]\n    #[pallet::weight(&lt;T as pallet_b::Config&gt;::WeightInfo::dummy_weight())]\n    pub fn dummy_call_against_pallet_a(_origin: OriginFor&lt;T&gt;, number: u32) -&gt; DispatchResult {\n        pallet_a::DummyCounter::&lt;T&gt;::put(number);\n        Self::deposit_event(Event::Dummy);\n        Ok(())\n    }\n}\n</code></pre> <p>In this first test, a call to <code>pallet_a</code> is simulated, and the internal state is checked to ensure it updates correctly. The block number is also checked to ensure it advances as expected:</p> <pre><code>#[test]\nfn testing_runtime_with_pallet_a() {\n    new_test_ext().execute_with(|| {\n        // Block 0: Verify runtime initialization\n        assert_eq!(frame_system::Pallet::&lt;Runtime&gt;::block_number(), 0);\n\n        // Check the initial state of pallet_a\n        assert_eq!(0, pallet_a::Pallet::&lt;Runtime&gt;::get_dummy_counter());\n\n        // Simulate calling a function from pallet_a\n        let dummy_origin = RuntimeOrigin::none();\n        pallet_a::Pallet::&lt;Runtime&gt;::dummy_call(dummy_origin, 2);\n\n        // Verify that pallet_a's state has been updated\n        assert_eq!(2, pallet_a::Pallet::&lt;Runtime&gt;::get_dummy_counter());\n\n        // Move to the next block\n        frame_system::Pallet::&lt;Runtime&gt;::set_block_number(1);\n\n        // Confirm the block number has advanced\n        assert_eq!(frame_system::Pallet::&lt;Runtime&gt;::block_number(), 1);\n    });\n}\n</code></pre> <p>Next, a test can be written to verify the interaction between <code>pallet_a</code> and <code>pallet_b</code>:</p> <pre><code>#[test]\nfn testing_runtime_with_pallet_b() {\n    new_test_ext().execute_with(|| {\n        // Block 0: Check if initialized correctly\n        assert_eq!(frame_system::Pallet::&lt;Runtime&gt;::block_number(), 0);\n\n        // Ensure that pallet_a is initialized correctly\n        assert_eq!(0, pallet_a::Pallet::&lt;Runtime&gt;::get_dummy_counter()); \n\n        // Use pallet_b to call a function that interacts with pallet_a\n        let dummy_origin = RuntimeOrigin::none();\n        pallet_b::Pallet::&lt;Runtime&gt;::dummy_call_against_pallet_a(dummy_origin, 4);\n\n        // Confirm that pallet_a's state was updated by pallet_b\n        assert_eq!(4, pallet_a::Pallet::&lt;Runtime&gt;::get_dummy_counter());\n\n        // Transition to block 1.\n        frame_system::Pallet::&lt;Runtime&gt;::set_block_number(1);\n\n        // Confirm the block number has advanced\n        assert_eq!(frame_system::pallet::&lt;runtime&gt;::block_number(), 1);\n    });\n}\n</code></pre> <p>This test demonstrates how <code>pallet_b</code> can trigger a change in <code>pallet_a</code>'s state, verifying that the pallets interact properly during runtime.</p> <p>For more information about testing more specific elements like storage, errors, and events, see the Pallet Testing article.</p> Integration Test - Complete Code <p>The complete code for the integration test is shown below: </p> <pre><code>pub mod integration_testing {\n    use crate::*;\n    use sp_runtime::BuildStorage;\n    use frame_support::assert_ok;\n\n    // Build genesis storage according to the runtime's configuration.\n    pub fn new_test_ext() -&gt; sp_io::TestExternalities {\n        frame_system::GenesisConfig::&lt;Runtime&gt;::default().build_storage().unwrap().into()\n    }\n\n    #[test]\n    fn testing_runtime_with_pallet_a() {\n        new_test_ext().execute_with(|| {\n            // Block 0: Check if initialized correctly\n            assert_eq!(frame_system::Pallet::&lt;Runtime&gt;::block_number(), 0);\n\n            assert_eq!(0, pallet_a::Pallet::&lt;Runtime&gt;::get_dummy_counter());\n\n            let dummy_origin = RuntimeOrigin::none();\n            pallet_a::Pallet::&lt;Runtime&gt;::dummy_call(dummy_origin, 2);\n\n            assert_eq!(2, pallet_a::Pallet::&lt;Runtime&gt;::get_dummy_counter());\n\n            // Transition to block 1.\n            frame_system::Pallet::&lt;Runtime&gt;::set_block_number(1);\n\n            // Check if block number is now 1.\n            assert_eq!(frame_system::Pallet::&lt;Runtime&gt;::block_number(), 1);\n        });\n    }\n\n    #[test]\n    fn testing_runtime_with_pallet_b() {\n        new_test_ext().execute_with(|| {\n            // Block 0: Check if initialized correctly\n            assert_eq!(frame_system::Pallet::&lt;Runtime&gt;::block_number(), 0);\n\n            assert_eq!(0, pallet_a::Pallet::&lt;Runtime&gt;::get_dummy_counter()); \n            let dummy_origin = RuntimeOrigin::none();\n            pallet_b::Pallet::&lt;Runtime&gt;::dummy_call_against_pallet_a(dummy_origin, 4);\n            assert_eq!(4, pallet_a::Pallet::&lt;Runtime&gt;::get_dummy_counter());\n\n            // Transition to block 1.\n            frame_system::Pallet::&lt;Runtime&gt;::set_block_number(1);\n\n            // Check if block number is now 1.\n            assert_eq!(frame_system::Pallet::&lt;Runtime&gt;::block_number(), 1);\n        });\n    }\n}\n</code></pre>"},{"location":"develop/parachains/testing/runtime/#verifying-pallet-interactions","title":"Verifying Pallet Interactions","text":"<p>The tests confirm that:</p> <ul> <li>Pallets initialize correctly - at the start of each test, the system should initialize with block number 0, and the pallets should be in their default states</li> <li>Pallets modify each other's state - the second test shows how one pallet can trigger changes in another pallet's internal state, confirming proper cross-pallet interactions</li> <li>State transitions between blocks are seamless - by simulating block transitions, the tests validate that the runtime responds correctly to changes in the block number</li> </ul> <p>Testing pallet interactions within the runtime is critical for ensuring the blockchain behaves as expected under real-world conditions. Writing integration tests allows validation of how pallets function together, preventing issues that might arise when the system is fully assembled.</p> <p>This approach provides a comprehensive view of the runtime's functionality, ensuring the blockchain is stable and reliable.</p>"},{"location":"develop/parachains/testing/setup/","title":"Testing Setup","text":""},{"location":"develop/parachains/testing/setup/#introduction","title":"Introduction","text":"<p>In Polkadot SDK development, testing is crucial to ensure your blockchain works as expected. While unit testing for individual pallets validates isolated functionality, as discussed in Pallet Testing, it's equally important to test how these pallets function together within the runtime. Runtime testing fills this role by providing a complete simulation of the blockchain system.</p> <p>This guide will help you set up an environment to test an entire runtime. Runtime testing will enable you to assess how different pallets, their configurations, and system components interact, ensuring your blockchain behaves correctly under real-world conditions.</p>"},{"location":"develop/parachains/testing/setup/#runtime-testing","title":"Runtime Testing","text":"<p>In the context of Polkadot SDK, runtime testing involves creating a simulated environment that mimics actual blockchain conditions. This type of testing goes beyond individual pallet validation, focusing on how multiple components integrate and collaborate across the system. This way, multiple runtimes can be tested if needed.</p> <p>While unit tests provide confidence that individual pallets function correctly in isolation, runtime tests offer a holistic view. These tests validate pallets' communication and interaction, ensuring a seamless and functional blockchain system. By running integration tests at the runtime level, you can catch issues that only arise when multiple pallets are combined, which is critical for building a stable and reliable blockchain.</p>"},{"location":"develop/parachains/testing/setup/#configuring-a-mock-runtime-for-integration-tests","title":"Configuring a Mock Runtime for Integration Tests","text":"<p>The mock runtime includes all the necessary pallets and configurations needed for testing. To simplify the process, you can create a module that integrates all components, making it easier to assess how pallets and system elements interact.</p> <p>Here's a simple example of how to create a testing module that simulates these interactions:</p> <pre><code>pub mod integration_testing {\n    use crate::*;\n    // ...\n}\n</code></pre> <p>Note</p> <p>The <code>crate::*;</code> snippet imports all the components from your crate (including runtime configurations, pallet modules, and utility functions) into the <code>integration_testing</code> module. This allows you to write tests without manually importing each piece, making the code more concise and readable.</p> <p>Once the testing module is set, the next step is configuring the genesis storage\u2014the initial state of your blockchain. Genesis storage sets the starting conditions for the runtime, defining how pallets are configured before any blocks are produced.</p> <p>In Polkadot SDK, you can create this storage using the <code>BuildStorage</code> trait from the <code>sp_runtime</code> crate. This trait is essential for building the configuration that initializes the blockchain's state.</p> <p>The function <code>new_test_ext()</code> demonstrates setting up this environment. It uses <code>frame_system::GenesisConfig::&lt;Runtime&gt;::default()</code> to generate a default genesis configuration for the runtime, followed by <code>.build_storage()</code> to create the initial storage state. This storage is then converted into a format usable by the testing framework, <code>sp_io::TestExternalities</code>, allowing tests to be executed in a simulated blockchain environment.</p> <p>Here's the code that sets up the mock runtime:</p> <pre><code>pub mod integration_testing {\n    use crate::*;\n    use sp_runtime::BuildStorage;\n\n    pub fn new_test_ext() -&gt; sp_io::TestExternalities {\n        frame_system::GenesisConfig::&lt;Runtime&gt;::default()\n            .build_storage()\n            .unwrap()\n            .into()\n    }\n}\n</code></pre> <p>You can also customize the genesis storage to set initial values for your runtime pallets. For example, you can set the initial balance for accounts like this:</p> <pre><code>// Build genesis storage according to the runtime's configuration\npub fn new_test_ext() -&gt; sp_io::TestExternalities {\n    // Define the initial balances for accounts\n    let initial_balances: Vec&lt;(AccountId32, u128)&gt; = vec![\n        (AccountId32::from([0u8; 32]), 1_000_000_000_000),\n        (AccountId32::from([1u8; 32]), 2_000_000_000_000),\n    ];\n\n    let mut t = frame_system::GenesisConfig::&lt;Runtime&gt;::default()\n        .build_storage()\n        .unwrap();\n\n    // Adding balances configuration to the genesis config\n    pallet_balances::GenesisConfig::&lt;Runtime&gt; {\n        balances: initial_balances,\n    }\n    .assimilate_storage(&amp;mut t)\n    .unwrap();\n\n    t.into()\n}\n</code></pre>"},{"location":"develop/parachains/testing/setup/#where-to-go-next","title":"Where to Go Next","text":"<p>With the mock environment in place, you can now write tests to validate how your pallets interact within the runtime. This approach ensures that your blockchain behaves as expected when the entire runtime is assembled.</p> <p>You can view a complete example of an integration test in the Astar parachain codebase.</p> <p>For more advanced information on runtime testing, please refer to the Runtime Testing article.</p>"},{"location":"develop/smart-contracts/","title":"Smart Contracts","text":"<p>Learn about smart contract development in Polkadot using ink! for Wasm contracts and EVM support for Solidity contracts on Asset Hub and parachains.</p>"},{"location":"develop/smart-contracts/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"develop/smart-contracts/overview/","title":"Overview","text":""},{"location":"develop/smart-contracts/overview/#introduction","title":"Introduction","text":"<p>Polkadot is designed to support an ecosystem of parachains, rather than hosting smart contracts directly. Developers aiming to build smart contract applications on Polkadot rely on parachains within the ecosystem that provide smart contract functionality.</p> <p>This guide outlines the primary approaches to developing smart contracts in the Polkadot ecosystem:</p> <ul> <li>Wasm-based smart contracts - using ink!, a Rust-based embedded domain-specific language (eDSL), enabling developers to leverage Rust\u2019s safety and tooling</li> <li>EVM-compatible contracts - which support languages like Solidity and Vyper, offering compatibility with popular Ethereum tools and wallets</li> <li>PolkaVM compatible contracts - which support Solidity and Rust while maintaining compatibility with Ethereum based tools</li> </ul> <p>You'll explore the key differences between these development paths, along with considerations for parachain developers integrating smart contract functionality.</p> <p>Parachain Developer?</p> <p>If you are a parachain developer looking to add smart contract functionality to your chain, please refer to the Add Smart Contract Functionality page, which covers both Wasm and EVM-based contract implementations.</p>"},{"location":"develop/smart-contracts/overview/#smart-contracts-versus-parachains","title":"Smart Contracts Versus Parachains","text":"<p>A smart contract is a program that executes specific logic isolated to the chain on which it is being executed. All the logic executed is bound to the same state transition rules determined by the underlying virtual machine (VM). Consequently, smart contracts are more streamlined to develop, and programs can easily interact with each other through similar interfaces.</p> <pre><code>flowchart LR\n  subgraph A[Chain State]\n    direction LR\n    B[\"Program Logic and Storage&lt;br/&gt;(Smart Contract)\"]\n    C[\"Tx Relevant Storage\"]\n  end\n  A --&gt; D[[Virtual Machine]]\n  E[Transaction] --&gt; D\n  D --&gt; F[(New State)]\n  D --&gt; G[Execution Logs]\n  style A fill:#ffffff,stroke:#000000,stroke-width:1px</code></pre> <p>In addition, because smart contracts are programs that execute on top of existing chains, teams don't have to think about the underlying consensus they are built on.</p> <p>These strengths do come with certain limitations. Some smart contracts environments, like EVM, tend to be immutable by default. Developers have developed different proxy strategies to be able to upgrade smart contracts over time. The typical pattern relies on a proxy contract which holds the program storage forwarding a call to an implementation contract where the execution logic resides. Smart contract upgrades require changing the implementation contract while retaining the same storage structure, necessitating careful planning.</p> <p>Another downside is that smart contracts often follow a gas metering model, where program execution is associated with a given unit and a marketplace is set up to pay for such an execution unit. This fee system is often very rigid, and some complex flows, like account abstraction, have been developed to circumvent this problem.</p> <p>In contrast, parachains can create their own custom logics (known as pallets or modules), and combine them as the state transition function (STF or runtime) thanks to the modularity provided by the Polkadot-SDK. The different pallets within the parachain runtime can give developers a lot of flexibility when building applications on top of it.</p> <pre><code>flowchart LR\n    A[(Chain State)] --&gt; B[[\"STF&lt;br/&gt;[Pallet 1]&lt;br/&gt;[Pallet 2]&lt;br/&gt;...&lt;br/&gt;[Pallet N]\"]]\n    C[Transaction&lt;br/&gt;Targeting Pallet 2] --&gt; B\n    B --&gt; E[(New State)]\n    B --&gt; F[Execution Logs]</code></pre> <p>Parachains inherently offer features such as logic upgradeability, flexible transaction fee mechanisms, and chain abstraction logic. More so, by using Polkadot, parachains can benefit from robust consensus guarantees with little engineering overhead.</p> <p>Additional information</p> <p>To read more about the differences between smart contracts and parachain runtimes, please Refer to the Runtime vs. Smart Contracts section of the Polkadot SDK Rust docs. For a more in-depth discussion on choosing between runtime development and smart contract development, you can check the post \"When should one build a Polkadot SDK runtime versus a Substrate (Polkadot SDK) smart contract?\" from Stack Overflow.</p>"},{"location":"develop/smart-contracts/overview/#building-a-smart-contract","title":"Building a Smart Contract","text":"<p>Polkadot's primary purpose is to provide security for parachains that connect to it. Therefore, it is not meant to support smart contract execution. Developers looking to build smart contract projects in Polkadot need to look into its ecosystem for parachains that support it.</p> <p>The Polkadot SDK supports multiple smart contract execution environments:</p> <ul> <li>EVM - through Frontier. It consists of a full Ethereum JSON RPC compatible client, an Ethereum emulation layer, and a Rust-based EVM. This is used by chains like Acala, Astar, Moonbeam and more</li> <li>Wasm - through the Contracts pallet. ink! is a smart contract language that provides a compiler to Wasm. Wasm contracts can be used by chains like Astar</li> <li>PolkaVM - a cutting-edge virtual machine tailored to optimize smart contract execution on Polkadot. Unlike traditional EVMs, PolkaVM is built with a RISC-V-based register architecture for increased performance and scalability</li> </ul>"},{"location":"develop/smart-contracts/overview/#evm-contracts","title":"EVM Contracts","text":"<p>The Frontier project provides a set of modules that enables a Polkadot SDK-based chain to run an Ethereum emulation layer that allows the execution of EVM smart contracts natively with the same API/RPC interface.</p> <p>Ethereum addresses (ECDSA) can also be mapped directly to and from the Polkadot SDK's SS58 scheme from existing accounts. Moreover, you can modify Polkadot SDK to use the ECDSA signature scheme directly to avoid any mapping.</p> <p>At a high level, Frontier is composed of three main components:</p> <ul> <li>Ethereum Client - an Ethereum JSON RPC compliant client that allows any request coming from an Ethereum tool, such as Remix, Hardhat or Foundry, to be admitted by the network</li> <li>Pallet Ethereum - a block emulation and Ethereum transaction validation layer that works jointly with the Ethereum client to ensure compatibility with Ethereum tools</li> <li>Pallet EVM - access layer to the Rust-based EVM, enabling the execution of EVM smart contract logic natively</li> </ul> <p>Broadly speaking, in this configuration, an EVM transaction follows the path presented in the diagram below:</p> <pre><code>flowchart TD\n    A[Users and Devs] --&gt;|Send Tx| B[Frontier RPC Ext]\n    subgraph C[Pallet Ethereum]\n        D[Validate Tx]\n        E[Send&lt;br/&gt;Valid Tx]    \n    end\n    B --&gt;|Interact with| C\n    D --&gt; E\n    subgraph F[Pallet EVM]\n        G[Rust EVM]\n    end\n    I[(Current EVM&lt;br/&gt;Emulated State)]\n\n    H[Smart Contract&lt;br/&gt;Solidity, Vyper...] &lt;--&gt;|Compiled to EVM&lt;br/&gt;Bytecode| I\n\n    C --&gt; F\n    I --&gt; F\n    F --&gt; J[(New Ethereum&lt;br/&gt;Emulated State)]\n    F --&gt; K[Execution Logs]\n\n    style C fill:#ffffff,stroke:#000000,stroke-width:1px\n    style F fill:#ffffff,stroke:#000000,stroke-width:1px</code></pre> <p>Although it seems complex, users and developers are abstracted of that complexity, and tools can easily interact with the parachain as they would with any other EVM-compatible environment.</p> <p>The Rust EVM is capable of executing regular EVM bytecode. Consequently, any language that compiles to EVM bytecode can be used to create programs that the parachain can execute.</p> <p>You can find more information on deploying EVM smart contracts to Polkadot's native smart contract platform, or any of the ecosystem parachains.</p>"},{"location":"develop/smart-contracts/overview/#wasm-contracts","title":"Wasm Contracts","text":"<p>The <code>pallet_contracts</code> provides the execution environment for Wasm-based smart contracts. Consequently, any smart contract language that compiles to Wasm can be executed in a parachain that enables this module.</p> <p>At the time of writing there are two main languages that can be used for Wasm programs:</p> <ul> <li>ink! - it is a Rust-based language that compiles to Wasm. It allows developers to inherit all its safety guarantees and use normal Rust tooling, being the dedicated domain-specific language</li> <li>Solidity - it can be compiled to Wasm via the Solang compiler. Consequently, developers can write Solidity 0.8 smart contracts that can be executed as Wasm programs in parachains</li> </ul> <p>Broadly speaking, with <code>pallet_contracts</code>, a transaction follows the path presented in the diagram below:</p> <pre><code>flowchart TD\n\n    subgraph A[Wasm Bytecode API]\n        C[Pallet Contracts]\n    end\n\n    B[Users and Devs] -- Interact with ---&gt; A\n\n    D[(Current State)]\n\n    E[Smart Contract&lt;br/&gt;ink!, Solidity...] &lt;--&gt;|Compiled to Wasm&lt;br/&gt;Bytecode| D\n\n    D --&gt; A\n    A --&gt; F[(New State)]\n    A --&gt; G[Execution Logs]\n\n    style A fill:#ffffff,stroke:#000000,stroke-width:1px</code></pre> <p>Learn more on how to build and deploy Wasm smart contracts on the Wasm Smart Contracts page.</p>"},{"location":"develop/smart-contracts/overview/#polkavm-contracts","title":"PolkaVM Contracts","text":"<p>A component of the Asset Hub parachain, PolkaVM helps enable the deployment of Solidity-based smart contracts directly on Asset Hub. Learn more about how this cutting edge virtual machine facilitates using familiar EVM contracts and tools with Asset Hub by visiting the Native EVM Contracts guide.</p>"},{"location":"develop/smart-contracts/wasm-ink/","title":"Wasm (ink!)","text":""},{"location":"develop/smart-contracts/wasm-ink/#introduction","title":"Introduction","text":"<p>The pallet_contracts is a specialized pallet within the Polkadot SDK that enables smart contract functionality through a WebAssembly (Wasm) execution environment. For developing smart contracts for this pallet, ink! emerges as the primary and recommended language. </p> <p>ink! is an embedded domain-specific language (eDSL) designed to develop Wasm smart contracts using the Rust programming language.</p> <p>Rather than creating a new language, ink! is just standard Rust in a well-defined \"contract format\" with specialized <code>#[ink(\u2026)]</code> attribute macros. These attribute macros tell ink! what the different parts of your Rust smart contract represent and ultimately allow ink! to do all the magic needed to create Polkadot SDK-compatible Wasm bytecode. Because of this, it inherits critical advantages such as:</p> <ul> <li>Strong memory safety guarantees</li> <li>Advanced type system</li> <li>Comprehensive development tooling</li> <li>Support from Rust's extensive developer community</li> </ul> <p>Since ink! smart contracts are compiled to Wasm, they offer high execution speed, platform independence, and enhanced security through sandboxed execution.</p>"},{"location":"develop/smart-contracts/wasm-ink/#installation","title":"Installation","text":"<p>ink! smart contract development requires the installation of cargo-contract, a command-line interface (CLI) tool that provides essential utilities for creating, testing, and managing ink! projects.</p> <p>For step-by-step installation instructions, including platform-specific requirements and troubleshooting tips, refer to the official <code>cargo-contract</code> Installation guide.</p>"},{"location":"develop/smart-contracts/wasm-ink/#get-started","title":"Get Started","text":"<p>To create a new ink! smart contract project, use the <code>cargo contract</code> command:</p> <pre><code>cargo contract new INSERT_PROJECT_NAME\n</code></pre> <p>This command generates a new project directory with the following structure:</p> <pre><code>INSERT_PROJECT_NAME/\n\u251c\u2500\u2500 lib.rs          # Contract source code\n\u251c\u2500\u2500 Cargo.toml      # Project configuration and dependencies\n\u2514\u2500\u2500 .gitignore      # Git ignore rules\n</code></pre> <p>The <code>lib.rs</code> file includes a basic contract template with storage and message-handling functionality. Customize this file to implement your contract\u2019s logic. The <code>Cargo.toml</code> file defines project dependencies, including the necessary ink! libraries and configuration settings.</p>"},{"location":"develop/smart-contracts/wasm-ink/#contract-structure","title":"Contract Structure","text":"<p>An ink! smart contract requires three fundamental components:</p> <ul> <li>A storage struct marked with <code>#[ink(storage)]</code></li> <li>At least one constructor function marked with <code>#[ink(constructor)]</code></li> <li>At least one message function marked with <code>#[ink(message)]</code></li> </ul>"},{"location":"develop/smart-contracts/wasm-ink/#default-template-structure","title":"Default Template Structure","text":"<p>The following example shows the basic contract structure generated by running <code>cargo contract new</code>:</p> <pre><code>#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\nmod flipper {\n\n    /// Defines the storage of your contract.\n    /// Add new fields to the below struct in order\n    /// to add new static storage fields to your contract.\n    #[ink(storage)]\n    pub struct Flipper {\n        /// Stores a single `bool` value on the storage.\n        value: bool,\n    }\n\n    impl Flipper {\n        /// Constructor that initializes the `bool` value to the given `init_value`.\n        #[ink(constructor)]\n        pub fn new(init_value: bool) -&gt; Self {\n            Self { value: init_value }\n        }\n\n        /// Constructor that initializes the `bool` value to `false`.\n        ///\n        /// Constructors can delegate to other constructors.\n        #[ink(constructor)]\n        pub fn default() -&gt; Self {\n            Self::new(Default::default())\n        }\n\n        /// A message that can be called on instantiated contracts.\n        /// This one flips the value of the stored `bool` from `true`\n        /// to `false` and vice versa.\n        #[ink(message)]\n        pub fn flip(&amp;mut self) {\n            self.value = !self.value;\n        }\n\n        /// Simply returns the current value of our `bool`.\n        #[ink(message)]\n        pub fn get(&amp;self) -&gt; bool {\n            self.value\n        }\n    }\n}\n</code></pre>"},{"location":"develop/smart-contracts/wasm-ink/#storage","title":"Storage","text":"<p>In an ink! contract, persistent storage is defined by a single struct annotated with the <code>#[ink(storage)]</code> attribute. This struct represents the contract's state and can use various data types for storing information, such as:</p> <ul> <li> <p>Common data types:</p> <ul> <li>Boolean values (<code>bool</code>)</li> <li>Unsigned integers (<code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>)</li> <li>Signed integers (<code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>)</li> <li>Tuples and arrays</li> </ul> </li> <li> <p>Substrate-specific types:</p> <ul> <li><code>AccountId</code> - contract and user addresses</li> <li><code>Balance</code> - token amounts</li> <li><code>Hash</code> - cryptographic hashes</li> </ul> </li> <li> <p>Data structures:</p> <ul> <li>Struct - custom data structures</li> <li>Vec - dynamic arrays</li> <li>Mapping - key-value storage</li> <li>BTreeMap- ordered maps</li> <li>HashMap - unordered maps</li> </ul> </li> </ul> <p>Example of a storage struct using various supported types:</p> <pre><code>#[ink(storage)]\npub struct Data {\n    /// A boolean flag to indicate a certain condition\n    flag: bool,\n    /// A vector to store multiple entries of unsigned 32-bit integers\n    entries: Vec&lt;u32&gt;,\n    /// An optional value that can store a specific integer or none\n    optional_value: Option&lt;i32&gt;,\n    /// A map to associate keys (as AccountId) with values (as unsigned 64-bit integers)\n    key_value_store: Mapping&lt;AccountId, u64&gt;,\n    /// A counter to keep track of some numerical value\n    counter: u64,\n}\n</code></pre> <p>For an in-depth explanation of storage and data structures in ink!, refer to the  Storage &amp; Data Structures section and the <code>#[ink(storage)]</code> macro definition in the official documentation.</p>"},{"location":"develop/smart-contracts/wasm-ink/#constructors","title":"Constructors","text":"<p>Constructors are functions that execute once when deploying the contract and are used to initialize the contract\u2019s state. Each contract must have at least one constructor, though multiple constructors can provide different initialization options.</p> <p>Example:</p> <pre><code>#[ink::contract]\nmod mycontract {\n\n    #[ink(storage)]\n    pub struct MyContract {\n        number: u32,\n    }\n\n    impl MyContract {\n        /// Constructor that initializes the `u32` value to the given `init_value`.\n        #[ink(constructor)]\n        pub fn new(init_value: u32) -&gt; Self {\n            Self {\n                number: init_value,\n            }\n        }\n\n        /// Constructor that initializes the `u32` value to the `u32` default.\n        #[ink(constructor)]\n        pub fn default() -&gt; Self {\n            Self {\n                number: Default::default(),\n            }\n        }\n    }\n\n    /* ... */\n}\n</code></pre> <p>Note</p> <p>In this example, <code>new(init_value: u32)</code> initializes <code>number</code> with a specified value, while <code>default()</code> initializes it with the type\u2019s default value (0 for <code>u32</code>). These constructors provide flexibility in contract deployment by supporting custom and default initialization options.</p> <p>For more information, refer to the official documentation for the <code>#[ink(constructor)]</code> macro definition.</p>"},{"location":"develop/smart-contracts/wasm-ink/#messages","title":"Messages","text":"<p>Messages are functions that interact with the contract, allowing users or other contracts to call specific methods. Each contract must define at least one message.</p> <p>There are two types of messages:</p> <ul> <li>Immutable messages (<code>&amp;self</code>) - these messages can only read the contract's state and cannot modify it</li> <li>Mutable messages (<code>&amp;mut self</code>) - these messages can read and modify the contract's state</li> </ul> <p>Note</p> <p><code>&amp;self</code> is a reference to the contract's storage.</p> <p>Example:</p> <pre><code>#[ink(message)]\npub fn my_getter(&amp;self) -&gt; u32 {\n    self.my_number\n}\n\n#[ink(message)]\npub fn my_setter(&amp;mut self, new_value: u32) -&gt; u32 {\n    self.my_number = new_value;\n}\n</code></pre> <p>Note</p> <p>In the example above, <code>my_getter</code> is an immutable message that reads state, while <code>my_setter</code> is a mutable message that updates state.</p> <p>For more information, refer to the official documentation on the <code>#[ink(message)]</code> macro.</p>"},{"location":"develop/smart-contracts/wasm-ink/#errors","title":"Errors","text":"<p>For defining errors, ink! uses idiomatic Rust error handling with the <code>Result&lt;T,E&gt;</code> type. These errors are user-defined by creating an <code>Error</code> enum and all the necessary types. If an error is returned, the contract reverts</p> <p>In ink!, errors are handled using idiomatic Rust practices with the <code>Result&lt;T, E&gt;</code> type. Custom error types are defined by creating an <code>Error</code> enum and specifying any necessary variants. If a message returns an error, the contract execution reverts, ensuring no changes are applied to the contract's state.</p> <p>Example:</p> <pre><code>[derive(Debug, PartialEq, Eq)]\n#[ink::scale_derive(Encode, Decode, TypeInfo)]\npub enum Error {\n    /// Returned if not enough balance to fulfill a request is available.\n    InsufficientBalance,\n    /// Returned if not enough allowance to fulfill a request is available.\n    InsufficientAllowance,\n}\n\nimpl Erc20 {\n    //...\n    #[ink(message)]\n    pub fn transfer_from(\n        &amp;mut self,\n        from: AccountId,\n        to: AccountId,\n        value: Balance,\n    ) -&gt; Result&lt;(),Error&gt; {\n        let caller = self.env().caller();\n        let allowance = self.allowance_impl(&amp;from, &amp;caller);\n        if allowance &lt; value {\n            return Err(Error::InsufficientAllowance)\n        }\n        //...\n    }\n    //...\n}\n</code></pre> <p>Note</p> <p>In this example, the <code>Error</code> enum defines custom error types <code>InsufficientBalance</code> and <code>InsufficientAllowance</code>. When <code>transfer_from</code> is called, it checks if the allowance is sufficient. If not, it returns an <code>InsufficientAllowance</code> error, causing the contract to revert. This approach ensures robust error handling for smart contracts.</p>"},{"location":"develop/smart-contracts/wasm-ink/#events","title":"Events","text":"<p>Events are a way of letting the outside world know about what's happening inside the contract. They are user-defined in a struct and decorated with the <code>#[ink(event)]</code> macro.</p> <p>Events allow the contract to communicate important occurrences to the outside world. They are user-defined by creating a struct and annotating it with the <code>#[ink(event)]</code> macro. Each field you want to index for efficient querying should be marked with <code>#[ink(topic)]</code>.</p> <p>Example:</p> <pre><code>/// Event emitted when a token transfer occurs.\n#[ink(event)]\npub struct Transfer {\n    #[ink(topic)]\n    from: Option&lt;AccountId&gt;,\n    #[ink(topic)]\n    to: Option&lt;AccountId&gt;,\n    value: Balance,\n}\n\nimpl Erc20 {\n    //...\n    #[ink(message)]\n    pub fn transfer_from(\n        &amp;mut self,\n        from: AccountId,\n        to: AccountId,\n        value: Balance,\n    ) -&gt; Result&lt;(),Error&gt; {\n        //...\n        self.env().emit_event(Transfer {\n            from: Some(from),\n            to: Some(to),\n            value,\n        });\n\n        Ok(())\n    }\n}\n</code></pre> <p>Note</p> <p>In this example, the <code>Transfer</code> event records the sender (<code>from</code>), the receiver (<code>to</code>), and the amount transferred (<code>value</code>). The event is emitted in the <code>transfer_from</code> function to notify external listeners whenever a transfer occurs.</p> <p>For more details, check the Events section and the <code>#[ink(event)]</code> macro documentation.</p>"},{"location":"develop/smart-contracts/wasm-ink/#where-to-go-next","title":"Where to Go Next?","text":"<p>To deepen your knowledge of ink! development, whether you're exploring foundational concepts or advanced implementations, the following resources provide essential guidance:</p> <ul> <li> <p>Official ink! documentation \u2014 a thorough resource with guides, in-depth explanations, and technical references to support you in mastering ink! development</p> </li> <li> <p><code>ink-examples</code> repository \u2014 a curated collection of smart contract examples that demonstrate best practices and commonly used design patterns</p> </li> </ul>"},{"location":"develop/smart-contracts/evm/","title":"EVM","text":"<p>Explore EVM support in Polkadot, covering native Asset Hub contracts and parachain implementations like Astar and Moonbeam for smart contract development.</p>"},{"location":"develop/smart-contracts/evm/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"develop/smart-contracts/evm/native-evm-contracts/","title":"Native EVM Contracts","text":""},{"location":"develop/smart-contracts/evm/native-evm-contracts/#introduction","title":"Introduction","text":"<p>The Asset Hub parachain is the cornerstone of asset management within the Polkadot ecosystem, providing seamless, secure access to digital assets. Native EVM contracts allow developers to deploy Solidity-based smart contracts directly on Asset Hub, enhancing developer efficiency and simplifying application design. This approach eliminates the complexity of asynchronous cross-chain communication and avoids the overhead of additional governance systems or tokens.</p> <p>This guide will help you understand the role of native EVM contracts and how they integrate with the Polkadot ecosystem. You will explore the components powering this functionality, including PolkaVM and Revive, and learn how to deploy and interact with smart contracts on Asset Hub using tools like MetaMask, Revive Remix, and Ethers.js.</p> <p>By enabling native smart contract deployment, Polkadot's Asset Hub streamlines blockchain development while preserving its secure, scalable foundation.</p>"},{"location":"develop/smart-contracts/evm/native-evm-contracts/#components","title":"Components","text":"<p>The native EVM contracts feature leverages several powerful components to deliver high performance and Solidity compatibility:</p> <ul> <li> <p><code>pallet_revive</code> - a runtime module that executes smart contracts by adding extrinsics, runtime APIs, and logic to convert Ethereum-style transactions into formats compatible with the blockchain. The workflow is as follows: </p> <ul> <li>Transactions are sent via a proxy server emulating Ethereum JSON RPC</li> <li>The proxy converts Ethereum transactions into a special dispatchable, leaving the payload intact </li> <li>The pallet's logic decodes and transforms these transactions into a format compatible with the blockchain</li> </ul> <p>Using a proxy avoids modifying the node binary, ensuring compatibility with alternative clients without requiring additional implementation.</p> </li> <li> <p>PolkaVM - a custom virtual machine optimized for performance with RISC-V-based architecture, supporting Solidity and additional high-performance languages</p> </li> <li> <p>Revive - compiles Solidity for PolkaVM by translating the solc compiler's YUL output into RISC-V. This translation simplifies development and ensures full compatibility with all Solidity versions and features</p> </li> <li> <p>Revive Remix - a modified fork of Remix IDE supporting backend compilation via LLVM-based Revive. Allows for efficient Solidity contract deployment on Polkadot</p> </li> </ul>"},{"location":"develop/smart-contracts/evm/native-evm-contracts/#polkavm","title":"PolkaVM","text":"<p>PolkaVM is a cutting-edge virtual machine tailored to optimize smart contract execution on Polkadot. Unlike traditional Ethereum Virtual Machines (EVM), PolkaVM is built with a RISC-V-based register architecture and a 64-bit word size, enabling:</p> <ul> <li>Faster arithmetic operations and efficient hardware translation</li> <li>Seamless integration of high-performance languages like C and Rust for advanced optimization</li> <li>Improved scalability for modern blockchain applications</li> </ul>"},{"location":"develop/smart-contracts/evm/native-evm-contracts/#compared-to-traditional-evms","title":"Compared to Traditional EVMs","text":"<ul> <li>Architecture - PolkaVM's register-based design offers significant performance improvements over Ethereum's stack-based EVM. It allows for faster compilation times and aligns better with modern hardware, reducing bottlenecks in contract execution</li> <li>Gas modeling - PolkaVM employs a multi-dimensional gas model, metering resources like computation time, storage, and proof sizes. This ensures more accurate cost assessments for contract execution, reducing overcharging for memory allocation and enabling efficient cross-contract calls</li> <li>Compatibility - while optimized for performance, PolkaVM remains compatible with Ethereum tools through a closely mirrored RPC interface, with minor adjustments for certain operations. It also hides the existential deposit requirement, simplifying user interactions by abstracting balance limitations</li> </ul>"},{"location":"develop/smart-contracts/evm/native-evm-contracts/#performance-benefits","title":"Performance Benefits","text":"<p>PolkaVM's innovations translate into significant performance gains, such as:</p> <ul> <li>Enhanced developer experience - faster execution and better tooling support</li> <li>Optimized resource use - reduced transaction costs with precise metering</li> <li>Broader language support - potential integration of languages like Rust and C for specialized use cases</li> </ul> <p>By combining advanced performance optimizations with Ethereum compatibility, PolkaVM bridges the gap between cutting-edge blockchain development and the familiar tools developers rely on.</p>"},{"location":"develop/smart-contracts/evm/native-evm-contracts/#get-started","title":"Get Started","text":"<p>The following sections guide you through the steps to connect to Asset Hub, deploy a smart contract, and interact with the contract using Ethers.js.</p>"},{"location":"develop/smart-contracts/evm/native-evm-contracts/#connect-to-asset-hub","title":"Connect to Asset Hub","text":"<p>Install any EVM-compatible wallet. To follow this example, install the MetaMask browser extension and add the Westend TestNet Asset Hub as a custom network using the following settings:</p> <ul> <li>Network name - <code>Asset-Hub Westend Testnet</code></li> <li>RPC URL - <code>https://westend-asset-hub-eth-rpc.polkadot.io</code></li> <li>Chain ID - <code>420420421</code></li> <li>Currency symbol - <code>WND</code></li> <li>Block explorer URL - <code>https://assethub-westend.subscan.io</code></li> </ul>"},{"location":"develop/smart-contracts/evm/native-evm-contracts/#deploy-a-contract","title":"Deploy a Contract","text":"<p>To deploy a contract to the Westend Asset Hub, you must get WND tokens. To do so, you can use the Westend Faucet. You need to specify the address where you want to receive the tokens from the faucet.</p> <p>For deploying and interacting with contracts in Revive Remix, you can use the following steps:</p> <ol> <li> <p>Open the Remix IDE, select any Solidity contract available, and compile it using the \u25b6\ufe0f button or the Solidity Compiler tab</p> <p></p> </li> <li> <p>Deploy the contract</p> <ol> <li>Click on the Deploy &amp; Run tab</li> <li>Choose the Westend TestNet - Metamask button. Your account address and balance will appear in the ACCOUNT field</li> <li> <p>Click on the Deploy button to launch the contract</p> <p></p> </li> </ol> </li> </ol> <p>After deployment, you can interact with the contract listed in the Deployed/Unpinned Contracts section within the Deploy &amp; Run tab. You can either call the smart contract methods or run tests against the contract to see if it works as expected.</p>"},{"location":"develop/smart-contracts/evm/native-evm-contracts/#use-ethersjs-to-interact","title":"Use Ethers.js to Interact","text":"<p>Once deployed, you can use the Ethers.js library to allow your application to interact with the contract. This library provides the tools needed to query data, send transactions, and listen to events through a provider, which links your application and the blockchain.</p> <ul> <li> <p>In browsers, providers are available through wallets like MetaMask, which inject an <code>ethereum</code> object into the <code>window</code>. Ensure that Metamask is installed and connected to Westend Asset Hub</p> <pre><code>import { BrowserProvider } from 'ethers';\n\n// Browser wallet will inject the ethereum object into the window object\nif (typeof window.ethereum == 'undefined') {\n  return console.log('No wallet installed');\n}\n\nconsole.log('An Ethereum wallet is installed!');\nconst provider = new BrowserProvider(window.ethereum);\n</code></pre> </li> <li> <p>For server-side applications, <code>JsonRpcProvider</code> can connect directly to RPC nodes:</p> <pre><code>import { JsonRpcProvider } from 'ethers';\n\nconst provider = new JsonRpcProvider(\n  'https://westend-asset-hub-eth-rpc.polkadot.io',\n);\n</code></pre> </li> </ul> <p>Once your application is connected, you can retrieve network data, access contract methods, and fully interact with the deployed smart contract.</p>"},{"location":"develop/smart-contracts/evm/native-evm-contracts/#where-to-go-next","title":"Where to Go Next","text":"<p>For further information about the Asset Hub smart contracts, please refer to the official documentation.</p>"},{"location":"develop/smart-contracts/evm/parachain-contracts/","title":"Parachain Contracts","text":""},{"location":"develop/smart-contracts/evm/parachain-contracts/#introduction","title":"Introduction","text":"<p>One key factor underpinning Ethereum's growth is the ease of deploying to the EVM. The EVM, or Ethereum Virtual Machine, provides developers with a consistent and predictable execution environment for smart contracts. While the EVM is not perfect, its popularity and ease of deployment have far outweighed any shortcomings and resulted in the massive growth of EVM-compatible smart contract platforms.</p> <p>Also integral to the proliferation of EVM-based smart contract networks is smart contract portability. Developers can take their smart contracts that they've deployed to Ethereum, and in many cases, deploy them to other EVM-compatible networks with minimal changes. More than \"Copy/Paste\" deployments, this enables chains' interoperability. Building a cross-chain application is much easier when both chains offer similar EVM compatibility.</p>"},{"location":"develop/smart-contracts/evm/parachain-contracts/#why-adopt-the-evm-as-a-polkadot-parachain","title":"Why Adopt the EVM as a Polkadot Parachain?","text":"<p>In addition to the developer mindshare of the EVM, Polkadot parachains leveraging the EVM can benefit from the extensive tooling for Ethereum developers that's already been built and battle-tested. This includes wallets, block explorers, developer tools, and more. Beyond just tools, the EVM has had a long headstart regarding smart contract auditors and institutional/custodial asset management. Integrating EVM compatibility can unlock several of these tools by default or allow for relatively easy future integrations.</p> <p>Polkadot enables parachains to supercharge the capabilities of their parachain beyond just the limitations of the EVM. To that end, many parachains have developed ways to tap into the powerful features offered by Polkadot, such as through precompiles or solidity interfaces that expose Substrate functionality to app developers and users. This guide will cover some of the unique features that each parachain offers. For more information about each parachain, visit the documentation site for the respective parachain.  </p>"},{"location":"develop/smart-contracts/evm/parachain-contracts/#evm-compatible-parachains","title":"EVM-Compatible Parachains","text":""},{"location":"develop/smart-contracts/evm/parachain-contracts/#astar","title":"Astar","text":"<p>Astar emerged as a key smart contract platform on Polkadot, distinguished by its unique multiple virtual machine approach that supports both EVM and WebAssembly (Wasm) smart contracts. This dual VM support allows developers to choose their preferred programming environment while maintaining full Ethereum compatibility. The platform's runtime is built on Substrate using FRAME, incorporating crucial components from Polkadot-SDK alongside custom-built modules for handling its unique features.</p> <p>Astar has established itself as an innovation hub through initiatives like the zk-rollup development framework and integration with multiple Layer 2 scaling solutions. Astar leverages XCM for native Polkadot ecosystem interoperability while maintaining connections to external networks through various bridge protocols. Through its support for both EVM and Wasm, along with advanced cross-chain capabilities, Astar serves as a crucial gateway for projects looking to leverage the unique advantages of both Ethereum and Polkadot ecosystems while maintaining seamless interoperability between them.</p>"},{"location":"develop/smart-contracts/evm/parachain-contracts/#technical-architecture","title":"Technical Architecture","text":"<pre><code>graph TB\n    subgraph A[\"DApp Layer\"]\n        direction TB\n        eth[\"Ethereum DApps\\n(Web3)\"]\n        wasm[\"Wasm DApps\\n(ink!, Ask!)\"]\n        substrate[\"Substrate DApps\\n(Polkadot.js)\"]\n    end\n\n    subgraph B[\"Astar Network\"]\n        direction TB\n        rpc[\"RPC Layer\\n(Web3 + Substrate)\"]\n\n        subgraph \"Runtime\"\n            xvm[\"Cross-Virtual Machine (XVM)\"]\n            evm[\"EVM\"]\n            wasm_vm[\"Wasm VM\"]\n\n            subgraph D[\"Core Features\"]\n                staking[\"dApp Staking\"]\n            end\n        end\n    end\n\n    subgraph C[\"Base Layer\"]\n        dot[\"Polkadot Relay Chain\\n(Shared Security)\"]\n    end\n\n    %% Connections\n    A --&gt; B\n    rpc --&gt; xvm\n    xvm --&gt; C\n    xvm --&gt; D\n    xvm --&gt; wasm_vm\n    xvm --&gt; evm\n\n    evm &lt;--&gt; wasm_vm</code></pre> <p>The diagram illustrates the layered architecture of Astar Network: at the top, dApps can interact with the Astar network through either Web3, Substrate, or Wasm. These requests flow through Astar's RPC layer into the main runtime, where the magic happens in the virtual machine layer. Here, Astar's unique Cross-Virtual Machine (XVM) coordinates between EVM and Wasm environments, allowing smart contracts from both ecosystems to interact. The Runtime also includes core blockchain functions through various pallets (like system operations and dApps staking), and everything is ultimately secured by connecting to the Polkadot Relay Chain at the bottom layer.</p>"},{"location":"develop/smart-contracts/evm/parachain-contracts/#endpoints-and-faucet","title":"Endpoints and Faucet","text":"Variable Value Network Name Shibuya Testnet EVM Chain ID 81 Public RPC URLs <pre><code>https://evm.shibuya.astar.network</code></pre> Public WSS URLs <pre><code>wss://evm.shibuya.astar.network</code></pre> Block Explorer Shibuya Blockscout Faucet Link Faucet - Astar Docs"},{"location":"develop/smart-contracts/evm/parachain-contracts/#moonbeam","title":"Moonbeam","text":"<p>Moonbeam was the first parachain to bring full Ethereum-compatibility to Polkadot, enabling Ethereum developers to bring their dApps to Polkadot and gain access to the rapidly growing Polkadot user base. Moonbeam's runtime is built using FRAME, and combines essential components from the Polkadot-SDK, Frontier, and custom pallets. The architecture integrates key Substrate offerings like balance management and transaction processing, while Frontier's pallets enable EVM execution and Ethereum compatibility. Custom pallets handle Moonbeam-specific features such as parachain staking and block author verification. Moonbeam offers a variety of precompiles for dApp developers to access powerful Polkadot features via a Solidity interface, such as governance, randomness, transaction batching, and more.</p> <p>Additionally, Moonbeam is a hub for interoperability and cross-chain connected contracts. Moonbeam has a variety of integrations with GMP (general message passing) providers, including Wormhole, LayerZero, Axelar, and more. These integrations make it easy for developers to build cross-chain contracts on Moonbeam, and they also play an integral role in connecting the entire Polkadot ecosystem with other blockchains. Innovations like Moonbeam Routed Liquidity, or MRL, enable users to bridge funds between chains like Ethereum and parachains like HydraDX. Through XCM, other parachains can connect to Moonbeam and access its established bridge connections to Ethereum and other networks, eliminating the need for each parachain to build and maintain their own bridges.</p>"},{"location":"develop/smart-contracts/evm/parachain-contracts/#technical-architecture_1","title":"Technical Architecture","text":"<pre><code>  graph LR\n      A[Existing&lt;br/&gt;EVM DApp&lt;/br&gt;Frontend]\n      B[Ethereum&lt;br/&gt;Development&lt;br/&gt;Tool]\n\n      subgraph C[Moonbeam Node]\n        direction LR\n        D[Web3 RPC]\n        subgraph E[Ethereum Pallet]\n          direction LR\n          F[Substrate&lt;br/&gt;Runtime&lt;br/&gt;Functions]\n          G[Block Processor]\n        end\n        subgraph H[EVM Pallet]\n          direction LR\n          I[EVM Execution]\n        end\n\n      end\n\n      A --&gt; C\n      B --&gt; C\n      D --&gt; E\n      F --&gt; G \n      E --&gt; H\n\n    classDef darkBackground fill:#2b2042,stroke:#000,color:#fff;\n    classDef lightBox fill:#b8a8d9,stroke:#000,color:#000;\n\n    class A,B darkBackground\n    class D,E,H lightBox</code></pre> <p>The diagram above illustrates how transactions are processed on Moonbeam. When a DApp or Ethereum development tool (like Hardhat) sends a Web3 RPC request, it's first received by a Moonbeam node. Moonbeam nodes are versatile - they support both Web3 and Substrate RPCs, giving developers the flexibility to use either Ethereum or Substrate tools. When these RPC calls come in, they're processed by corresponding functions in the Substrate runtime. The runtime verifies signatures and processes any Substrate extrinsics. Finally, if the transaction involves smart contracts, these are forwarded to Moonbeam's EVM for execution and state changes.</p>"},{"location":"develop/smart-contracts/evm/parachain-contracts/#endpoints-and-faucet_1","title":"Endpoints and Faucet","text":"Variable Value Network Name Moonbase Alpha Testnet EVM Chain ID 1287 Public RPC URLs <pre><code>https://rpc.api.moonbase.moonbeam.network</code></pre> Public WSS URLs <pre><code>wss://wss.api.moonbase.moonbeam.network</code></pre> Block Explorer Moonbase Alpha Moonscan Faucet Link Moonbase Faucet"},{"location":"develop/smart-contracts/evm/parachain-contracts/#acala","title":"Acala","text":"<p>Acala positioned itself as Polkadot's DeFi hub by introducing the Acala EVM+ - an enhanced version of the EVM specifically optimized for DeFi operations. This customized EVM implementation enables seamless deployment of Ethereum-based DeFi protocols while offering advanced features like on-chain scheduling, pre-built DeFi primitives, and native multi-token support that aren't available in traditional EVMs.</p> <p>Acala supports a comprehensive DeFi ecosystem including a decentralized stablecoin (aUSD) and a liquid staking derivative for DOT. The platform's EVM+ innovations extend beyond standard Ethereum compatibility by enabling direct interaction between EVM smart contracts and Substrate pallets, facilitating advanced cross-chain DeFi operations through XCM, and providing built-in oracle integrations. These enhancements make it possible for DeFi protocols to achieve functionality that would be prohibitively expensive or technically infeasible on traditional EVM chains.</p>"},{"location":"develop/smart-contracts/evm/parachain-contracts/#technical-architecture_2","title":"Technical Architecture","text":"<pre><code>graph TB\n    subgraph A[\"DApp Layer\"]\n        direction TB\n        eth[\"Ethereum DApps\\n(Web3 + bodhi.js)\"]\n        substrate[\"Substrate DApps\\n(Polkadot.js)\"]\n    end\n\n    subgraph B[\"Acala Network\"]\n        direction TB\n        rpc[\"RPC Layer\\n(Web3 + Substrate)\"]\n\n        subgraph \"Runtime\"\n            direction TB\n            evmplus[\"EVM+\"]\n\n            subgraph C[\"Core Components\"]\n                direction LR\n                storage[\"Storage Meter\"]\n                precompiles[\"Precompiled DeFi Contracts\\n(DEX, Oracle, Scheduler)\"]\n            end\n        end\n    end\n\n    subgraph D[\"Base Layer\"]\n        dot[\"Polkadot Relay Chain\\n(Shared Security)\"]\n    end\n\n    %% Simplified connections\n    A --&gt; B\n    rpc --&gt; evmplus\n    evmplus --&gt; C\n    evmplus --&gt; D</code></pre> <p>The diagram illustrates Acala's unique EVM+ architecture, which extends beyond standard EVM compatibility. At the top, DApps can interact with the network using either Ethereum tools (via Web3 and bodhi.js) or Substrate tools. These requests flow through Acala's dual RPC layer into the main Runtime. The key differentiator is the EVM+ environment, which includes special features like the Storage Meter for rent management, and numerous precompiled contracts (like DEX, Oracle, Schedule) that provide native Substrate functionality to EVM contracts. All of this runs on top of Polkadot's shared security as a parachain.</p>"},{"location":"develop/smart-contracts/evm/parachain-contracts/#endpoints-and-faucet_2","title":"Endpoints and Faucet","text":"Variable Value Network Name Mandala TC7 Testnet EVM Chain ID 595 Public RPC URLs <pre><code>https://eth-rpc-tc9.aca-staging.network</code></pre> Public WSS URLs <pre><code>wss://tc7-eth.aca-dev.network</code></pre> Block Explorer Mandala Blockscout Faucet Link Mandala Faucet"},{"location":"develop/smart-contracts/evm/parachain-contracts/#evm-developer-tools","title":"EVM Developer Tools","text":"<p>One of the key benefits of being an EVM-compatible parachain the ability for developers to use familiar developer tools, like Hardhat, Remix, and Foundry. Being compatible with the most widely adopted smart contract programming language, Solidity, means that developers can leverage existing smart contract templates and standards, such as the ones built by OpenZeppelin. To learn more, check out the following guides for each parachain:</p> AstarMoonbeamAcala <ul> <li>Hardhat</li> <li>Thirdweb</li> <li>Remix</li> <li>Privy embedded wallets</li> </ul> <ul> <li>Hardhat</li> <li>Thirdweb</li> <li>Remix</li> <li>Tenderly</li> <li>Foundry</li> <li>OpenZeppelin</li> </ul> <ul> <li>Hardhat</li> <li>Remix</li> <li>Waffle</li> </ul>"},{"location":"develop/smart-contracts/evm/parachain-contracts/#reading-contract-state-on-evm-compatible-parachains","title":"Reading Contract State on EVM-Compatible Parachains","text":"<p>The following section will dive into a practical demonstration. The following script showcases how to interact with multiple Polkadot parachains using their EVM compatibility. This script will query:</p> <ul> <li>Moonbeam for its Wormhole USDC total supply</li> <li>Acala for its native ACA token supply using a precompile</li> <li>Astar for its USDC total supply</li> </ul> <p>What makes this demo particularly powerful is that all three chains\u2014Astar, Moonbeam, and Acala\u2014share EVM compatibility. This means you can use a single, unified script to query token balances across all chains, simply by adjusting the RPC endpoints and token contract addresses. Thanks to EVM-compatibility, there's no need for chain-specific scripts or custom development work.</p> Expand to view the complete script <pre><code>// Required imports\nconst { ethers } = require('ethers');\n\n// Network RPC endpoints\nconst networkConfigs = {\n  moonbeam: {\n    rpc: 'https://rpc.api.moonbeam.network',\n    name: 'Moonbeam (Wormhole USDC)',\n  },\n  acala: {\n    rpc: 'https://eth-rpc-acala.aca-api.network',\n    name: 'Acala ACA',\n  },\n  astar: {\n    rpc: 'https://evm.astar.network',\n    name: 'Astar (USDC)',\n  },\n};\n\n// Minimal ERC20 ABI - we only need totalSupply\nconst erc20ABI = [\n  {\n    constant: true,\n    inputs: [],\n    name: 'totalSupply',\n    outputs: [{ name: '', type: 'uint256' }],\n    type: 'function',\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: 'decimals',\n    outputs: [{ name: '', type: 'uint8' }],\n    type: 'function',\n  },\n];\n\nasync function getTokenSupply(networkKey, tokenAddress) {\n  try {\n    // Get network configuration\n    const networkConfig = networkConfigs[networkKey];\n    if (!networkConfig) {\n      throw new Error(`Unsupported network: ${networkKey}`);\n    }\n\n    // Create provider and contract instance - Updated for ethers v6\n    const provider = new ethers.JsonRpcProvider(networkConfig.rpc);\n    const contract = new ethers.Contract(tokenAddress, erc20ABI, provider);\n\n    // Get total supply and decimals\n    const [totalSupply, decimals] = await Promise.all([\n      contract.totalSupply(),\n      contract.decimals(),\n    ]);\n\n    // Convert to human readable format\n    const formattedSupply = ethers.formatUnits(totalSupply, decimals);\n\n    return {\n      network: networkConfig.name,\n      tokenAddress,\n      totalSupply: formattedSupply,\n      rawTotalSupply: totalSupply.toString(),\n      decimals: decimals,\n    };\n  } catch (error) {\n    throw new Error(`Error fetching token supply: ${error.message}`);\n  }\n}\n\nasync function main() {\n  const tokens = {\n    moonbeam: '0x931715FEE2d06333043d11F658C8CE934aC61D0c', // Wormhole USDC\n    acala: '0x0000000000000000000100000000000000000000', // ACA\n    astar: '0x6a2d262D56735DbA19Dd70682B39F6bE9a931D98', // USDC on Astar\n  };\n\n  for (const [network, tokenAddress] of Object.entries(tokens)) {\n    try {\n      const result = await getTokenSupply(network, tokenAddress);\n      console.log(`\\n${result.network} Token Supply:`);\n      console.log(`Address: ${result.tokenAddress}`);\n      console.log(`Total Supply: ${result.totalSupply}`);\n      console.log(`Decimals: ${result.decimals}`);\n    } catch (error) {\n      console.error(`Error for ${network}:`, error.message);\n    }\n  }\n}\n\n// Execute the main function and handle any errors\nmain().catch((error) =&gt; {\n  console.error('Error in main:', error);\n  process.exit(1);\n});\n</code></pre> <p>This script demonstrates one of the fundamental ways to interact with blockchain networks - querying on-chain state through smart contract calls.  The standardized ERC20 interface (which most tokens implement) is used to read the total supply of tokens across different EVM networks. This type of interaction is \"read-only\" or a \"view\" call, meaning it is simply fetching data from the blockchain without making any transactions or state changes. Therefore, it isn't using any gas. Transactions that attempt to make a state change to the blockchain require gas.  The ability to query state like this is essential for DApps, analytics tools, and monitoring systems that need real-time blockchain data.</p>"},{"location":"develop/smart-contracts/evm/parachain-contracts/#where-to-go-next","title":"Where to Go Next?","text":"<p>Check out the links below for each respective parachain for network endpoints, getting started guides, and more.</p> AstarMoonbeamAcala <ul> <li>Astar Docs</li> <li>Astar Network Endpoints</li> <li>Build EVM Smart Contracts on Astar</li> </ul> <ul> <li>Moonbeam Docs</li> <li>Moonbeam Network Endpoints</li> <li>Get Started Building on Moonbeam</li> </ul> <ul> <li>Acala Docs</li> <li>Acala Network Endpoints</li> <li>About the Acala Network</li> </ul>"},{"location":"develop/toolkit/","title":"Toolkit","text":"<p>Learn about Polkadot's core development toolkit, from blockchain construction tools to API libraries and cross-chain messaging capabilities.</p>"},{"location":"develop/toolkit/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"develop/toolkit/api-libraries/","title":"API Libraries","text":"<p>Dive into APIs for interacting with the Polkadot network, including Polkadot-API, Polkadot.js, Python Substrate Interface, and Sidecar REST services.</p>"},{"location":"develop/toolkit/api-libraries/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"develop/toolkit/api-libraries/papi/","title":"Polkadot-API","text":""},{"location":"develop/toolkit/api-libraries/papi/#introduction","title":"Introduction","text":"<p>Polkadot-API (PAPI) is a set of libraries built to be modular, composable, and grounded in a \u201clight-client first\u201d approach. Its primary aim is to equip dApp developers with an extensive toolkit for building fully decentralized applications.</p> <p>PAPI is optimized for light-client functionality, using the new JSON-RPC spec to support decentralized interactions fully. It provides strong TypeScript support with types and documentation generated directly from on-chain metadata, and it offers seamless access to storage reads, constants, transactions, events, and runtime calls. Developers can connect to multiple chains simultaneously and prepare for runtime updates through multi-descriptor generation and compatibility checks. PAPI is lightweight and performant, leveraging native BigInt, dynamic imports, and modular subpaths to avoid bundling unnecessary assets. It supports promise-based and observable-based APIs, integrates easily with Polkadot.js extensions, and offers signing options through browser extensions or private keys.</p>"},{"location":"develop/toolkit/api-libraries/papi/#get-started","title":"Get Started","text":""},{"location":"develop/toolkit/api-libraries/papi/#api-instantiation","title":"API Instantiation","text":"<p>To instantiate the API, you can install the package by using the following command:</p> npmpnpmyarn <pre><code>npm i polkadot-api\n</code></pre> <pre><code>pnpm add polkadot-api\n</code></pre> <pre><code>yarn add polkadot-api\n</code></pre> <p>Then, obtain the latest metadata from the target chain and generate the necessary types:</p> <pre><code># Add the target chain\nnpx papi add dot -n polkadot\n</code></pre> <p>The <code>papi add</code> command initializes the library by generating the corresponding types needed for the chain used. It assigns the chain a custom name and specifies downloading metadata from the Polkadot chain. You can replace <code>dot</code> with the name you prefer or with another chain if you want to add a different one. Once the latest metadata is downloaded, generate the required types:</p> <pre><code># Generate the necessary types\nnpx papi\n</code></pre> <p>You can now set up a <code>PolkadotClient</code> with your chosen provider to begin interacting with the API. Choose from Smoldot via WebWorker, Node.js, or direct usage, or connect through the WSS provider. The examples below show how to configure each option for your setup.</p> Smoldot (WebWorker)Smoldot (Node.js)SmoldotWSS <pre><code>// `dot` is the identifier assigned during `npx papi add`\nimport { dot } from '@polkadot-api/descriptors';\nimport { createClient } from 'polkadot-api';\nimport { getSmProvider } from 'polkadot-api/sm-provider';\nimport { chainSpec } from 'polkadot-api/chains/polkadot';\nimport { startFromWorker } from 'polkadot-api/smoldot/from-worker';\nimport SmWorker from 'polkadot-api/smoldot/worker?worker';\n\nconst worker = new SmWorker();\nconst smoldot = startFromWorker(worker);\nconst chain = await smoldot.addChain({ chainSpec });\n\n// Establish connection to the Polkadot relay chain\nconst client = createClient(getSmProvider(chain));\n\n// To interact with the chain, obtain the `TypedApi`, which provides\n// the necessary types for every API call on this chain\nconst dotApi = client.getTypedApi(dot);\n</code></pre> <pre><code>// `dot` is the alias assigned during `npx papi add`\nimport { dot } from '@polkadot-api/descriptors';\nimport { createClient } from 'polkadot-api';\nimport { getSmProvider } from 'polkadot-api/sm-provider';\nimport { chainSpec } from 'polkadot-api/chains/polkadot';\nimport { startFromWorker } from 'polkadot-api/smoldot/from-node-worker';\nimport { fileURLToPath } from 'url';\nimport { Worker } from 'worker_threads';\n\n// Get the path for the worker file in ESM\nconst workerPath = fileURLToPath(\n  import.meta.resolve('polkadot-api/smoldot/node-worker'),\n);\n\nconst worker = new Worker(workerPath);\nconst smoldot = startFromWorker(worker);\nconst chain = await smoldot.addChain({ chainSpec });\n\n// Set up a client to connect to the Polkadot relay chain\nconst client = createClient(getSmProvider(chain));\n\n// To interact with the chain's API, use `TypedApi` for access to\n// all the necessary types and calls associated with this chain\nconst dotApi = client.getTypedApi(dot);\n</code></pre> <pre><code>// `dot` is the alias assigned when running `npx papi add`\nimport { dot } from '@polkadot-api/descriptors';\nimport { createClient } from 'polkadot-api';\nimport { getSmProvider } from 'polkadot-api/sm-provider';\nimport { chainSpec } from 'polkadot-api/chains/polkadot';\nimport { start } from 'polkadot-api/smoldot';\n\n// Initialize Smoldot client\nconst smoldot = start();\nconst chain = await smoldot.addChain({ chainSpec });\n\n// Set up a client to connect to the Polkadot relay chain\nconst client = createClient(getSmProvider(chain));\n\n// Access the `TypedApi` to interact with all available chain calls and types\nconst dotApi = client.getTypedApi(dot);\n</code></pre> <pre><code>// `dot` is the identifier assigned when executing `npx papi add`\nimport { dot } from '@polkadot-api/descriptors';\nimport { createClient } from 'polkadot-api';\n// Use this import for Node.js environments\nimport { getWsProvider } from 'polkadot-api/ws-provider/web';\nimport { withPolkadotSdkCompat } from 'polkadot-api/polkadot-sdk-compat';\n\n// Establish a connection to the Polkadot relay chain\nconst client = createClient(\n  // The Polkadot SDK nodes may have compatibility issues; using this enhancer is recommended.\n  // Refer to the Requirements page for additional details\n  withPolkadotSdkCompat(getWsProvider('wss://dot-rpc.stakeworld.io')),\n);\n\n// To interact with the chain, obtain the `TypedApi`, which provides\n// the types for all available calls in that chain\nconst dotApi = client.getTypedApi(dot);\n</code></pre> <p>Now that you have set up the client, you can interact with the chain by reading and sending transactions.</p>"},{"location":"develop/toolkit/api-libraries/papi/#reading-chain-data","title":"Reading Chain Data","text":"<p>The <code>TypedApi</code> provides a streamlined way to read blockchain data through three main interfaces, each designed for specific data access patterns:</p> <ul> <li> <p>Constants - access fixed values or configurations on the blockchain using the <code>constants</code> interface:</p> <pre><code>const version = await typedApi.constants.System.Version();\n</code></pre> </li> <li> <p>Storage queries - retrieve stored values by querying the blockchain\u2019s storage via the <code>query</code> interface:</p> <pre><code>const asset = await api.query.ForeignAssets.Asset.getValue(\n  token.location,\n  { at: 'best' },\n);\n</code></pre> </li> <li> <p>Runtime APIs - interact directly with runtime APIs using the <code>apis</code> interface:</p> <pre><code>const metadata = await typedApi.apis.Metadata.metadata();\n</code></pre> </li> </ul> <p>To learn more about the different actions you can perform with the <code>TypedApi</code>, refer to the TypedApi reference.</p>"},{"location":"develop/toolkit/api-libraries/papi/#sending-transactions","title":"Sending Transactions","text":"<p>In PAPI, the <code>TypedApi</code> provides the <code>tx</code> and <code>txFromCallData</code> methods to send transactions. </p> <ul> <li> <p>The <code>tx</code> method allows you to directly send a transaction with the specified parameters by using the <code>typedApi.tx.Pallet.Call</code> pattern:</p> <pre><code>const tx: Transaction = typedApi.tx.Pallet.Call({arg1, arg2, arg3});\n</code></pre> <p>For instance, to execute the <code>balances.transferKeepAlive</code> call, you can use the following snippet:</p> <pre><code>import { MultiAddress } from '@polkadot-api/descriptors';\n\nconst tx: Transaction = typedApi.tx.Balances.transfer_keep_alive({\n  dest: MultiAddress.Id('INSERT_DESTINATION_ADDRESS'),\n  value: BigInt(INSERT_VALUE),\n});\n</code></pre> <p>Ensure you replace <code>INSERT_DESTINATION_ADDRESS</code> and <code>INSERT_VALUE</code> with the actual destination address and value, respectively.</p> </li> <li> <p>The <code>txFromCallData</code> method allows you to send a transaction using the call data. This option accepts binary call data and constructs the transaction from it. It validates the input upon creation and will throw an error if invalid data is provided. The pattern is as follows:</p> <pre><code>const callData = Binary.fromHex('0x...');\nconst tx: Transaction = typedApi.txFromCallData(callData);\n</code></pre> <p>For instance, to execute a transaction using the call data, you can use the following snippet:</p> <pre><code>const callData = Binary.fromHex('0x00002470617065726d6f6f6e');\nconst tx: Transaction = typedApi.txFromCallData(callData);\n</code></pre> </li> </ul> <p>For more information about sending transactions, refer to the Transactions page.</p>"},{"location":"develop/toolkit/api-libraries/papi/#where-to-go-next","title":"Where to Go Next","text":"<p>For an in-depth guide on how to use PAPI, refer to the official PAPI documentation.</p>"},{"location":"develop/toolkit/api-libraries/polkadot-js-api/","title":"Polkadot.js API","text":""},{"location":"develop/toolkit/api-libraries/polkadot-js-api/#introduction","title":"Introduction","text":"<p>The Polkadot.js API uses JavaScript/TypeScript to interact with Polkadot SDK-based chains. It allows you to query nodes, read chain state, and submit transactions through a dynamic, auto-generated API interface.</p>"},{"location":"develop/toolkit/api-libraries/polkadot-js-api/#dynamic-api-generation","title":"Dynamic API Generation","text":"<p>Unlike traditional static APIs, the Polkadot.js API generates its interfaces automatically when connecting to a node. Here's what happens when you connect:</p> <ol> <li>The API connects to your node</li> <li>It retrieves the chain's metadata</li> <li>Based on this metadata, it creates specific endpoints in this format: <code>api.&lt;type&gt;.&lt;module&gt;.&lt;section&gt;</code></li> </ol>"},{"location":"develop/toolkit/api-libraries/polkadot-js-api/#available-api-categories","title":"Available API Categories","text":"<p>You can access three main categories of chain interactions:</p> <ul> <li> <p>Runtime constants (<code>api.consts</code>)</p> <ul> <li>Access runtime constants directly</li> <li>Returns values immediately without function calls</li> <li>Example - <code>api.consts.balances.existentialDeposit</code></li> </ul> </li> <li> <p>State queries (<code>api.query</code>)</p> <ul> <li>Read chain state</li> <li>Example - <code>api.query.system.account(accountId)</code></li> </ul> </li> <li> <p>Transactions (<code>api.tx</code>)</p> <ul> <li>Submit extrinsics (transactions)</li> <li>Example - <code>api.tx.balances.transfer(accountId, value)</code></li> </ul> </li> </ul> <p>The available methods and interfaces will automatically reflect what's possible on your connected chain.</p>"},{"location":"develop/toolkit/api-libraries/polkadot-js-api/#installation","title":"Installation","text":"<p>To add the Polkadot.js API to your project:</p> npmpnpmyarn <pre><code>npm i @polkadot/api\n</code></pre> <pre><code>pnpm add @polkadot/api\n</code></pre> <pre><code>yarn add @polkadot/api\n</code></pre> <p>This command installs the latest stable release, which supports any Polkadot SDK-based chain.</p> <p>Note</p> <p>For more installation details, refer to the Installation section in the official Polkadot.js API documentation.</p>"},{"location":"develop/toolkit/api-libraries/polkadot-js-api/#get-started","title":"Get Started","text":""},{"location":"develop/toolkit/api-libraries/polkadot-js-api/#creating-an-api-instance","title":"Creating an API Instance","text":"<p>To interact with a Polkadot SDK-based chain, you must establish a connection through an API instance. The API provides methods for querying chain state, sending transactions, and subscribing to updates.</p> <p>To create an API connection:</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\n// Create a WebSocket provider\nconst wsProvider = new WsProvider('wss://rpc.polkadot.io');\n\n// Initialize the API\nconst api = await ApiPromise.create({ provider: wsProvider });\n\n// Verify the connection by getting the chain's genesis hash\nconsole.log('Genesis Hash:', api.genesisHash.toHex());\n</code></pre> <p>Note</p> <p>All <code>await</code> operations must be wrapped in an async function or block since the API uses promises for asynchronous operations.</p>"},{"location":"develop/toolkit/api-libraries/polkadot-js-api/#reading-chain-data","title":"Reading Chain Data","text":"<p>The API provides several ways to read data from the chain. You can access:</p> <ul> <li> <p>Constants - values that are fixed in the runtime and don't change without a runtime upgrade</p> <pre><code>// Get the minimum balance required for a new account\nconst minBalance = api.consts.balances.existentialDeposit.toNumber();\n</code></pre> </li> <li> <p>State - current chain state that updates with each block</p> <pre><code>// Example address\nconst address = '5DTestUPts3kjeXSTMyerHihn1uwMfLj8vU8sqF7qYrFabHE';\n\n// Get current timestamp\nconst timestamp = await api.query.timestamp.now();\n\n// Get account information\nconst { nonce, data: balance } = await api.query.system.account(address);\n\nconsole.log(`\n  Timestamp: ${timestamp}\n  Free Balance: ${balance.free}\n  Nonce: ${nonce}\n`);\n</code></pre> </li> </ul>"},{"location":"develop/toolkit/api-libraries/polkadot-js-api/#sending-transactions","title":"Sending Transactions","text":"<p>Transactions (also called extrinsics) modify the chain state. Before sending a transaction, you need:</p> <ul> <li>A funded account with sufficient balance to pay transaction fees</li> <li>The account's keypair for signing</li> </ul> <p>To make a transfer:</p> <pre><code>// Assuming you have an `alice` keypair from the Keyring\nconst recipient = 'INSERT_RECIPIENT_ADDRESS';\nconst amount = 'INSERT_VALUE'; // Amount in the smallest unit (e.g., Planck for DOT)\n\n// Sign and send a transfer\nconst txHash = await api.tx.balances\n  .transfer(recipient, amount)\n  .signAndSend(alice);\n\nconsole.log('Transaction Hash:', txHash);\n</code></pre> <p>Note</p> <p>The <code>alice</code> keypair in the example comes from a Keyring object. See the Keyring documentation for details on managing keypairs.</p>"},{"location":"develop/toolkit/api-libraries/polkadot-js-api/#where-to-go-next","title":"Where to Go Next","text":"<p>For more detailed information about the Polkadot.js API, check the official documentation.</p>"},{"location":"develop/toolkit/api-libraries/py-substrate-interface/","title":"Python Substrate Interface","text":""},{"location":"develop/toolkit/api-libraries/py-substrate-interface/#introduction","title":"Introduction","text":"<p>The Python Substrate Interface is a powerful library that enables interaction with Polkadot SDK-based chains. It provides essential functionality for:</p> <ul> <li>Querying on-chain storage</li> <li>Composing and submitting extrinsics</li> <li>SCALE encoding/decoding</li> <li>Interacting with Substrate runtime metadata</li> <li>Managing blockchain interactions through convenient utility methods</li> </ul>"},{"location":"develop/toolkit/api-libraries/py-substrate-interface/#installation","title":"Installation","text":"<p>Install the library using <code>pip</code>:</p> <pre><code>pip install substrate-interface\n</code></pre> <p>Note</p> <p>For more installation details, refer to the Installation section in the official Python Substrate Interface documentation.</p>"},{"location":"develop/toolkit/api-libraries/py-substrate-interface/#get-started","title":"Get Started","text":"<p>This guide will walk you through the basic operations with the Python Substrate Interface: connecting to a node, reading chain state, and submitting transactions.</p>"},{"location":"develop/toolkit/api-libraries/py-substrate-interface/#establishing-connection","title":"Establishing Connection","text":"<p>The first step is to establish a connection to a Polkadot SDK-based node. You can connect to either a local or remote node:</p> <pre><code>from substrateinterface import SubstrateInterface\n\n# Connect to a node using websocket\nsubstrate = SubstrateInterface(\n    # For local node: \"ws://127.0.0.1:9944\"\n    # For Polkadot: \"wss://rpc.polkadot.io\"\n    # For Kusama: \"wss://kusama-rpc.polkadot.io\"\n    url=\"INSERT_WS_URL\"\n)\n\n# Verify connection\nprint(f\"Connected to chain: {substrate.chain}\")\n</code></pre>"},{"location":"develop/toolkit/api-libraries/py-substrate-interface/#reading-chain-state","title":"Reading Chain State","text":"<p>You can query various on-chain storage items. To retrieve data, you need to specify three key pieces of information:</p> <ul> <li>Pallet name - module or pallet that contains the storage item you want to access</li> <li>Storage item - specific storage entry you want to query within the pallet</li> <li>Required parameters - any parameters needed to retrieve the desired data</li> </ul> <p>Here's an example of how to check an account's balance and other details:</p> <pre><code># ...\n\n# Query account balance and info\naccount_info = substrate.query(\n    module=\"System\",  # The pallet name\n    storage_function=\"Account\",  # The storage item\n    params=[\"INSERT_ADDRESS\"],  # Account address in SS58 format\n)\n\n# Access account details from the result\nfree_balance = account_info.value[\"data\"][\"free\"]\nreserved = account_info.value[\"data\"][\"reserved\"]\nnonce = account_info.value[\"nonce\"]\n\nprint(\n    f\"\"\"\n    Account Details:\n    - Free Balance: {free_balance}\n    - Reserved: {reserved} \n    - Nonce: {nonce}\n    \"\"\"\n)\n</code></pre>"},{"location":"develop/toolkit/api-libraries/py-substrate-interface/#submitting-transactions","title":"Submitting Transactions","text":"<p>To modify the chain state, you need to submit transactions (extrinsics). Before proceeding, ensure you have:</p> <ul> <li>A funded account with sufficient balance to pay transaction fees</li> <li>Access to the account's keypair</li> </ul> <p>Here's how to create and submit a balance transfer:</p> <pre><code>#...\n\n# Compose the transfer call\ncall = substrate.compose_call(\n    call_module=\"Balances\",  # The pallet name\n    call_function=\"transfer_keep_alive\",  # The extrinsic function\n    call_params={\n        'dest': 'INSERT_ADDRESS',  # Recipient's address\n        'value': 'INSERT_VALUE'  # Amount in smallest unit (e.g., Planck for DOT)\n    }\n)\n\n# Create a signed extrinsic\nextrinsic = substrate.create_signed_extrinsic(\n    call=call, keypair=keypair  # Your keypair for signing\n)\n\n# Submit and wait for inclusion\nreceipt = substrate.submit_extrinsic(\n    extrinsic, wait_for_inclusion=True  # Wait until the transaction is in a block\n)\n\nif receipt.is_success:\n    print(\n        f\"\"\"\n        Transaction successful:\n        - Extrinsic Hash: {receipt.extrinsic_hash}\n        - Block Hash: {receipt.block_hash}\n        \"\"\"\n    )\nelse:\n    print(f\"Transaction failed: {receipt.error_message}\")\n</code></pre> <p>Note</p> <p>The <code>keypair</code> object is essential for signing transactions. See the Keypair documentation for more details.</p>"},{"location":"develop/toolkit/api-libraries/py-substrate-interface/#where-to-go-next","title":"Where to Go Next","text":"<p>Now that you understand the basics, you can:</p> <ul> <li>Explore more complex queries and transactions</li> <li>Learn about batch transactions and utility functions</li> <li>Discover how to work with custom pallets and types</li> </ul> <p>For comprehensive reference materials and advanced features, visit the py-substrate-interface documentation.</p>"},{"location":"develop/toolkit/api-libraries/sidecar/","title":"Sidecar API","text":""},{"location":"develop/toolkit/api-libraries/sidecar/#introduction","title":"Introduction","text":"<p>The Sidecar Rest API is a service that provides a REST interface for interacting with Polkadot SDK-based blockchains. With this API, developers can easily access a broad range of endpoints for nodes, accounts, transactions, parachains, and more.</p> <p>Sidecar functions as a caching layer between your application and a Polkadot SDK-based node, offering standardized REST endpoints that simplify interactions without requiring complex, direct RPC calls. This approach is especially valuable for developers who prefer REST APIs or build applications in languages with limited WebSocket support.</p> <p>Some of the key features of the Sidecar API include:</p> <ul> <li>REST API interface - provides a familiar REST API interface for interacting with Polkadot SDK-based chains</li> <li>Standardized endpoints - offers consistent endpoint formats across different chain implementations</li> <li>Caching layer - acts as a caching layer to improve performance and reduce direct node requests</li> <li>Multiple chain support - works with any Polkadot SDK-based chain, including Polkadot, Kusama, and custom chains</li> </ul>"},{"location":"develop/toolkit/api-libraries/sidecar/#installation","title":"Installation","text":"<p>To install Substrate API Sidecar, use one of the following commands:</p> npmpnpmyarn <pre><code>npm install -g @substrate/api-sidecar\n</code></pre> <pre><code>pnpm install -g @substrate/api-sidecar\n</code></pre> <pre><code>yarn global add @substrate/api-sidecar\n</code></pre> <p>Note</p> <p>Sidecar API requires Node.js version 18.14 LTS or higher. Verify your Node.js version:</p> <pre><code>node --version\n</code></pre> <p>If you need to install or update Node.js, visit the official Node.js website to download and install the latest LTS version.</p> <p>You can confirm the installation by running:</p> <pre><code>substrate-api-sidecar --version\n</code></pre> <p>For more information about the Sidecar API installation, please refer to the official documentation.</p>"},{"location":"develop/toolkit/api-libraries/sidecar/#usage","title":"Usage","text":"<p>To use the Sidecar API, you have two options:</p> <ul> <li>Local node - run a node locally, which Sidecar will connect to by default, requiring no additional configuration. To start, run:     <pre><code>substrate-api-sidecar\n</code></pre></li> <li> <p>Remote node - connect Sidecar to a remote node by specifying the RPC endpoint for that chain. For example, to gain access to the Polkadot Asset Hub associated endpoints:     <pre><code>SAS_SUBSTRATE_URL=wss://polkadot-asset-hub-rpc.polkadot.io substrate-api-sidecar\n</code></pre></p> <p>Note</p> <p>More configuration details are available in the Configuration section of the Sidecar API documentation.</p> </li> </ul> <p>Once the Sidecar API is running, you\u2019ll see output similar to this:</p> SAS_SUBSTRATE_URL=wss://polkadot-asset-hub-rpc.polkadot.io substrate-api-sidecar SAS: \ud83d\udce6 LOG:    \u2705 LEVEL: \"info\"    \u2705 JSON: false    \u2705 FILTER_RPC: false    \u2705 STRIP_ANSI: false    \u2705 WRITE: false    \u2705 WRITE_PATH: \"/opt/homebrew/lib/node_modules/@substrate/api-sidecar/build/src/logs\"    \u2705 WRITE_MAX_FILE_SIZE: 5242880    \u2705 WRITE_MAX_FILES: 5 \ud83d\udce6 SUBSTRATE:    \u2705 URL: \"wss://polkadot-asset-hub-rpc.polkadot.io\"    \u2705 TYPES_BUNDLE: undefined    \u2705 TYPES_CHAIN: undefined    \u2705 TYPES_SPEC: undefined    \u2705 TYPES: undefined    \u2705 CACHE_CAPACITY: undefined \ud83d\udce6 EXPRESS:    \u2705 BIND_HOST: \"127.0.0.1\"    \u2705 PORT: 8080    \u2705 KEEP_ALIVE_TIMEOUT: 5000 \ud83d\udce6 METRICS:    \u2705 ENABLED: false    \u2705 PROM_HOST: \"127.0.0.1\"    \u2705 PROM_PORT: 9100    \u2705 LOKI_HOST: \"127.0.0.1\"    \u2705 LOKI_PORT: 3100    \u2705 INCLUDE_QUERYPARAMS: false 2024-11-06 08:06:01 info: Version: 19.3.0 2024-11-06 08:06:02 warn: API/INIT: RPC methods not decorated: chainHead_v1_body, chainHead_v1_call, chainHead_v1_continue, chainHead_v1_follow, chainHead_v1_header, chainHead_v1_stopOperation, chainHead_v1_storage, chainHead_v1_unfollow, chainHead_v1_unpin, chainSpec_v1_chainName, chainSpec_v1_genesisHash, chainSpec_v1_properties, transactionWatch_v1_submitAndWatch, transactionWatch_v1_unwatch, transaction_v1_broadcast, transaction_v1_stop 2024-11-06 08:06:02 info: Connected to chain Polkadot Asset Hub on the statemint client at wss://polkadot-asset-hub-rpc.polkadot.io 2024-11-06 08:06:02 info: Listening on http://127.0.0.1:8080/ 2024-11-06 08:06:02 info: Check the root endpoint (http://127.0.0.1:8080/) to see the available endpoints for the current node <p>With Sidecar running, you can access the exposed endpoints via a browser, <code>Postman</code>, <code>curl</code>, or your preferred tool.</p>"},{"location":"develop/toolkit/api-libraries/sidecar/#endpoints","title":"Endpoints","text":"<p>Sidecar API provides a set of REST endpoints that allow you to query different aspects of the chain, including blocks, accounts, and transactions. Each endpoint offers specific insights into the chain\u2019s state and activities.</p> <p>For example, to retrieve the version of the node, use the <code>/node/version</code> endpoint:</p> <pre><code>curl -X 'GET' \\\n  'http://127.0.0.1:8080/node/version' \\\n  -H 'accept: application/json'\n</code></pre> <p>Note</p> <p>Alternatively, you can access <code>http://127.0.0.1:8080/node/version</code> directly in a browser since it\u2019s a <code>GET</code> request.</p> <p>In response, you\u2019ll see output similar to this (assuming you\u2019re connected to Polkadot Asset Hub):</p> curl -X 'GET' 'http://127.0.0.1:8080/node/version' -H 'accept: application/json' {     \"clientVersion\": \"1.16.1-835e0767fe8\",     \"clientImplName\": \"statemint\",     \"chain\": \"Polkadot Asset Hub\" } <p>For a complete list of available endpoints and their documentation, visit the Sidecar API list endpoints. You can learn about the endpoints and how to use them in your applications.</p>"},{"location":"develop/toolkit/api-libraries/sidecar/#where-to-go-next","title":"Where to Go Next","text":"<p>To dive deeper, refer to the official Sidecar documentation. This provides a comprehensive guide to the available configurations and advanced usage.</p>"},{"location":"develop/toolkit/integrations/","title":"Integrations","text":"<p>Explore fundamental integrations in the Polkadot ecosystem, including indexers for querying blockchain data, oracles for external data, and wallets.</p>"},{"location":"develop/toolkit/integrations/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"develop/toolkit/integrations/indexers/","title":"Indexers","text":""},{"location":"develop/toolkit/integrations/indexers/#the-challenge-of-blockchain-data-access","title":"The Challenge of Blockchain Data Access","text":"<p>Blockchain data is inherently sequential and distributed, with information stored chronologically across numerous blocks. While retrieving data from a single block through JSON-RPC API calls is straightforward, more complex queries that span multiple blocks present significant challenges:</p> <ul> <li>Data is scattered and unorganized across the blockchain</li> <li>Retrieving large datasets can take days or weeks to sync</li> <li>Complex operations (like aggregations, averages, or cross-chain queries) require additional processing</li> <li>Direct blockchain queries can impact dApp performance and responsiveness</li> </ul>"},{"location":"develop/toolkit/integrations/indexers/#what-is-a-blockchain-indexer","title":"What is a Blockchain Indexer?","text":"<p>A blockchain indexer is a specialized infrastructure tool that processes, organizes, and stores blockchain data in an optimized format for efficient querying. Think of it as a search engine for blockchain data that:</p> <ul> <li>Continuously monitors the blockchain for new blocks and transactions</li> <li>Processes and categorizes this data according to predefined schemas</li> <li>Stores the processed data in an easily queryable database</li> <li>Provides efficient APIs (typically GraphQL) for data retrieval</li> </ul>"},{"location":"develop/toolkit/integrations/indexers/#indexer-implementations","title":"Indexer Implementations","text":"<ul> <li> <p>Subsquid</p> <p>Subsquid is a data network that allows rapid and cost-efficient retrieval of blockchain data from 100+ chains using Subsquid's decentralized data lake and open-source SDK. In simple terms, Subsquid can be considered an ETL (extract, transform, and load) tool with a GraphQL server included. It enables comprehensive filtering, pagination, and even full-text search capabilities. Subsquid has native and full support for EVM and Substrate data, even within the same project.</p> <p> Reference</p> </li> <li> <p>Subquery</p> <p>SubQuery is a fast, flexible, and reliable open-source data decentralised infrastructure network that provides both RPC and indexed data to consumers worldwide. It provides custom APIs for your web3 project across multiple supported chains.</p> <p> Reference</p> </li> </ul>"},{"location":"develop/toolkit/integrations/oracles/","title":"Oracles","text":""},{"location":"develop/toolkit/integrations/oracles/#what-is-a-blockchain-oracle","title":"What is a Blockchain Oracle?","text":"<p>Oracles enable blockchains to access external data sources. Since blockchains operate as isolated networks, they cannot natively interact with external systems - this limitation is known as the \"blockchain oracle problem.\" Oracles solves this by extracting data from external sources (like APIs, IoT devices, or other blockchains), validating it, and submitting it on-chain.</p> <p>While simple oracle implementations may rely on a single trusted provider, more sophisticated solutions use decentralized networks where multiple providers stake assets and reach consensus on data validity. Typical applications include DeFi price feeds, weather data for insurance contracts, and cross-chain asset verification.</p>"},{"location":"develop/toolkit/integrations/oracles/#oracle-implementations","title":"Oracle Implementations","text":"<ul> <li> <p>Acurast</p> <p>Acurast is a decentralized, serverless cloud platform that uses a distributed network of mobile devices for oracle services, addressing centralized trust and data ownership issues. In the Polkadot ecosystem, it allows developers to define off-chain data and computation needs, which are processed by these devices acting as decentralized oracle nodes, delivering results to Substrate (Wasm) and EVM environments.</p> <p> Reference</p> </li> <li> <p>Chainlink</p> <p>Chainlink is a decentralized oracle network that brings external data onto blockchains. It acts as a secure bridge between traditional data sources and blockchain networks, enabling access to real-world information reliably. In the Polkadot ecosystem, Chainlink provides the Chainlink Feed Pallet, a Polkadot SDK-based oracle module that enables access to price reference data across your runtime logic.</p> <p> Reference</p> </li> </ul>"},{"location":"develop/toolkit/integrations/wallets/","title":"Wallets","text":""},{"location":"develop/toolkit/integrations/wallets/#what-is-a-blockchain-wallet","title":"What is a Blockchain Wallet?","text":"<p>A wallet serves as your gateway to interacting with blockchain networks. Rather than storing funds, wallets secure your private keys, controlling access to your blockchain assets. Your private key provides complete control over all permitted transactions on your blockchain account, making it essential to keep it secure.</p> <p>Wallet types fall into two categories based on their connection to the internet:</p> <ul> <li>Hot wallets - online storage through websites, browser extensions or smartphone apps</li> <li>Cold wallets - offline storage using hardware devices or air-gapped systems</li> </ul>"},{"location":"develop/toolkit/integrations/wallets/#hot-wallets","title":"Hot Wallets","text":"<ul> <li> <p>Nova Wallet</p> <p>A non-custodial, mobile-first wallet for managing assets and interacting with the Polkadot and Kusama ecosystems. It supports staking, governance, cross-chain transfers, and crowdloans. With advanced features, seamless multi-network support, and strong security, Nova Wallet empowers users to explore the full potential of Polkadot parachains on the go.</p> <p> Reference</p> </li> <li> <p>Talisman</p> <p>A non-custodial web browser extension that allows you to manage your portfolio and interact with Polkadot and Ethereum applications. It supports Web3 apps, asset storage, and account management across over 150 Polkadot SDK-based and EVM networks. Features include NFT management, Ledger support, fiat on-ramp, and portfolio tracking.</p> <p> Reference</p> </li> <li> <p>Subwallet</p> <p>A non-custodial web browser extension and mobile wallet for Polkadot and Ethereum. Track, send, receive, and monitor multi-chain assets on 150+ networks. Import account with seed phrase, private key, QR code, and JSON file. Import token &amp; NFT, attach read-only account. XCM Transfer, NFT Management, Parity Signer &amp; Ledger support, light clients support, EVM dApp support, MetaMask compatibility, custom endpoints, fiat on-ramp, phishing detection, transaction history.</p> <p> Reference</p> </li> </ul>"},{"location":"develop/toolkit/integrations/wallets/#cold-wallets","title":"Cold Wallets","text":"<ul> <li> <p>Ledger</p> <p>A hardware wallet that securely stores cryptocurrency private keys offline, protecting them from online threats. Using a secure chip and the Ledger Live app allows safe transactions and asset management while keeping keys secure.</p> <p> Reference</p> </li> <li> <p>Polkadot Vault</p> <p>This cold storage solution lets you use a phone in airplane mode as an air-gapped wallet, turning any spare phone, tablet, or iOS/Android device into a hardware wallet.</p> <p> Reference</p> </li> </ul>"},{"location":"develop/toolkit/interoperability/","title":"Interoperability","text":"<p>Explore Polkadot's XCM tooling ecosystem, featuring the Asset Transfer API and other utilities for implementing cross-chain messaging and transfers.</p>"},{"location":"develop/toolkit/interoperability/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"develop/toolkit/interoperability/xcm-tools/","title":"XCM Tools","text":""},{"location":"develop/toolkit/interoperability/xcm-tools/#introduction","title":"Introduction","text":"<p>As described in the Interoperability section, XCM (Cross-Consensus Messaging) is a protocol used in the Polkadot and Kusama ecosystems to enable communication and interaction between chains. It facilitates cross-chain communication, allowing assets, data, and messages to flow seamlessly across the ecosystem.</p> <p>As XCM is central to enabling communication between blockchains, developers need robust tools to help interact with, build, and test XCM messages. Several XCM tools simplify working with the protocol by providing libraries, frameworks, and utilities that enhance the development process, ensuring that applications built within the Polkadot ecosystem can efficiently use cross-chain functionalities.</p>"},{"location":"develop/toolkit/interoperability/xcm-tools/#popular-xcm-tools","title":"Popular XCM Tools","text":""},{"location":"develop/toolkit/interoperability/xcm-tools/#moonsong-labs-xcm-tools","title":"Moonsong Labs XCM Tools","text":"<p>Moonsong Labs XCM Tools provides a collection of scripts for managing and testing XCM operations between Polkadot SDK-based runtimes. These tools allow performing tasks like asset registration, channel setup, and XCM initialization. Key features include:</p> <ul> <li>Asset registration - registers assets, setting units per second (up-front fees), and configuring error (revert) codes</li> <li>XCM initializer - initializes XCM, sets default XCM versions, and configures revert codes for XCM-related precompiles</li> <li>HRMP manipulator - manages HRMP channel actions, including opening, accepting, or closing channels</li> <li>XCM-Transactor-Info-Setter - configures transactor information, including extra weight and fee settings</li> <li>Decode XCM - decodes XCM messages on the relay chain or parachains to help interpret cross-chain communication</li> </ul> <p>To get started, clone the repository and install the required dependencies:</p> <pre><code>git clone https://github.com/Moonsong-Labs/xcm-tools &amp;&amp; \ncd xcm-tools &amp;&amp;\nyarn install\n</code></pre> <p>For a full overview of each script, visit the scripts directory or refer to the official documentation on GitHub.</p>"},{"location":"develop/toolkit/interoperability/xcm-tools/#paraspell","title":"ParaSpell","text":"<p>ParaSpell is a collection of open-source XCM tools designed to streamline cross-chain asset transfers and interactions within the Polkadot and Kusama ecosystems. It equips developers with an intuitive interface to manage and optimize XCM-based functionalities. Some key points included by ParaSpell are:</p> <ul> <li>XCM SDK - provides a unified layer to incorporate XCM into decentralized applications, simplifying complex cross-chain interactions</li> <li>XCM API - offers an efficient, package-free approach to integrating XCM functionality while offloading heavy computing tasks, minimizing costs and improving application performance</li> <li>XCM router - enables cross-chain asset swaps in a single command, allowing developers to send one asset type (such as DOT on Polkadot) and receive a different asset on another chain (like ASTR on Astar)</li> <li>XCM analyser - decodes and translates complex XCM multilocation data into readable information, supporting easier troubleshooting and debugging</li> <li>XCM visualizator - a tool designed to give developers a clear, interactive view of XCM activity across the Polkadot ecosystem, providing insights into cross-chain communication flow</li> </ul> <p>ParaSpell's tools make it simple for developers to build, test, and deploy cross-chain solutions without needing extensive knowledge of the XCM protocol. With features like message composition, decoding, and practical utility functions for parachain interactions, ParaSpell is especially useful for debugging and optimizing cross-chain communications.</p>"},{"location":"develop/toolkit/interoperability/xcm-tools/#astar-xcm-tools","title":"Astar XCM Tools","text":"<p>The Astar parachain offers a crate with a set of utilities for interacting with the XCM protocol. The xcm-tools crate provides a straightforward method for users to locate a sovereign account or calculate an XC20 asset ID. Some commands included by the xcm-tools crate allow users to perform the following tasks:</p> <ul> <li>Sovereign accounts - obtain the sovereign account address for any parachain, either on the Relay Chain or for sibling parachains, using a simple command</li> <li>XC20 EVM addresses - generate XC20-compatible EVM addresses for assets by entering the asset ID, making it easy to integrate assets across EVM-compatible environments</li> <li>Remote accounts - retrieve remote account addresses needed for multi-location compatibility, using flexible options to specify account types and parachain IDs</li> </ul> <p>To start using these tools, clone the Astar repository and compile the xcm-tools package:</p> <pre><code>git clone https://github.com/AstarNetwork/Astar &amp;&amp;\ncd Astar &amp;&amp;\ncargo build --release -p xcm-tools\n</code></pre> <p>After compiling, verify the setup with the following command:</p> <p><pre><code>./target/release/xcm-tools --help\n</code></pre> For more details on using Astar xcm-tools, consult the official documentation.</p>"},{"location":"develop/toolkit/interoperability/xcm-tools/#chopsticks","title":"Chopsticks","text":"<p>The Chopsticks library provides XCM functionality for testing XCM messages across networks, enabling you to fork multiple parachains along with a relay chain. For further details, see the Chopsticks documentation about XCM.</p>"},{"location":"develop/toolkit/interoperability/asset-transfer-api/","title":"Asset Transfer API","text":"<p>Asset Transfer API is a library that simplifies the transfer of assets for Substrate based chains. It provides methods for cross-chain and local transfers.</p>"},{"location":"develop/toolkit/interoperability/asset-transfer-api/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"develop/toolkit/interoperability/asset-transfer-api/overview/","title":"Asset Transfer API","text":""},{"location":"develop/toolkit/interoperability/asset-transfer-api/overview/#introduction","title":"Introduction","text":"<p>Asset Transfer API, a tool developed and maintained by Parity, is a specialized library designed to streamline asset transfers for Substrate-based blockchains. This API provides a simplified set of methods for users to:</p> <ul> <li>Execute asset transfers to other parachains or locally within the same chain</li> <li>Facilitate transactions involving system parachains like Asset Hub (Polkadot and Kusama)</li> </ul> <p>Using this API, developers can manage asset transfers more efficiently, reducing the complexity of cross-chain transactions and enabling smoother operations within the ecosystem.</p> <p>For additional support and information, please reach out through GitHub Issues.</p>"},{"location":"develop/toolkit/interoperability/asset-transfer-api/overview/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have the following installed:</p> <ul> <li>Node.js (recommended version 21 or greater)</li> <li>Package manager - npm should be installed with Node.js by default. Alternatively, you can use other package managers like Yarn</li> </ul>"},{"location":"develop/toolkit/interoperability/asset-transfer-api/overview/#install-asset-transfer-api","title":"Install Asset Transfer API","text":"<p>To use <code>asset-transfer-api</code>, you need a TypeScript project. If you don't have one, you can create a new one:</p> <ol> <li> <p>Create a new directory for your project:</p> <pre><code>mkdir my-asset-transfer-project \\\n&amp;&amp; cd my-asset-transfer-project\n</code></pre> </li> <li> <p>Initialize a new TypeScript project:</p> <pre><code>npm init -y \\\n&amp;&amp; npm install typescript ts-node @types/node --save-dev \\\n&amp;&amp; npx tsc --init\n</code></pre> </li> </ol> <p>Once you have a project set up, you can install the <code>asset-transfer-api</code> package:</p> <pre><code>npm install @substrate/asset-transfer-api@v0.3.1\n</code></pre> <p>Note</p> <p>This documentation covers version <code>v0.3.1</code> of Asset Transfer API.</p>"},{"location":"develop/toolkit/interoperability/asset-transfer-api/overview/#set-up-asset-transfer-api","title":"Set Up Asset Transfer API","text":"<p>To initialize the Asset Transfer API, you need three key components:</p> <ul> <li>A Polkadot.js API instance</li> <li>The <code>specName</code> of the chain</li> <li>The XCM version to use</li> </ul>"},{"location":"develop/toolkit/interoperability/asset-transfer-api/overview/#using-helper-function-from-library","title":"Using Helper Function from Library","text":"<p>Leverage the <code>constructApiPromise</code> helper function provided by the library for the simplest setup process. It not only constructs a Polkadot.js <code>ApiPromise</code> but also automatically retrieves the chain's <code>specName</code> and fetches a safe XCM version. By using this function, developers can significantly reduce boilerplate code and potential configuration errors, making the initial setup both quicker and more robust.</p> <pre><code>import {\n  AssetTransferApi,\n  constructApiPromise,\n} from '@substrate/asset-transfer-api';\n\nasync function main() {\n  const { api, specName, safeXcmVersion } = await constructApiPromise(\n    'INSERT_WEBSOCKET_URL',\n  );\n\n  const assetsApi = new AssetTransferApi(api, specName, safeXcmVersion);\n\n  // Your code using assetsApi goes here\n}\n\nmain();\n</code></pre> <p>Note</p> <p>The code example id enclosed in an async main function to provide the necessary asynchronous context. However, you can use the code directly if you're already working within an async environment. The key is to ensure you're in an async context when working with these asynchronous operations, regardless of your specific setup.</p>"},{"location":"develop/toolkit/interoperability/asset-transfer-api/overview/#asset-transfer-api-reference","title":"Asset Transfer API Reference","text":"<p>For detailed information on the Asset Transfer API, including available methods, data types, and functionalities, refer to the Asset Transfer API Reference section. This resource provides in-depth explanations and technical specifications to help you integrate and utilize the API effectively.</p>"},{"location":"develop/toolkit/interoperability/asset-transfer-api/overview/#examples","title":"Examples","text":""},{"location":"develop/toolkit/interoperability/asset-transfer-api/overview/#relay-to-system-parachain-transfer","title":"Relay to System Parachain Transfer","text":"<p>This example demonstrates how to initiate a cross-chain token transfer from a relay chain to a system parachain. Specifically, 1 WND will be transferred from a Westend (relay chain) account to a Westmint (system parachain) account.</p> <pre><code>import {\n  AssetTransferApi,\n  constructApiPromise,\n} from '@substrate/asset-transfer-api';\n\nasync function main() {\n  const { api, specName, safeXcmVersion } = await constructApiPromise(\n    'wss://westend-rpc.polkadot.io',\n  );\n  const assetApi = new AssetTransferApi(api, specName, safeXcmVersion);\n  let callInfo;\n  try {\n    callInfo = await assetApi.createTransferTransaction(\n      '1000',\n      '5EWNeodpcQ6iYibJ3jmWVe85nsok1EDG8Kk3aFg8ZzpfY1qX',\n      ['WND'],\n      ['1000000000000'],\n      {\n        format: 'call',\n        xcmVersion: safeXcmVersion,\n      },\n    );\n\n    console.log(`Call data:\\n${JSON.stringify(callInfo, null, 4)}`);\n  } catch (e) {\n    console.error(e);\n    throw Error(e as string);\n  }\n\n  const decoded = assetApi.decodeExtrinsic(callInfo.tx, 'call');\n  console.log(`\\nDecoded tx:\\n${JSON.stringify(JSON.parse(decoded), null, 4)}`);\n}\n\nmain()\n  .catch((err) =&gt; console.error(err))\n  .finally(() =&gt; process.exit());\n</code></pre> <p>After running the script, you'll see the following output in the terminal, which shows the call data for the cross-chain transfer and its decoded extrinsic details:</p> ts-node relayToSystem.ts Call data: {     \"origin\": \"westend\",     \"dest\": \"westmint\",     \"direction\": \"RelayToSystem\",     \"xcmVersion\": 3,     \"method\": \"transferAssets\",     \"format\": \"call\",     \"tx\": \"0x630b03000100a10f03000101006c0c32faf970eacb2d4d8e538ac0dab3642492561a1be6f241c645876c056c1d030400000000070010a5d4e80000000000\" } Decoded tx: {     \"args\": {         \"dest\": {             \"V3\": {                 \"parents\": \"0\",                 \"interior\": {                     \"X1\": {                         \"Parachain\": \"1,000\"                     }                 }             }         },         \"beneficiary\": {             \"V3\": {                 \"parents\": \"0\",                 \"interior\": {                     \"X1\": {                         \"AccountId32\": {                             \"network\": null,                             \"id\": \"0x6c0c32faf970eacb2d4d8e538ac0dab3642492561a1be6f241c645876c056c1d\"                         }                     }                 }             }         },         \"assets\": {             \"V3\": [                 {                     \"id\": {                         \"Concrete\": {                             \"parents\": \"0\",                             \"interior\": \"Here\"                         }                     },                     \"fun\": {                         \"Fungible\": \"1,000,000,000,000\"                     }                 }             ]         },         \"fee_asset_item\": \"0\",         \"weight_limit\": \"Unlimited\"     },     \"method\": \"transferAssets\",     \"section\": \"xcmPallet\" }"},{"location":"develop/toolkit/interoperability/asset-transfer-api/overview/#local-parachain-transfer","title":"Local Parachain Transfer","text":"<p>The following example demonstrates a local GLMR transfer within Moonbeam, using the <code>balances</code> pallet. It transfers 1 GLMR token from one account to another account, where both the sender and recipient accounts are located on the same parachain.</p> <pre><code>import {\n  AssetTransferApi,\n  constructApiPromise,\n} from '@substrate/asset-transfer-api';\n\nasync function main() {\n  const { api, specName, safeXcmVersion } = await constructApiPromise(\n    'wss://wss.api.moonbeam.network',\n  );\n  const assetApi = new AssetTransferApi(api, specName, safeXcmVersion);\n\n  let callInfo;\n  try {\n    callInfo = await assetApi.createTransferTransaction(\n      '2004',\n      '0xF977814e90dA44bFA03b6295A0616a897441aceC',\n      [],\n      ['1000000000000000000'],\n      {\n        format: 'call',\n        keepAlive: true,\n      },\n    );\n\n    console.log(`Call data:\\n${JSON.stringify(callInfo, null, 4)}`);\n  } catch (e) {\n    console.error(e);\n    throw Error(e as string);\n  }\n\n  const decoded = assetApi.decodeExtrinsic(callInfo.tx, 'call');\n  console.log(`\\nDecoded tx:\\n${JSON.stringify(JSON.parse(decoded), null, 4)}`);\n}\n\nmain()\n  .catch((err) =&gt; console.error(err))\n  .finally(() =&gt; process.exit());\n</code></pre> <p>Upon executing this script, the terminal will display the following output, illustrating the encoded extrinsic for the cross-chain message and its corresponding decoded format:</p> ts-node localParachainTx.ts Call data: {     \"origin\": \"moonbeam\",     \"dest\": \"moonbeam\",     \"direction\": \"local\",     \"xcmVersion\": null,     \"method\": \"balances::transferKeepAlive\",     \"format\": \"call\",     \"tx\": \"0x0a03f977814e90da44bfa03b6295a0616a897441acec821a0600\" } Decoded tx: {     \"args\": {         \"dest\": \"0xF977814e90dA44bFA03b6295A0616a897441aceC\",         \"value\": \"1,000,000,000,000,000,000\"     },     \"method\": \"transferKeepAlive\",     \"section\": \"balances\" }"},{"location":"develop/toolkit/interoperability/asset-transfer-api/overview/#parachain-to-parachain-transfer","title":"Parachain to Parachain Transfer","text":"<p>This example demonstrates creating a cross-chain asset transfer between two parachains. It shows how to send vMOVR and vBNC from a Moonriver account to a Bifrost Kusama account using the safe XCM version. It connects to Moonriver, initializes the API, and uses the <code>createTransferTransaction</code> method to prepare a transaction.</p> <pre><code>import {\n  AssetTransferApi,\n  constructApiPromise,\n} from '@substrate/asset-transfer-api';\n\nasync function main() {\n  const { api, specName, safeXcmVersion } = await constructApiPromise(\n    'wss://moonriver.public.blastapi.io',\n  );\n  const assetApi = new AssetTransferApi(api, specName, safeXcmVersion);\n  let callInfo;\n  try {\n    callInfo = await assetApi.createTransferTransaction(\n      '2001',\n      '0xc4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a063',\n      ['vMOVR', '72145018963825376852137222787619937732'],\n      ['1000000', '10000000000'],\n      {\n        format: 'call',\n        xcmVersion: safeXcmVersion,\n      },\n    );\n\n    console.log(`Call data:\\n${JSON.stringify(callInfo, null, 4)}`);\n  } catch (e) {\n    console.error(e);\n    throw Error(e as string);\n  }\n\n  const decoded = assetApi.decodeExtrinsic(callInfo.tx, 'call');\n  console.log(`\\nDecoded tx:\\n${JSON.stringify(JSON.parse(decoded), null, 4)}`);\n}\n\nmain()\n  .catch((err) =&gt; console.error(err))\n  .finally(() =&gt; process.exit());\n</code></pre> <p>After running this script, you'll see the following output in your terminal. This output presents the encoded extrinsic for the cross-chain message, along with its decoded format, providing a clear view of the transaction details.</p> ts-node paraToPara.ts Call data: {     \"origin\": \"moonriver\",     \"dest\": \"bifrost\",     \"direction\": \"ParaToPara\",     \"xcmVersion\": 2,     \"method\": \"transferMultiassets\",     \"format\": \"call\",     \"tx\": \"0x6a05010800010200451f06080101000700e40b540200010200451f0608010a0002093d000000000001010200451f0100c4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a06300\" } Decoded tx: {     \"args\": {         \"assets\": {             \"V2\": [                 {                     \"id\": {                         \"Concrete\": {                             \"parents\": \"1\",                             \"interior\": {                                 \"X2\": [                                     {                                         \"Parachain\": \"2,001\"                                     },                                     {                                         \"GeneralKey\": \"0x0101\"                                     }                                 ]                             }                         }                     },                     \"fun\": {                         \"Fungible\": \"10,000,000,000\"                     }                 },                 {                     \"id\": {                         \"Concrete\": {                             \"parents\": \"1\",                             \"interior\": {                                 \"X2\": [                                     {                                         \"Parachain\": \"2,001\"                                     },                                     {                                         \"GeneralKey\": \"0x010a\"                                     }                                 ]                             }                         }                     },                     \"fun\": {                         \"Fungible\": \"1,000,000\"                     }                 }             ]         },         \"fee_item\": \"0\",         \"dest\": {             \"V2\": {                 \"parents\": \"1\",                 \"interior\": {                     \"X2\": [                         {                             \"Parachain\": \"2,001\"                         },                         {                             \"AccountId32\": {                                 \"network\": \"Any\",                                 \"id\": \"0xc4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a063\"                             }                         }                     ]                 }             }         },         \"dest_weight_limit\": \"Unlimited\"     },     \"method\": \"transferMultiassets\",     \"section\": \"xTokens\" }"},{"location":"develop/toolkit/interoperability/asset-transfer-api/reference/","title":"Asset Transfer API Reference","text":"<ul> <li> <p> Install the Asset Transfer API</p> <p>Learn how to install <code>asset-transfer-api</code> into a new or existing project.</p> <p>  Get started</p> </li> <li> <p> Dive in with a tutorial</p> <p>Ready to start coding? Follow along with a step-by-step tutorial.</p> <p>  How to use the Asset Transfer API</p> </li> </ul> <p></p>"},{"location":"develop/toolkit/interoperability/asset-transfer-api/reference/#asset-transfer-api-class","title":"Asset Transfer API Class","text":"<p>Holds open an API connection to a specified chain within the <code>ApiPromise</code> to help construct transactions for assets and estimate fees.</p> <p>For a more in-depth explanation of the Asset Transfer API class structure, check the source code.</p>"},{"location":"develop/toolkit/interoperability/asset-transfer-api/reference/#methods","title":"Methods","text":""},{"location":"develop/toolkit/interoperability/asset-transfer-api/reference/#create-transfer-transaction","title":"Create Transfer Transaction","text":"<p>Generates an XCM transaction for transferring assets between chains. It simplifies the process by inferring what type of transaction is required given the inputs, ensuring that the assets are valid, and that the transaction details are correctly formatted.</p> <p>After obtaining the transaction, you must handle the signing and submission process separately.</p> <pre><code>public async createTransferTransaction&lt;T extends Format&gt;(\n  destChainId: string,\n  destAddr: string,\n  assetIds: string[],\n  amounts: string[],\n  opts: TransferArgsOpts&lt;T&gt; = {}\n): Promise&lt;TxResult&lt;T&gt;&gt;;\n</code></pre> Request parameters <p><code>destChainId</code> string required</p> <p>ID of the destination chain (<code>'0'</code> for relay chain, other values for parachains).</p> <p><code>destAddr</code> string required</p> <p>Address of the recipient account on the destination chain.</p> <p><code>assetIds</code> string[] required</p> <p>Array of asset IDs to be transferred.</p> <p>When asset IDs are provided, the API dynamically selects the appropriate pallet for the current chain to handle these specific assets. If the array is empty, the API defaults to using the <code>balances</code> pallet.</p> <p><code>amounts</code> string[] required</p> <p>Array of amounts corresponding to each asset in <code>assetIds</code>.</p> <p><code>opts</code> TransferArgsOpts&lt;T&gt;</p> <p>Options for customizing the claim assets transaction. These options allow you to specify the transaction format, fee payment details, weight limits, XCM versions, and more.</p> Show more <p><code>format</code> T extends Format </p> <p>Specifies the format for returning a transaction.</p> Type <code>Format</code> <pre><code>\n</code></pre> <p><code>paysWithFeeOrigin</code> string</p> <p>The Asset ID to pay fees on the current common good parachain. The defaults are as follows:</p> <ul> <li>Polkadot Asset Hub - <code>'DOT'</code></li> <li>Kusama Asset Hub - <code>'KSM'</code></li> </ul> <p><code>paysWithFeeDest</code> string</p> <p>Asset ID to pay fees on the destination parachain.</p> <p><code>weightLimit</code> { refTime?: string, proofSize?: string }</p> <p>Custom weight limit option. If not provided, it will default to unlimited.</p> <p><code>xcmVersion</code> number</p> <p>Sets the XCM version for message construction. If this is not present a supported version will be queried, and if there is no supported version a safe version will be queried.</p> <p><code>keepAlive</code> boolean</p> <p>Enables <code>transferKeepAlive</code> for local asset transfers. For creating local asset transfers, if <code>true</code> this will allow for a <code>transferKeepAlive</code> as opposed to a <code>transfer</code>.</p> <p><code>transferLiquidToken</code> boolean</p> <p>Declares if this will transfer liquidity tokens. Default is <code>false</code>.</p> <p><code>assetTransferType</code> string</p> <p>The XCM transfer type used to transfer assets. The <code>AssetTransferType</code> type defines the possible values for this parameter.</p> Type <code>AssetTransferType</code> <p><code>remoteReserveAssetTransferTypeLocation</code> string</p> <p>The remove reserve location for the XCM transfer. Should be provided when specifying an <code>assetTransferType</code> of <code>RemoteReserve</code>.</p> <p><code>feesTransferType</code> string</p> <p>XCM TransferType used to pay fees for XCM transfer. The <code>AssetTransferType</code> type defines the possible values for this parameter.</p> Type <code>AssetTransferType</code> <p><code>remoteReserveFeesTransferTypeLocation</code> string</p> <p>The remote reserve location for the XCM transfer fees. Should be provided when specifying a <code>feesTransferType</code> of <code>RemoteReserve</code>.</p> <p><code>customXcmOnDest</code> string</p> <p>A custom XCM message to be executed on the destination chain. Should be provided if a custom XCM message is needed after transferring assets. Defaults to:</p> <pre><code>Xcm(vec![DepositAsset { assets: Wild(AllCounted(assets.len())), beneficiary }])\n</code></pre> Response parameters <p>Promise&lt;TxResult&lt;T&gt;</p> <p>A promise containing the result of constructing the transaction.</p> Show more <p><code>dest</code> string</p> <p>The destination <code>specName</code> of the transaction.</p> <p><code>origin</code> string</p> <p>The origin <code>specName</code> of the transaction.</p> <p><code>format</code> Format | 'local'</p> <p>The format type the transaction is outputted in.</p> Type <code>Format</code> <pre><code>\n</code></pre> <p><code>xcmVersion</code> number | null</p> <p>The XCM version that was used to construct the transaction.</p> <p><code>direction</code> Direction | 'local'</p> <p>The direction of the cross-chain transfer.</p> Enum <code>Direction</code> values <p><code>Local</code></p> <p>Local transaction.</p> <p><code>SystemToPara</code></p> <p>System parachain to parachain.</p> <p><code>SystemToRelay</code></p> <p>System paracahin to system relay chain.</p> <p><code>SystemToSystem</code></p> <p>System parachain to System parachain chain.</p> <p><code>SystemToBridge</code></p> <p>System parachain to an external <code>GlobalConsensus</code> chain.</p> <p><code>ParaToPara</code></p> <p>Parachain to Parachain.</p> <p><code>ParaToRelay</code></p> <p>Parachain to Relay chain.</p> <p><code>ParaToSystem</code></p> <p>Parachain to System parachain.</p> <p><code>RelayToSystem</code></p> <p>Relay to System Parachain.</p> <p><code>RelayToPara</code></p> <p>Relay chain to Parachain.</p> <p><code>RelayToBridge</code></p> <p>Relay chain to an external <code>GlobalConsensus</code> chain.</p> <p><code>method</code> Methods</p> <p>The method used in the transaction.</p> Type <code>Methods</code> <pre><code>type Methods =\n  | LocalTransferTypes\n  | 'transferAssets'\n  | 'transferAssetsUsingTypeAndThen'\n  | 'limitedReserveTransferAssets'\n  | 'limitedTeleportAssets'\n  | 'transferMultiasset'\n  | 'transferMultiassets'\n  | 'transferMultiassetWithFee'\n  | 'claimAssets';\n</code></pre> Type <code>LocalTransferTypes</code> <pre><code>type LocalTransferTypes =\n  | 'assets::transfer'\n  | 'assets::transferKeepAlive'\n  | 'foreignAssets::transfer'\n  | 'foreignAssets::transferKeepAlive'\n  | 'balances::transfer'\n  | 'balances::transferKeepAlive'\n  | 'poolAssets::transfer'\n  | 'poolAssets::transferKeepAlive'\n  | 'tokens::transfer'\n  | 'tokens::transferKeepAlive';\n</code></pre> <p><code>tx</code> ConstructedFormat&lt;T&gt;</p> <p>The constructed transaction.</p> Type <code>ConstructedFormat&lt;T&gt;</code> Example <p>Request</p> <pre><code>import {\n  AssetTransferApi,\n  constructApiPromise,\n} from '@substrate/asset-transfer-api';\n\nasync function main() {\n  const { api, specName, safeXcmVersion } = await constructApiPromise(\n    'wss://wss.api.moonbeam.network',\n  );\n  const assetsApi = new AssetTransferApi(api, specName, safeXcmVersion);\n\n  let callInfo;\n  try {\n    callInfo = await assetsApi.createTransferTransaction(\n      '2004',\n      '0xF977814e90dA44bFA03b6295A0616a897441aceC',\n      [],\n      ['1000000000000000000'],\n      {\n        format: 'call',\n        keepAlive: true,\n      },\n    );\n\n    console.log(`Call data:\\n${JSON.stringify(callInfo, null, 4)}`);\n  } catch (e) {\n    console.error(e);\n    throw Error(e as string);\n  }\n}\n\nmain()\n  .catch((err) =&gt; console.error(err))\n  .finally(() =&gt; process.exit());\n</code></pre> <p>Response</p> <p> Call data: {     \"origin\": \"moonbeam\",     \"dest\": \"moonbeam\",     \"direction\": \"local\",     \"xcmVersion\": null,     \"method\": \"balances::transferKeepAlive\",     \"format\": \"call\",     \"tx\": \"0x0a03f977814e90da44bfa03b6295a0616a897441acec821a0600\" }"},{"location":"develop/toolkit/interoperability/asset-transfer-api/reference/#claim-assets","title":"Claim Assets","text":"<p>Creates a local XCM transaction to retrieve trapped assets. This function can be used to claim assets either locally on a system parachain, on the relay chain, or on any chain that supports the <code>claimAssets</code> runtime call.</p> <pre><code>public async claimAssets&lt;T extends Format&gt;(\n  assetIds: string[],\n  amounts: string[],\n  beneficiary: string,\n  opts: TransferArgsOpts&lt;T&gt;\n): Promise&lt;TxResult&lt;T&gt;&gt;;\n</code></pre> Request parameters <p><code>assetIds</code> string[] required</p> <p>Array of asset IDs to be claimed from the <code>AssetTrap</code>.</p> <p><code>amounts</code> string[] required</p> <p>Array of amounts corresponding to each asset in <code>assetIds</code>.</p> <p><code>beneficiary</code> string required</p> <p>Address of the account to receive the trapped assets.</p> <p><code>opts</code> TransferArgsOpts&lt;T&gt;</p> <p>Options for customizing the claim assets transaction. These options allow you to specify the transaction format, fee payment details, weight limits, XCM versions, and more.</p> Show more <p><code>format</code> T extends Format </p> <p>Specifies the format for returning a transaction.</p> Type <code>Format</code> <pre><code>\n</code></pre> <p><code>paysWithFeeOrigin</code> string</p> <p>The Asset ID to pay fees on the current common good parachain. The defaults are as follows:</p> <ul> <li>Polkadot Asset Hub - <code>'DOT'</code></li> <li>Kusama Asset Hub - <code>'KSM'</code></li> </ul> <p><code>paysWithFeeDest</code> string</p> <p>Asset ID to pay fees on the destination parachain.</p> <p><code>weightLimit</code> { refTime?: string, proofSize?: string }</p> <p>Custom weight limit option. If not provided, it will default to unlimited.</p> <p><code>xcmVersion</code> number</p> <p>Sets the XCM version for message construction. If this is not present a supported version will be queried, and if there is no supported version a safe version will be queried.</p> <p><code>keepAlive</code> boolean</p> <p>Enables <code>transferKeepAlive</code> for local asset transfers. For creating local asset transfers, if <code>true</code> this will allow for a <code>transferKeepAlive</code> as opposed to a <code>transfer</code>.</p> <p><code>transferLiquidToken</code> boolean</p> <p>Declares if this will transfer liquidity tokens. Default is <code>false</code>.</p> <p><code>assetTransferType</code> string</p> <p>The XCM transfer type used to transfer assets. The <code>AssetTransferType</code> type defines the possible values for this parameter.</p> Type <code>AssetTransferType</code> <p><code>remoteReserveAssetTransferTypeLocation</code> string</p> <p>The remove reserve location for the XCM transfer. Should be provided when specifying an <code>assetTransferType</code> of <code>RemoteReserve</code>.</p> <p><code>feesTransferType</code> string</p> <p>XCM TransferType used to pay fees for XCM transfer. The <code>AssetTransferType</code> type defines the possible values for this parameter.</p> Type <code>AssetTransferType</code> <p><code>remoteReserveFeesTransferTypeLocation</code> string</p> <p>The remote reserve location for the XCM transfer fees. Should be provided when specifying a <code>feesTransferType</code> of <code>RemoteReserve</code>.</p> <p><code>customXcmOnDest</code> string</p> <p>A custom XCM message to be executed on the destination chain. Should be provided if a custom XCM message is needed after transferring assets. Defaults to:</p> <pre><code>Xcm(vec![DepositAsset { assets: Wild(AllCounted(assets.len())), beneficiary }])\n</code></pre> Response parameters <p>Promise&lt;TxResult&lt;T&gt;&gt;</p> <p>A promise containing the result of constructing the transaction.</p> Show more <p><code>dest</code> string</p> <p>The destination <code>specName</code> of the transaction.</p> <p><code>origin</code> string</p> <p>The origin <code>specName</code> of the transaction.</p> <p><code>format</code> Format | 'local'</p> <p>The format type the transaction is outputted in.</p> Type <code>Format</code> <pre><code>\n</code></pre> <p><code>xcmVersion</code> number | null</p> <p>The XCM version that was used to construct the transaction.</p> <p><code>direction</code> Direction | 'local'</p> <p>The direction of the cross-chain transfer.</p> Enum <code>Direction</code> values <p><code>Local</code></p> <p>Local transaction.</p> <p><code>SystemToPara</code></p> <p>System parachain to parachain.</p> <p><code>SystemToRelay</code></p> <p>System paracahin to system relay chain.</p> <p><code>SystemToSystem</code></p> <p>System parachain to System parachain chain.</p> <p><code>SystemToBridge</code></p> <p>System parachain to an external <code>GlobalConsensus</code> chain.</p> <p><code>ParaToPara</code></p> <p>Parachain to Parachain.</p> <p><code>ParaToRelay</code></p> <p>Parachain to Relay chain.</p> <p><code>ParaToSystem</code></p> <p>Parachain to System parachain.</p> <p><code>RelayToSystem</code></p> <p>Relay to System Parachain.</p> <p><code>RelayToPara</code></p> <p>Relay chain to Parachain.</p> <p><code>RelayToBridge</code></p> <p>Relay chain to an external <code>GlobalConsensus</code> chain.</p> <p><code>method</code> Methods</p> <p>The method used in the transaction.</p> Type <code>Methods</code> <pre><code>type Methods =\n  | LocalTransferTypes\n  | 'transferAssets'\n  | 'transferAssetsUsingTypeAndThen'\n  | 'limitedReserveTransferAssets'\n  | 'limitedTeleportAssets'\n  | 'transferMultiasset'\n  | 'transferMultiassets'\n  | 'transferMultiassetWithFee'\n  | 'claimAssets';\n</code></pre> Type <code>LocalTransferTypes</code> <pre><code>type LocalTransferTypes =\n  | 'assets::transfer'\n  | 'assets::transferKeepAlive'\n  | 'foreignAssets::transfer'\n  | 'foreignAssets::transferKeepAlive'\n  | 'balances::transfer'\n  | 'balances::transferKeepAlive'\n  | 'poolAssets::transfer'\n  | 'poolAssets::transferKeepAlive'\n  | 'tokens::transfer'\n  | 'tokens::transferKeepAlive';\n</code></pre> <p><code>tx</code> ConstructedFormat&lt;T&gt;</p> <p>The constructed transaction.</p> Type <code>ConstructedFormat&lt;T&gt;</code> Example <p>Request</p> <pre><code>import {\n  AssetTransferApi,\n  constructApiPromise,\n} from '@substrate/asset-transfer-api';\n\nasync function main() {\n  const { api, specName, safeXcmVersion } = await constructApiPromise(\n    'wss://westend-rpc.polkadot.io',\n  );\n  const assetsApi = new AssetTransferApi(api, specName, safeXcmVersion);\n\n  let callInfo;\n  try {\n    callInfo = await assetsApi.claimAssets(\n      [\n        `{\"parents\":\"0\",\"interior\":{\"X2\":[{\"PalletInstance\":\"50\"},{\"GeneralIndex\":\"1984\"}]}}`,\n      ],\n      ['1000000000000'],\n      '0xf5d5714c084c112843aca74f8c498da06cc5a2d63153b825189baa51043b1f0b',\n      {\n        format: 'call',\n        xcmVersion: 2,\n      },\n    );\n\n    console.log(`Call data:\\n${JSON.stringify(callInfo, null, 4)}`);\n  } catch (e) {\n    console.error(e);\n    throw Error(e as string);\n  }\n}\n\nmain()\n  .catch((err) =&gt; console.error(err))\n  .finally(() =&gt; process.exit());\n</code></pre> <p>Response</p> <p> Call data: {     \"origin\": \"0\",     \"dest\": \"westend\",     \"direction\": \"local\",     \"xcmVersion\": 2,     \"method\": \"claimAssets\",     \"format\": \"call\",     \"tx\": \"0x630c0104000002043205011f00070010a5d4e80100010100f5d5714c084c112843aca74f8c498da06cc5a2d63153b825189baa51043b1f0b\" }"},{"location":"develop/toolkit/interoperability/asset-transfer-api/reference/#decode-extrinsic","title":"Decode Extrinsic","text":"<p>Decodes the hex of an extrinsic into a string readable format.</p> <pre><code>public decodeExtrinsic&lt;T extends Format&gt;(\n  encodedTransaction: string,\n  format: T\n): string;\n</code></pre> Request parameters <p><code>encodedTransaction</code> string required</p> <p>A hex encoded extrinsic.</p> <p><code>format</code> T extends Format required</p> <p>Specifies the format for returning a transaction.</p> Type <code>Format</code> <pre><code>export type Format = 'payload' | 'call' | 'submittable';\n</code></pre> Response parameters <p>string</p> <p>Decoded extrinsic in string readable format.</p> Example <p>Request</p> <pre><code>import {\n  AssetTransferApi,\n  constructApiPromise,\n} from '@substrate/asset-transfer-api';\n\nasync function main() {\n  const { api, specName, safeXcmVersion } = await constructApiPromise(\n    'wss://wss.api.moonbeam.network',\n  );\n  const assetsApi = new AssetTransferApi(api, specName, safeXcmVersion);\n\n  const encodedExt = '0x0a03f977814e90da44bfa03b6295a0616a897441acec821a0600';\n\n  try {\n    const decodedExt = assetsApi.decodeExtrinsic(encodedExt, 'call');\n    console.log(\n      `Decoded tx:\\n ${JSON.stringify(JSON.parse(decodedExt), null, 4)}`,\n    );\n  } catch (e) {\n    console.error(e);\n    throw Error(e as string);\n  }\n}\n\nmain()\n  .catch((err) =&gt; console.error(err))\n  .finally(() =&gt; process.exit());\n</code></pre> <p>Response</p> <p> Decoded tx:  {     \"args\": {         \"dest\": \"0xF977814e90dA44bFA03b6295A0616a897441aceC\",         \"value\": \"100,000\"     },     \"method\": \"transferKeepAlive\",     \"section\": \"balances\" } </p>"},{"location":"develop/toolkit/interoperability/asset-transfer-api/reference/#fetch-fee-info","title":"Fetch Fee Info","text":"<p>Fetch estimated fee information for an extrinsic.</p> <pre><code>public async fetchFeeInfo&lt;T extends Format&gt;(\n  tx: ConstructedFormat&lt;T&gt;,\n  format: T\n): Promise&lt;RuntimeDispatchInfo | RuntimeDispatchInfoV1 | null&gt;;\n</code></pre> Request parameters <p><code>tx</code> ConstructedFormat&lt;T&gt; required</p> <p>The constructed transaction.</p> Type <code>ConstructedFormat&lt;T&gt;</code> <pre><code>export type ConstructedFormat&lt;T&gt; = T extends 'payload'\n  ? GenericExtrinsicPayload\n  : T extends 'call'\n  ? `0x${string}`\n  : T extends 'submittable'\n  ? SubmittableExtrinsic&lt;'promise', ISubmittableResult&gt;\n  : never;\n</code></pre> <p>The <code>ConstructedFormat</code> type is a conditional type that returns a specific type based on the value of the TxResult <code>format</code> field.</p> <ul> <li>Payload format - if the format field is set to <code>'payload'</code>, the <code>ConstructedFormat</code> type will return a <code>GenericExtrinsicPayload</code></li> <li>Call format - if the format field is set to <code>'call'</code>, the <code>ConstructedFormat</code> type will return a hexadecimal string (<code>0x${string}</code>). This is the encoded representation of the extrinsic call</li> <li>Submittable format - if the format field is set to <code>'submittable'</code>, the <code>ConstructedFormat</code> type will return a <code>SubmittableExtrinsic</code>. This is a Polkadot.js type that represents a transaction that can be submitted to the blockchain</li> </ul> <p><code>format</code> T extends Format required</p> <p>Specifies the format for returning a transaction.</p> Type <code>Format</code> <pre><code>export type Format = 'payload' | 'call' | 'submittable';\n</code></pre> Response parameters <p>Promise&lt;RuntimeDispatchInfo | RuntimeDispatchInfoV1 | null&gt;</p> <p>A promise containing the estimated fee information for the provided extrinsic.</p> Type <code>RuntimeDispatchInfo</code> <pre><code>export interface RuntimeDispatchInfo extends Struct {\n  readonly weight: Weight;\n  readonly class: DispatchClass;\n  readonly partialFee: Balance;\n}\n</code></pre> <p>For more information on the underlying types and fields of <code>RuntimeDispatchInfo</code>, check the RuntimeDispatchInfo source code.</p> Type <code>RuntimeDispatchInfoV1</code> <pre><code>export interface RuntimeDispatchInfoV1 extends Struct {\n  readonly weight: WeightV1;\n  readonly class: DispatchClass;\n  readonly partialFee: Balance;\n}\n</code></pre> <p>For more information on the underlying types and fields of <code>RuntimeDispatchInfoV1</code>, check the RuntimeDispatchInfoV1 source code.</p> Example <p>Request</p> <pre><code>import {\n  AssetTransferApi,\n  constructApiPromise,\n} from '@substrate/asset-transfer-api';\n\nasync function main() {\n  const { api, specName, safeXcmVersion } = await constructApiPromise(\n    'wss://wss.api.moonbeam.network',\n  );\n  const assetsApi = new AssetTransferApi(api, specName, safeXcmVersion);\n\n  const encodedExt = '0x0a03f977814e90da44bfa03b6295a0616a897441acec821a0600';\n\n  try {\n    const decodedExt = await assetsApi.fetchFeeInfo(encodedExt, 'call');\n    console.log(`Fee info:\\n${JSON.stringify(decodedExt, null, 4)}`);\n  } catch (e) {\n    console.error(e);\n    throw Error(e as string);\n  }\n}\n\nmain()\n  .catch((err) =&gt; console.error(err))\n  .finally(() =&gt; process.exit());\n</code></pre> <p>Response</p> <p> Fee info: {     \"weight\": {         \"refTime\": 163777000,         \"proofSize\": 3581     },     \"class\": \"Normal\",     \"partialFee\": 0 } </p>"},{"location":"develop/toolkit/parachains/","title":"Blockchain Tools","text":"<p>Discover essential parachain development resources for building in the Polkadot ecosystem, highlighting tools to streamline your development process.</p>"},{"location":"develop/toolkit/parachains/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"develop/toolkit/parachains/fork-chains/","title":"Fork Chains for Testing","text":"<p>Explore tools for forking live blockchain networks, enabling you to replicate real-world conditions in a local environment for accurate testing and debugging.</p>"},{"location":"develop/toolkit/parachains/fork-chains/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"develop/toolkit/parachains/fork-chains/chopsticks/","title":"Chopsticks","text":"<p>Learn how to install, configure, and use Chopsticks for debugging and forking Polkadot SDK-based networks in a local development environment.</p>"},{"location":"develop/toolkit/parachains/fork-chains/chopsticks/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"develop/toolkit/parachains/fork-chains/chopsticks/get-started/","title":"Get Started","text":""},{"location":"develop/toolkit/parachains/fork-chains/chopsticks/get-started/#introduction","title":"Introduction","text":"<p>Chopsticks, developed by the Acala Foundation, is a versatile tool tailored for developers working on Polkadot SDK-based blockchains. With Chopsticks, you can fork live chains locally, replay blocks to analyze extrinsics, and simulate complex scenarios like XCM interactions all without deploying to a live network.</p> <p>This guide walks you through installing Chopsticks and provides information on configuring a local blockchain fork. By streamlining testing and experimentation, Chopsticks empowers developers to innovate and accelerate their blockchain projects within the Polkadot ecosystem.</p> <p>For additional support and information, please reach out through GitHub Issues.</p> <p>Note</p> <p>Chopsticks uses Smoldot light client, which only supports the native Polkadot SDK API. Consequently, a Chopsticks-based fork doesn't support Ethereum JSON-RPC calls, meaning you cannot use it to fork your chain and connect Metamask.</p>"},{"location":"develop/toolkit/parachains/fork-chains/chopsticks/get-started/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have the following installed:</p> <ul> <li>Node.js</li> <li>A package manager such as npm, which should be installed with Node.js by default, or Yarn</li> </ul>"},{"location":"develop/toolkit/parachains/fork-chains/chopsticks/get-started/#install-chopsticks","title":"Install Chopsticks","text":"<p>You can install Chopsticks globally or locally in your project. Choose the option that best fits your development workflow.</p> <p>Note</p> <p>This documentation explains the features of Chopsticks version <code>0.13.1</code>. Make sure you're using the correct version to match these instructions.</p>"},{"location":"develop/toolkit/parachains/fork-chains/chopsticks/get-started/#global-installation","title":"Global Installation","text":"<p>To install Chopsticks globally, allowing you to use it across multiple projects, run:</p> <pre><code>npm i -g @acala-network/chopsticks@0.13.1\n</code></pre> <p>Now, you should be able to run the <code>chopsticks</code> command from your terminal.</p>"},{"location":"develop/toolkit/parachains/fork-chains/chopsticks/get-started/#local-installation","title":"Local Installation","text":"<p>To use Chopsticks in a specific project, first create a new directory and initialize a Node.js project:</p> <pre><code>mkdir my-chopsticks-project\ncd my-chopsticks-project\nnpm init -y\n</code></pre> <p>Then, install Chopsticks as a local dependency:</p> <pre><code>npm i @acala-network/chopsticks@0.13.1\n</code></pre> <p>Finally, you can run Chopsticks using the <code>npx</code> command:</p> <pre><code>npx @acala-network/chopsticks\n</code></pre>"},{"location":"develop/toolkit/parachains/fork-chains/chopsticks/get-started/#configure-chopsticks","title":"Configure Chopsticks","text":"<p>To run Chopsticks, you need to configure some parameters. This can be set either through using a configuration file or the command line interface (CLI). The parameters that can be configured are as follows:</p> <ul> <li><code>genesis</code> - the link to a parachain's raw genesis file to build the fork from, instead of an endpoint</li> <li><code>timestamp</code> - timestamp of the block to fork from</li> <li><code>endpoint</code> - the endpoint of the parachain to fork</li> <li><code>block</code> - use to specify at which block hash or number to replay the fork</li> <li><code>wasm-override</code> - path of the Wasm to use as the parachain runtime, instead of an endpoint's runtime</li> <li><code>db</code> - path to the name of the file that stores or will store the parachain's database</li> <li><code>config</code> - path or URL of the config file</li> <li><code>port</code> - the port to expose an endpoint on</li> <li><code>build-block-mode</code> - how blocks should be built in the fork: batch, manual, instant</li> <li><code>import-storage</code> - a pre-defined JSON/YAML storage path to override in the parachain's storage</li> <li><code>allow-unresolved-imports</code> - whether to allow Wasm unresolved imports when using a Wasm to build the parachain</li> <li><code>html</code> - include to generate storage diff preview between blocks</li> <li><code>mock-signature-host</code> - mock signature host so that any signature starts with <code>0xdeadbeef</code> and filled by <code>0xcd</code> is considered valid</li> </ul>"},{"location":"develop/toolkit/parachains/fork-chains/chopsticks/get-started/#configuration-file","title":"Configuration File","text":"<p>The Chopsticks source repository includes a collection of YAML files that can be used to set up various Polkadot SDK chains locally. You can download these configuration files from the repository's <code>configs</code> folder.</p> <p>An example of a configuration file for Polkadot is as follows:</p> <pre><code>endpoint:\n  - wss://rpc.ibp.network/polkadot\n  - wss://polkadot-rpc.dwellir.com\nmock-signature-host: true\nblock: ${env.POLKADOT_BLOCK_NUMBER}\ndb: ./db.sqlite\nruntime-log-level: 5\n\nimport-storage:\n  System:\n    Account:\n      - - - 5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY\n        - providers: 1\n          data:\n            free: '10000000000000000000'\n  ParasDisputes:\n    $removePrefix: ['disputes'] # those can makes block building super slow\n</code></pre> <p>The configuration file allows you to modify the storage of the forked network by rewriting the pallet, state component and value that you want to change. For example, Polkadot's file rewrites Alice's <code>system.Account</code> storage so that the free balance is set to <code>10000000000000000000</code>.</p>"},{"location":"develop/toolkit/parachains/fork-chains/chopsticks/get-started/#cli-flags","title":"CLI Flags","text":"<p>Alternatively, all settings (except for genesis and timestamp) can be configured via command-line flags, providing a comprehensive method to set up the environment. </p>"},{"location":"develop/toolkit/parachains/fork-chains/chopsticks/get-started/#where-to-go-next","title":"Where to Go Next","text":"<ul> <li>Visit the Fork a Chain with Chopsticks guide for step-by-step instructions for configuring and interacting with your forked chain.</li> </ul>"},{"location":"develop/toolkit/parachains/spawn-chains/","title":"Spawn Networks for Testing","text":"<p>Discover tools that enable you to spawn blockchains for testing, allowing for debugging, and validation of your blockchain setups in a controlled environment.</p>"},{"location":"develop/toolkit/parachains/spawn-chains/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"develop/toolkit/parachains/spawn-chains/zombienet/","title":"Zombienet","text":"<p>Learn how to install, configure, and use Zombienet for testing and simulating Polkadot SDK-based networks in a local development environment.</p>"},{"location":"develop/toolkit/parachains/spawn-chains/zombienet/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"develop/toolkit/parachains/spawn-chains/zombienet/get-started/","title":"Get Started","text":""},{"location":"develop/toolkit/parachains/spawn-chains/zombienet/get-started/#introduction","title":"Introduction","text":"<p>Zombienet is a robust testing framework designed for Polkadot SDK-based blockchain networks. It enables developers to efficiently deploy and test ephemeral blockchain environments on platforms like Kubernetes, Podman, and native setups. With its simple and versatile CLI, Zombienet provides an all-in-one solution for spawning networks, running tests, and validating performance.</p> <p>This guide will outline the different installation methods for Zombienet, provide step-by-step instructions for setting up on various platforms, and highlight essential provider-specific features and requirements.</p> <p>By following this guide, Zombienet will be up and running quickly, ready to streamline your blockchain testing and development workflows.</p> <p>Additional support resources</p> <p>Parity Technologies has designed and developed this framework, now maintained by the Zombienet team. </p> <p>For further support and information, refer to the following contact points:</p> <ul> <li>Zombienet repository</li> <li>Element public channel</li> </ul>"},{"location":"develop/toolkit/parachains/spawn-chains/zombienet/get-started/#install-zombienet","title":"Install Zombienet","text":"<p>Zombienet releases are available on the Zombienet repository.</p> <p>Multiple options are available for installing Zombienet, depending on the user's preferences and the environment where it will be used. The following section will guide you through the installation process for each option.</p> Use the executableUse NixUse Docker <p>Install Zombienet using executables by visiting the latest release page and selecting the appropriate asset for your operating system. You can download the executable and move it to a directory in your PATH. </p> <p>Note</p> <p>Each release includes executables for Linux and macOS. Executables are generated using pkg, which allows the Zombienet CLI to operate without requiring Node.js to be installed. </p> <p>Then, ensure the downloaded file is executable:</p> <pre><code>chmod +x zombienet-macos-arm64\n</code></pre> <p>Finally, you can run the following command to check if the installation was successful. If so, it will display the version of the installed Zombienet:</p> <pre><code>./zombienet-macos-arm64 version\n</code></pre> <p>If you want to add the <code>zombienet</code> executable to your PATH, you can move it to a directory in your PATH, such as <code>/usr/local/bin</code>:</p> <pre><code>mv zombienet-macos-arm64 /usr/local/bin/zombienet\n</code></pre> <p>Now you can refer to the <code>zombienet</code> executable directly.</p> <pre><code>zombienet version\n</code></pre> <p>For Nix users, the Zombienet repository provides a <code>flake.nix</code> file to install Zombienet making it easy to incorporate Zombienet into Nix-based projects.</p> <p>To install Zombienet utilizing Nix, users can run the following command, triggering the fetching of the flake and subsequently installing the Zombienet package:</p> <pre><code>nix run github:paritytech/zombienet/INSERT_ZOMBIENET_VERSION -- \\\nspawn INSERT_ZOMBIENET_CONFIG_FILE_NAME.toml\n</code></pre> <p>Note</p> <ul> <li>Replace the <code>INSERT_ZOMBIENET_VERSION</code> with the desired version of Zombienet</li> <li>Replace the <code>INSERT_ZOMBIENET_CONFIG_FILE_NAME</code> with the name of the configuration file you want to use</li> </ul> <p>To run the command above, you need to have Flakes enabled.</p> <p>Alternatively, you can also include the Zombienet binary in the PATH for the current shell using the following command:</p> <pre><code>nix shell github:paritytech/zombienet/INSERT_ZOMBIENET_VERSION\n</code></pre> <p>Zombienet can also be run using Docker. The Zombienet repository provides a Docker image that can be used to run the Zombienet CLI. To run Zombienet using Docker, you can use the following command:</p> <pre><code>docker run -it --rm \\\n-v $(pwd):/home/nonroot/zombie-net/host-current-files \\\nparitytech/zombienet\n</code></pre> <p>The command above will run the Zombienet CLI inside a Docker container and mount the current directory to the <code>/home/nonroot/zombie-net/host-current-files</code> directory. This allows Zombienet to access the configuration file and other files in the current directory. If you want to mount a different directory, replace <code>$(pwd)</code> with the desired directory path.</p> <p>Inside the Docker container, you can run the Zombienet CLI commands. First, you need to set up Zombienet to download the necessary binaries:</p> <pre><code>npm run zombie -- setup polkadot polkadot-parachain\n</code></pre> <p>After that, you need to add those binaries to the PATH:</p> <pre><code>export PATH=/home/nonroot/zombie-net:$PATH\n</code></pre> <p>Finally, you can run the Zombienet CLI commands. For example, to spawn a network using a specific configuration file, you can run the following command:</p> <pre><code>pm run zombie -- -p native spawn host-current-files/minimal.toml\n</code></pre> <p>The command above mounts the current directory to the <code>/workspace</code> directory inside the Docker container, allowing Zombienet to access the configuration file and other files in the current directory. If you want to mount a different directory, replace <code>$(pwd)</code> with the desired directory path.</p>"},{"location":"develop/toolkit/parachains/spawn-chains/zombienet/get-started/#providers","title":"Providers","text":"<p>Zombienet supports different backend providers for running the nodes. At this moment, Kubernetes, Podman, and local providers are supported, which can be declared as <code>kubernetes</code>, <code>podman</code>, or <code>native</code>, respectively.</p> <p>To use a particular provider, you can specify it in the network file or use the <code>--provider</code> flag in the CLI:</p> <pre><code>zombienet spawn network.toml --provider INSERT_PROVIDER\n</code></pre> <p>Alternatively, you can set the provider in the network file:</p> <pre><code>[settings]\nprovider = \"INSERT_PROVIDER\"\n...\n</code></pre> <p>It's important to note that each provider has specific requirements and associated features. The following sections cover each provider's requirements and added features.</p>"},{"location":"develop/toolkit/parachains/spawn-chains/zombienet/get-started/#kubernetes","title":"Kubernetes","text":"<p>Kubernetes is a portable, extensible, open-source platform for managing containerized workloads and services. Zombienet is designed to be compatible with a variety of Kubernetes clusters, including: </p> <ul> <li>Google Kubernetes Engine (GKE)</li> <li>Docker Desktop</li> <li>kind</li> </ul>"},{"location":"develop/toolkit/parachains/spawn-chains/zombienet/get-started/#requirements","title":"Requirements","text":"<p>To effectively interact with your cluster, you'll need to ensure that <code>kubectl</code> is installed on your system. This Kubernetes command-line tool allows you to run commands against Kubernetes clusters. If you don't have <code>kubectl</code> installed, you can follow the instructions provided in the Kubernetes documentation.</p> <p>To create resources such as namespaces, pods, and CronJobs within the target cluster, you must grant your user or service account the appropriate permissions. These permissions are essential for managing and deploying applications effectively within Kubernetes.</p>"},{"location":"develop/toolkit/parachains/spawn-chains/zombienet/get-started/#features","title":"Features","text":"<p>If available, Zombienet uses the Prometheus operator to oversee monitoring and visibility. This configuration ensures that only essential networking-related pods are deployed. Using the Prometheus operator, Zombienet improves its ability to monitor and manage network activities within the Kubernetes cluster efficiently.  </p>"},{"location":"develop/toolkit/parachains/spawn-chains/zombienet/get-started/#podman","title":"Podman","text":"<p>Podman is a daemonless container engine for developing, managing, and running Open Container Initiative (OCI) containers and container images on Linux-based systems. Zombienet supports Podman rootless as a provider on Linux machines. Although Podman has support for macOS through an internal virtual machine (VM), the Zombienet provider code requires Podman to run natively on Linux.</p>"},{"location":"develop/toolkit/parachains/spawn-chains/zombienet/get-started/#requirements_1","title":"Requirements","text":"<p>To use Podman as a provider, you need to have Podman installed on your system. You can install Podman by following the instructions provided on the Podman website.</p>"},{"location":"develop/toolkit/parachains/spawn-chains/zombienet/get-started/#features_1","title":"Features","text":"<p>Using Podman, Zombienet deploys additional pods to enhance the monitoring and visibility of the active network. Specifically, pods for Prometheus, Tempo, and Grafana are included in the deployment. Grafana is configured with Prometheus and Tempo as data sources.</p> <p>Upon launching Zombienet, access to these monitoring services is facilitated through specific URLs provided in the output:</p> <ul> <li>Prometheus - http://127.0.0.1:34123</li> <li>Tempo - http://127.0.0.1:34125</li> <li>Grafana - http://127.0.0.1:41461</li> </ul> <p>It's important to note that Grafana is deployed with default administrator access. </p> <p>When network operations cease, either from halting a running spawn with the <code>Ctrl+C</code> command or test completion, Zombienet automatically removes all associated pods.</p>"},{"location":"develop/toolkit/parachains/spawn-chains/zombienet/get-started/#local-provider","title":"Local Provider","text":"<p>The Zombienet local provider, also called native, enables you to run nodes as local processes in your environment.</p>"},{"location":"develop/toolkit/parachains/spawn-chains/zombienet/get-started/#requirements_2","title":"Requirements","text":"<p>You must have the necessary binaries for your network (such as <code>polkadot</code> and <code>polkadot-parachain</code>). These binaries should be available in your PATH, allowing Zombienet to spawn the nodes as local processes.</p> <p>To install the necessary binaries, you can use the Zombienet CLI command:</p> <pre><code>zombienet setup polkadot polkadot-parachain\n</code></pre> <p>This command will download and prepare the necessary binaries for Zombienet's use.</p> <p>Warning</p> <p>The <code>polkadot</code> and <code>polkadot-parachain</code> binaries releases aren't compatible with macOS. As a result, macOS users will need to clone the Polkadot repository, build the Polkadot binary, and manually add it to their PATH for <code>polkadot</code> and <code>polkadot-parachain</code> to work.</p> <p>If you need to use a custom binary, ensure the binary is available in your PATH. You can also specify the binary path in the network configuration file. The following example uses the custom OpenZeppelin template:</p> <p>First, clone the OpenZeppelin template repository using the following command:</p> <pre><code>git clone https://github.com/OpenZeppelin/polkadot-runtime-templates \\\n&amp;&amp; cd polkadot-runtime-templates/generic-template\n</code></pre> <p>Next, run the command to build the custom binary:</p> <pre><code>cargo build --release\n</code></pre> <p>Finally, add the custom binary to your PATH as follows:</p> <pre><code>export PATH=$PATH:INSERT_PATH_TO_RUNTIME_TEMPLATES/parachain-template-node/target/release\n</code></pre> <p>Alternatively, you can specify the binary path in the network configuration file.</p> <pre><code>[relaychain]\nchain = \"rococo-local\"\ndefault_command = \"./bin-v1.6.0/polkadot\"\n\n[parachain]\nid = 1000\n\n    [parachain.collators]\n    name = \"collator01\"\n    command = \"./target/release/parachain-template-node\"\n</code></pre>"},{"location":"develop/toolkit/parachains/spawn-chains/zombienet/get-started/#features_2","title":"Features","text":"<p>The local provider does not offer any additional features.</p> <p>Note</p> <p>The local provider exclusively utilizes the command configuration for nodes, which supports both relative and absolute paths. You can employ the <code>default_command</code> configuration to specify the binary for spawning all nodes in the relay chain.</p>"},{"location":"develop/toolkit/parachains/spawn-chains/zombienet/get-started/#configure-zombienet","title":"Configure Zombienet","text":"<p>Effective network configuration is crucial for deploying and managing blockchain systems. Zombienet simplifies this process by offering versatile configuration options in both JSON and TOML formats. Whether setting up a simple test network or a complex multi-node system, Zombienet's tools provide the flexibility to customize every aspect of your network's setup.</p> <p>The following sections will explore the structure and usage of Zombienet configuration files, explain key settings for network customization, and walk through CLI commands and flags to optimize your development workflow.</p>"},{"location":"develop/toolkit/parachains/spawn-chains/zombienet/get-started/#configuration-files","title":"Configuration Files","text":"<p>The network configuration file can be either JSON or TOML format. The Zombienet repository also provides a collection of example configuration files that can be used as a reference.</p> <p>Note</p> <p>Each section may include provider-specific keys that aren't recognized by other providers. For example, if you use the local provider, any references to images for nodes will be disregarded.</p>"},{"location":"develop/toolkit/parachains/spawn-chains/zombienet/get-started/#cli-usage","title":"CLI Usage","text":"<p>Zombienet provides a CLI that allows interaction with the tool. The CLI can receive commands and flags to perform different kinds of operations. These operations use the following syntax:</p> <pre><code>zombienet &lt;arguments&gt; &lt;commands&gt;\n</code></pre> <p>The following sections will guide you through the primary usage of the Zombienet CLI and the available commands and flags.</p>"},{"location":"develop/toolkit/parachains/spawn-chains/zombienet/get-started/#cli-commands","title":"CLI Commands","text":"<ul> <li> <p><code>spawn &lt;networkConfig&gt;</code> - spawn the network defined in the configuration file</p> <p>Warning</p> <p>The Polkadot binary is currently not compatible with macOS. For the <code>spawn</code> command to work on macOS, users will need to clone the Polkadot repository, build the Polkadot binary, and manually add it to their PATH.</p> </li> <li> <p><code>test &lt;testFile&gt;</code> - run tests on the spawned network using the assertions and tests defined in the test file</p> </li> <li> <p><code>setup &lt;binaries&gt;</code> - set up the Zombienet development environment to download and use the <code>polkadot</code> or <code>polkadot-parachain</code> executable</p> </li> <li> <p><code>convert &lt;filePath&gt;</code> - transforms a polkadot-launch configuration file with a <code>.js</code> or <code>.json</code> extension into a Zombienet configuration file</p> </li> <li> <p><code>version</code> - prints Zombienet version</p> </li> <li> <p><code>help</code> - prints help information</p> </li> </ul>"},{"location":"develop/toolkit/parachains/spawn-chains/zombienet/get-started/#cli-flags","title":"CLI Flags","text":"<p>You can use the following flags to customize the behavior of the CLI:</p> <ul> <li> <p><code>-p</code>, <code>--provider</code> - override the provider to use</p> </li> <li> <p><code>-d</code>, <code>--dir</code> - specify a directory path for placing the network files instead of using the default temporary path</p> </li> <li> <p><code>-f</code>, <code>--force</code> - force override all prompt commands</p> </li> <li> <p><code>-l</code>, <code>--logType</code> - type of logging on the console. Defaults to <code>table</code></p> </li> <li> <p><code>-m</code>, <code>--monitor</code> - start as monitor and don't auto clean up network</p> </li> <li> <p><code>-c</code>, <code>--spawn-concurrency</code> - number of concurrent spawning processes to launch. Defaults to <code>1</code></p> </li> <li> <p><code>-h</code>, <code>--help</code> - display help for command</p> </li> </ul>"},{"location":"develop/toolkit/parachains/spawn-chains/zombienet/get-started/#settings","title":"Settings","text":"<p>Through the keyword <code>settings</code>, it's possible to define the general settings for the network. The available keys are:</p> <ul> <li> <p><code>global_volumes?</code> GlobalVolume[] - a list of global volumes to use </p> <code>GlobalVolume</code> interface definition <pre><code>export interface GlobalVolume {\n  name: string;\n  fs_type: string;\n  mount_path: string;\n}\n</code></pre> </li> <li> <p><code>bootnode</code> boolean - add bootnode to network. Defaults to <code>true</code></p> </li> <li><code>bootnode_domain?</code> string - domain to use for bootnode</li> <li><code>timeout</code> number - global timeout to use for spawning the whole network</li> <li><code>node_spawn_timeout?</code> number - timeout to spawn pod/process</li> <li><code>grafana?</code> boolean - deploy an instance of Grafana</li> <li><code>prometheus?</code> boolean - deploy an instance of Prometheus</li> <li><code>telemetry?</code> boolean - enable telemetry for the network</li> <li><code>jaeger_agent?</code> string - the Jaeger agent endpoint passed to the nodes. Only available on Kubernetes</li> <li><code>tracing_collator_url?</code> string - the URL of the tracing collator used to query by the tracing assertion. Should be tempo query compatible</li> <li><code>tracing_collator_service_name?</code> string - service name for tempo query frontend. Only available on Kubernetes. Defaults to <code>tempo-tempo-distributed-query-frontend</code></li> <li><code>tracing_collator_service_namespace?</code> string - namespace where tempo is running. Only available on Kubernetes. Defaults to <code>tempo</code></li> <li><code>tracing_collator_service_port?</code> number - port of the query instance of tempo. Only available on Kubernetes. Defaults to <code>3100</code></li> <li><code>enable_tracing?</code> boolean - enable the tracing system. Only available on Kubernetes. Defaults to <code>true</code></li> <li><code>provider</code> string - provider to use. Default is <code>kubernetes</code>\"</li> <li><code>polkadot_introspector?</code> boolean - deploy an instance of polkadot-introspector. Only available on Podman and Kubernetes. Defaults to <code>false</code></li> <li><code>backchannel?</code> boolean - deploy an instance of backchannel server. Only available on Kubernetes. Defaults to <code>false</code></li> <li><code>image_pull_policy?</code> string - image pull policy to use in the network. Possible values are <code>Always</code>, <code>IfNotPresent</code>, and <code>Never</code></li> <li><code>local_ip?</code> string - IP used for exposing local services (rpc/metrics/monitors). Defaults to <code>\"127.0.0.1\"</code></li> <li><code>global_delay_network_global_settings?</code> number - delay in seconds to apply to the network</li> <li><code>node_verifier?</code> string - specify how to verify node readiness or deactivate by using <code>None</code>. Possible values are <code>None</code> and <code>Metric</code>. Defaults to <code>Metric</code></li> </ul> <p>For example, the following configuration file defines a minimal example for the settings:</p> TOMLJSON base-example.toml<pre><code>[settings]\ntimeout = 1000\nbootnode = false\nprovider = \"kubernetes\"\nbackchannel = false\n# ...\n</code></pre> base-example.json<pre><code>{\n    \"settings\": {\n        \"timeout\": 1000,\n        \"bootnode\": false,\n        \"provider\": \"kubernetes\",\n        \"backchannel\": false,\n        \"...\": {}\n    },\n    \"...\": {}\n}\n</code></pre>"},{"location":"develop/toolkit/parachains/spawn-chains/zombienet/get-started/#relay-chain-configuration","title":"Relay Chain Configuration","text":"<p>You can use the <code>relaychain</code> keyword to define further parameters for the relay chain at start-up. The available keys are:</p> <ul> <li><code>default_command?</code> string - the default command to run. Defaults to <code>polkadot</code></li> <li><code>default_image?</code> string - the default Docker image to use</li> <li> <p><code>default_resources?</code> Resources - represents the resource limits/reservations the nodes need by default. Only available on Kubernetes</p> <code>Resources</code> interface definition <pre><code>export interface Resources {\n  resources: {\n    requests?: {\n      memory?: string;\n      cpu?: string;\n    };\n    limits?: {\n      memory?: string;\n      cpu?: string;\n    };\n  };\n}\n</code></pre> </li> <li> <p><code>default_db_snapshot?</code> string - the default database snapshot to use</p> </li> <li><code>default_prometheus_prefix</code> string - a parameter for customizing the metric's prefix. Defaults to <code>substrate</code></li> <li> <p><code>default_substrate_cli_args_version?</code> SubstrateCliArgsVersion - set the Substrate CLI arguments version</p> <code>SubstrateCliArgsVersion</code> enum definition <pre><code>export enum SubstrateCliArgsVersion {\n  V0 = 0,\n  V1 = 1,\n  V2 = 2,\n  V3 = 3,\n}\n</code></pre> </li> <li> <p><code>default_keystore_key_types?</code> string[] - defines which keystore keys should be created </p> </li> <li><code>chain</code> string - the chain name</li> <li><code>chain_spec_path?</code> string - path to the chain spec file. Should be the plain version to allow customizations</li> <li><code>chain_spec_command?</code> string - command to generate the chain spec. It can't be used in combination with <code>chain_spec_path</code></li> <li><code>default_args?</code> string[] - an array of arguments to use as default to pass to the command</li> <li> <p><code>default_overrides?</code> Override[] - an array of overrides to upload to the node</p> <code>Override</code> interface definition <pre><code>export interface Override {\n  local_path: string;\n  remote_name: string;\n} \n</code></pre> </li> <li> <p><code>random_nominators_count?</code> number - if set and the stacking pallet is enabled, Zombienet will generate the input quantity of nominators and inject them into the genesis</p> </li> <li><code>max_nominations</code> number - the max number of nominations allowed by a nominator. Should match the value set in the runtime. Defaults to <code>24</code></li> <li><code>nodes?</code> Node[] - an array of nodes to spawn. It is further defined in the Node Configuration section</li> <li><code>node_groups?</code> NodeGroup[] - an array of node groups to spawn. It is further defined in the Node Group Configuration section</li> <li><code>total_node_in_group?</code> number - the total number of nodes in the group. Defaults to <code>1</code></li> <li><code>genesis</code> JSON - the genesis configuration</li> <li> <p><code>default_delay_network_settings?</code> DelayNetworkSettings - sets the expected configuration to delay the network</p> <code>DelayNetworkSettings</code> interface definition <pre><code>export interface DelayNetworkSettings {\n  latency: string;\n  correlation?: string; // should be parsable as float by k8s\n  jitter?: string;\n}\n</code></pre> </li> </ul>"},{"location":"develop/toolkit/parachains/spawn-chains/zombienet/get-started/#node-configuration","title":"Node Configuration","text":"<p>One specific key capable of receiving more subkeys is the <code>nodes</code> key. This key is used to define further parameters for the nodes. The available keys:</p> <ul> <li><code>name</code> string - name of the node. Any whitespace will be replaced with a dash (for example, <code>new alice</code> will be converted to <code>new-alice</code>)</li> <li><code>image?</code> string - override default Docker image to use for this node</li> <li><code>command?</code> string - override default command to run</li> <li><code>command_with_args?</code> string - override default command and arguments</li> <li><code>args?</code> string[] - arguments to be passed to the command</li> <li> <p><code>env?</code> envVars[] - environment variables to set in the container</p> <code>envVars</code> interface definition <pre><code>export interface EnvVars {\n  name: string;\n  value: string;\n}\n</code></pre> </li> <li> <p><code>prometheus_prefix?</code> string - customizes the metric's prefix for the specific node. Defaults to <code>substrate</code></p> </li> <li><code>db_snapshot?</code> string - database snapshot to use</li> <li> <p><code>substrate_cli_args_version?</code> SubstrateCliArgsVersion - set the Substrate CLI arguments version directly to skip binary evaluation overhead</p> <code>SubstrateCliArgsVersion</code> enum definition <pre><code>export enum SubstrateCliArgsVersion {\n  V0 = 0,\n  V1 = 1,\n  V2 = 2,\n  V3 = 3,\n}\n</code></pre> </li> <li> <p><code>resources?</code> Resources - represent the resources limits/reservations needed by the node</p> <code>Resources</code> interface definition <pre><code>export interface Resources {\n  resources: {\n    requests?: {\n      memory?: string;\n      cpu?: string;\n    };\n    limits?: {\n      memory?: string;\n      cpu?: string;\n    };\n  };\n}\n</code></pre> </li> <li> <p><code>keystore_key_types?</code> string[] - defines which keystore keys should be created</p> </li> <li><code>validator</code> boolean - pass the <code>--validator</code> flag to the command. Defaults to <code>true</code></li> <li><code>invulnerable</code> boolean - if true, add the node to invulnerables in the chain spec. Defaults to <code>false</code></li> <li><code>balance</code> number - balance to set in balances for node's account. Defaults to <code>2000000000000</code></li> <li><code>bootnodes?</code> string[] - array of bootnodes to use</li> <li><code>add_to_bootnodes?</code> boolean - add this node to the bootnode list. Defaults to <code>false</code></li> <li><code>ws_port?</code> number - WS port to use</li> <li><code>rpc_port?</code> number - RPC port to use</li> <li><code>prometheus_port?</code> number - Prometheus port to use</li> <li><code>p2p_cert_hash?</code> string - libp2p certhash to use with webRTC transport</li> <li> <p><code>delay_network_settings?</code> DelayNetworkSettings - sets the expected configuration to delay the network</p> <code>DelayNetworkSettings</code> interface definition <pre><code>export interface DelayNetworkSettings {\n  latency: string;\n  correlation?: string; // should be parsable as float by k8s\n  jitter?: string;\n}\n</code></pre> </li> </ul> <p>The following configuration file defines a minimal example for the relay chain, including the <code>nodes</code> key:</p> TOMLJSON relaychain-example-nodes.toml<pre><code>[relaychain]\ndefault_command = \"polkadot\"\ndefault_image = \"polkadot-debug:master\"\nchain = \"rococo-local\"\nchain_spec_path = \"INSERT_PATH_TO_CHAIN_SPEC\"\ndefault_args = [\"--chain\", \"rococo-local\"]\n\n[[relaychain.nodes]]\nname = \"alice\"\nvalidator = true\nbalance = 1000000000000\n\n[[relaychain.nodes]]\nname = \"bob\"\nvalidator = true\nbalance = 1000000000000\n# ...\n</code></pre> relaychain-example-nodes.json<pre><code>{\n    \"relaychain\": {\n        \"default_command\": \"polkadot\",\n        \"default_image\": \"polkadot-debug:master\",\n        \"chain\": \"rococo-local\",\n        \"chain_spec_path\": \"INSERT_PATH_TO_CHAIN-SPEC.JSON\",\n        \"default_args\": [\"--chain\", \"rococo-local\"],\n        \"nodes\": [\n            {\n                \"name\": \"alice\",\n                \"validator\": true,\n                \"balance\": 1000000000000\n            },\n            {\n                \"name\": \"bob\",\n                \"validator\": true,\n                \"balance\": 1000000000000\n            }\n        ]\n    }\n}\n</code></pre>"},{"location":"develop/toolkit/parachains/spawn-chains/zombienet/get-started/#node-group-configuration","title":"Node Group Configuration","text":"<p>The <code>node_groups</code> key defines further parameters for the node groups. The available keys are:</p> <ul> <li><code>name</code> string - name of the node. Any whitespace will be replaced with a dash (for example, <code>new alice</code> will be converted to <code>new-alice</code>)</li> <li><code>image?</code> string - override default Docker image to use for this node</li> <li><code>command?</code> string - override default command to run</li> <li><code>args?</code> string[] - arguments to be passed to the command</li> <li> <p><code>env?</code> envVars[] - environment variables to set in the container</p> <code>envVars</code> interface definition <pre><code>export interface EnvVars {\n  name: string;\n  value: string;\n}\n</code></pre> </li> <li> <p><code>overrides?</code> Override[] - array of overrides definitions</p> <code>Override</code> interface definition <pre><code>export interface Override {\n  local_path: string;\n  remote_name: string;\n}\n</code></pre> </li> <li> <p><code>prometheus_prefix?</code> string - customizes the metric's prefix for the specific node. Defaults to <code>substrate</code></p> </li> <li><code>db_snapshot?</code> string - database snapshot to use</li> <li> <p><code>substrate_cli_args_version?</code> SubstrateCliArgsVersion - set the Substrate CLI arguments version directly to skip binary evaluation overhead</p> <code>SubstrateCliArgsVersion</code> enum definition <pre><code>export enum SubstrateCliArgsVersion {\n  V0 = 0,\n  V1 = 1,\n  V2 = 2,\n  V3 = 3,\n}\n</code></pre> </li> <li> <p><code>resources?</code> Resources - represent the resources limits/reservations needed by the node</p> <code>Resources</code> interface definition <pre><code>export interface Resources {\n  resources: {\n    requests?: {\n      memory?: string;\n      cpu?: string;\n    };\n    limits?: {\n      memory?: string;\n      cpu?: string;\n    };\n  };\n}\n</code></pre> </li> <li> <p><code>keystore_key_types?</code> string[] - defines which keystore keys should be created</p> </li> <li><code>count</code> number | string - number of nodes to launch for this group</li> <li> <p><code>delay_network_settings?</code> DelayNetworkSettings - sets the expected configuration to delay the network</p> <code>DelayNetworkSettings</code> interface definition <pre><code>export interface DelayNetworkSettings {\n  latency: string;\n  correlation?: string; // should be parsable as float by k8s\n  jitter?: string;\n}\n</code></pre> </li> </ul> <p>The following configuration file defines a minimal example for the relay chain, including the <code>node_groups</code> key:</p> TOMLJSON relaychain-example-node-groups.toml<pre><code>[relaychain]\ndefault_command = \"polkadot\"\ndefault_image = \"polkadot-debug:master\"\nchain = \"rococo-local\"\nchain_spec_path = \"INSERT_PATH_TO_CHAIN_SPEC\"\ndefault_args = [\"--chain\", \"rococo-local\"]\n\n[[relaychain.node_groups]]\nname = \"group-1\"\ncount = 2\nimage = \"polkadot-debug:master\"\ncommand = \"polkadot\"\nargs = [\"--chain\", \"rococo-local\"]\n# ...\n</code></pre> relaychain-example-node-groups.json<pre><code>{\n    \"relaychain\": {\n        \"default_command\": \"polkadot\",\n        \"default_image\": \"polkadot-debug:master\",\n        \"chain\": \"rococo-local\",\n        \"chain_spec_path\": \"INSERT_PATH_TO_CHAIN-SPEC.JSON\",\n        \"default_args\": [\"--chain\", \"rococo-local\"],\n        \"node_groups\": [\n            {\n                \"name\": \"group-1\",\n                \"count\": 2,\n                \"image\": \"polkadot-debug:master\",\n                \"command\": \"polkadot\",\n                \"args\": [\"--chain\", \"rococo-local\"]\n            }\n        ],\n        \"...\": {}\n    },\n    \"...\": {}\n}\n</code></pre>"},{"location":"develop/toolkit/parachains/spawn-chains/zombienet/get-started/#parachain-configuration","title":"Parachain Configuration","text":"<p>The <code>parachain</code> keyword defines further parameters for the parachain. The available keys are:</p> <ul> <li><code>id</code> number - the id to assign to this parachain. Must be unique</li> <li><code>chain?</code> string - the chain name</li> <li><code>force_decorator?</code> string - force the use of a specific decorator</li> <li><code>genesis?</code> JSON - the genesis configuration</li> <li><code>balance?</code> number - balance to set in balances for parachain's account</li> <li> <p><code>delay_network_settings?</code> DelayNetworkSettings - sets the expected configuration to delay the network</p> <code>DelayNetworkSettings</code> interface definition <pre><code>export interface DelayNetworkSettings {\n  latency: string;\n  correlation?: string; // should be parsable as float by k8s\n  jitter?: string;\n}\n</code></pre> </li> <li> <p><code>add_to_genesis?</code> boolean - flag to add parachain to genesis or register in runtime. Defaults to <code>true</code></p> </li> <li><code>register_para?</code> boolean - flag to specify whether the para should be registered. The <code>add_to_genesis</code> flag must be set to false for this flag to have any effect. Defaults to <code>true</code></li> <li><code>onboard_as_parachain?</code> boolean - flag to specify whether the para should be onboarded as a parachain, rather than remaining a parathread. Defaults to <code>true</code></li> <li><code>genesis_wasm_path?</code> string - path to the Wasm file to use</li> <li><code>genesis_wasm_generator?</code> string - command to generate the Wasm file</li> <li><code>genesis_state_path?</code> string - path to the state file to use</li> <li><code>genesis_state_generator?</code> string - command to generate the state file</li> <li><code>chain_spec_path?</code> string - path to the chain spec file</li> <li><code>chain_spec_command?</code> string - command to generate the chain spec</li> <li><code>cumulus_based?</code> boolean - flag to use cumulus command generation. Defaults to <code>true</code></li> <li><code>bootnodes?</code> string[] - array of bootnodes to use</li> <li><code>prometheus_prefix?</code> string - parameter for customizing the metric's prefix for all parachain nodes/collators. Defaults to <code>substrate</code></li> <li><code>collator?</code> Collator - further defined in the Collator Configuration section</li> <li><code>collator_groups?</code> CollatorGroup[] - an array of collator groups to spawn. It is further defined in the Collator Groups Configuration section</li> </ul> <p>For example, the following configuration file defines a minimal example for the parachain:</p> TOMLJSON parachain-example.toml<pre><code>[parachain]\nid = 100\nadd_to_genesis = true\ncumulus_based = true\ngenesis_wasm_path = \"INSERT_PATH_TO_WASM\"\ngenesis_state_path = \"INSERT_PATH_TO_STATE\"\n# ...\n</code></pre> parachain-example.json<pre><code>{\n    \"parachain\": {\n        \"id\": 100,\n        \"add_to_genesis\": true,\n        \"cumulus_based\": true,\n        \"genesis_wasm_path\": \"INSERT_PATH_TO_WASM\",\n        \"genesis_state_path\": \"INSERT_PATH_TO_STATE\",\n        \"...\": {}\n    },\n    \"...\": {}\n}\n</code></pre>"},{"location":"develop/toolkit/parachains/spawn-chains/zombienet/get-started/#collator-configuration","title":"Collator Configuration","text":"<p>One specific key capable of receiving more subkeys is the <code>collator</code> key. This key defines further parameters for the nodes. The available keys are:</p> <ul> <li><code>name</code> string - name of the collator. Any whitespace will be replaced with a dash (for example, <code>new alice</code> will be converted to <code>new-alice</code>)</li> <li><code>image?</code> string - image to use for the collator</li> <li><code>command_with_args?</code> string - overrides both command and arguments for the collator</li> <li><code>validator</code> boolean - pass the <code>--validator</code> flag to the command. Defaults to <code>true</code></li> <li><code>invulnerable</code> boolean - if true, add the collator to invulnerables in the chain spec. Defaults to <code>false</code></li> <li><code>balance</code> number - balance to set in balances for collator's account. Defaults to <code>2000000000000</code></li> <li><code>bootnodes?</code> string[] - array of bootnodes to use</li> <li><code>add_to_bootnodes?</code> boolean - add this collator to the bootnode list. Defaults to <code>false</code></li> <li><code>ws_port?</code> number - WS port to use</li> <li><code>rpc_port?</code> number - RPC port to use</li> <li><code>prometheus_port?</code> number - Prometheus port to use</li> <li><code>p2p_port?</code> number - P2P port to use</li> <li><code>p2p_cert_hash?</code> string - libp2p certhash to use with webRTC transport</li> <li> <p><code>delay_network_settings?</code> DelayNetworkSettings - sets the expected configuration to delay the network</p> <code>DelayNetworkSettings</code> interface definition <pre><code>export interface DelayNetworkSettings {\n  latency: string;\n  correlation?: string; // should be parsable as float by k8s\n  jitter?: string;\n}\n</code></pre> </li> <li> <p><code>command?</code> string - override default command to run</p> </li> <li><code>args?</code> string[] - arguments to be passed to the command</li> <li> <p><code>env?</code> envVars[] - environment variables to set in the container</p> <code>envVars</code> interface definition <pre><code>export interface EnvVars {\n  name: string;\n  value: string;\n}\n</code></pre> </li> <li> <p><code>overrides?</code> Override[] - array of overrides definitions</p> <code>Override</code> interface definition <pre><code>export interface Override {\n  local_path: string;\n  remote_name: string;\n}\n</code></pre> </li> <li> <p><code>prometheus_prefix?</code> string - customizes the metric's prefix for the specific node. Defaults to <code>substrate</code></p> </li> <li><code>db_snapshot?</code> string - database snapshot to use</li> <li> <p><code>substrate_cli_args_version?</code> SubstrateCliArgsVersion - set the Substrate CLI arguments version directly to skip binary evaluation overhead</p> <code>SubstrateCliArgsVersion</code> enum definition <pre><code>export enum SubstrateCliArgsVersion {\n  V0 = 0,\n  V1 = 1,\n  V2 = 2,\n  V3 = 3,\n}\n</code></pre> </li> <li> <p><code>resources?</code> Resources - represent the resources limits/reservations needed by the node</p> <code>Resources</code> interface definition <pre><code>export interface Resources {\n  resources: {\n    requests?: {\n      memory?: string;\n      cpu?: string;\n    };\n    limits?: {\n      memory?: string;\n      cpu?: string;\n    };\n  };\n}\n</code></pre> </li> <li> <p><code>keystore_key_types?</code> string[] - defines which keystore keys should be created</p> </li> </ul> <p>The configuration file below defines a minimal example for the collator:</p> TOMLJSON collator-example.toml<pre><code>[parachain]\nid = 100\nadd_to_genesis = true\ncumulus_based = true\ngenesis_wasm_path = \"INSERT_PATH_TO_WASM\"\ngenesis_state_path = \"INSERT_PATH_TO_STATE\"\n\n[[parachain.collators]]\nname = \"alice\"\nimage = \"polkadot-parachain\"\ncommand = \"polkadot-parachain\"\n# ...\n</code></pre> collator-example.json<pre><code>{\n    \"parachain\": {\n        \"id\": 100,\n        \"add_to_genesis\": true,\n        \"cumulus_based\": true,\n        \"genesis_wasm_path\": \"INSERT_PATH_TO_WASM\",\n        \"genesis_state_path\": \"INSERT_PATH_TO_STATE\",\n        \"collators\": [\n            {\n                \"name\": \"alice\",\n                \"image\": \"polkadot-parachain\",\n                \"command\": \"polkadot-parachain\",\n                \"...\": {}\n            }\n        ]\n    },\n    \"...\": {}\n}\n</code></pre>"},{"location":"develop/toolkit/parachains/spawn-chains/zombienet/get-started/#collator-groups-configuration","title":"Collator Groups Configuration","text":"<p>The <code>collator_groups</code> key defines further parameters for the collator groups. The available keys are:</p> <ul> <li><code>name</code> string - name of the node. Any whitespace will be replaced with a dash (for example, <code>new alice</code> will be converted to <code>new-alice</code>)</li> <li><code>image?</code> string - override default Docker image to use for this node</li> <li><code>command?</code> string - override default command to run</li> <li><code>args?</code> string[] - arguments to be passed to the command</li> <li> <p><code>env?</code> envVars[] - environment variables to set in the container</p> <code>envVars</code> interface definition <pre><code>export interface EnvVars {\n  name: string;\n  value: string;\n}\n</code></pre> </li> <li> <p><code>overrides?</code> Override[] - array of overrides definitions</p> <code>Override</code> interface definition <pre><code>export interface Override {\n  local_path: string;\n  remote_name: string;\n}\n</code></pre> </li> <li> <p><code>prometheus_prefix?</code> string - customizes the metric's prefix for the specific node. Defaults to <code>substrate</code></p> </li> <li><code>db_snapshot?</code> string - database snapshot to use</li> <li> <p><code>substrate_cli_args_version?</code> SubstrateCliArgsVersion - set the Substrate CLI arguments version directly to skip binary evaluation overhead</p> <code>SubstrateCliArgsVersion</code> enum definition <pre><code>export enum SubstrateCliArgsVersion {\n  V0 = 0,\n  V1 = 1,\n  V2 = 2,\n  V3 = 3,\n}\n</code></pre> </li> <li> <p><code>resources?</code> Resources - represent the resources limits/reservations needed by the node</p> <code>Resources</code> interface definition <pre><code>export interface Resources {\n  resources: {\n    requests?: {\n      memory?: string;\n      cpu?: string;\n    };\n    limits?: {\n      memory?: string;\n      cpu?: string;\n    };\n  };\n}\n</code></pre> </li> <li> <p><code>keystore_key_types?</code> string[] - defines which keystore keys should be created</p> </li> <li><code>count</code> number | string - number of nodes to launch for this group</li> <li> <p><code>delay_network_settings?</code> DelayNetworkSettings - sets the expected configuration to delay the network</p> <code>DelayNetworkSettings</code> interface definition <pre><code>export interface DelayNetworkSettings {\n  latency: string;\n  correlation?: string; // should be parsable as float by k8s\n  jitter?: string;\n}\n</code></pre> </li> </ul> <p>For instance, the configuration file below defines a minimal example for the collator groups:</p> TOMLJSON collator-groups-example.toml<pre><code>[parachain]\nid = 100\nadd_to_genesis = true\ncumulus_based = true\ngenesis_wasm_path = \"INSERT_PATH_TO_WASM\"\ngenesis_state_path = \"INSERT_PATH_TO_STATE\"\n\n[[parachain.collator_groups]]\nname = \"group-1\"\ncount = 2\nimage = \"polkadot-parachain\"\ncommand = \"polkadot-parachain\"\n# ...\n</code></pre> collator-groups-example.json<pre><code>{\n    \"parachain\": {\n        \"id\": 100,\n        \"add_to_genesis\": true,\n        \"cumulus_based\": true,\n        \"genesis_wasm_path\": \"INSERT_PATH_TO_WASM\",\n        \"genesis_state_path\": \"INSERT_PATH_TO_STATE\",\n        \"collator_groups\": [\n            {\n                \"name\": \"group-1\",\n                \"count\": 2,\n                \"image\": \"polkadot-parachain\",\n                \"command\": \"polkadot-parachain\",\n                \"...\": {}\n            }\n        ]\n    },\n    \"...\": {}\n}\n</code></pre>"},{"location":"develop/toolkit/parachains/spawn-chains/zombienet/get-started/#xcm-configuration","title":"XCM Configuration","text":"<p>You can use the <code>hrmp_channels</code> keyword to define further parameters for the XCM channels at start-up. The available keys are:</p> <ul> <li> <p><code>hrmp_channels</code> HrmpChannelsConfig[] - array of Horizontal Relay-routed Message Passing (HRMP) channel configurations</p> <code>HrmpChannelsConfig</code> interface definition <p><pre><code>export interface HrmpChannelsConfig {\n  sender: number;\n  recipient: number;\n  max_capacity: number;\n  max_message_size: number;\n}\n</code></pre> Each of the <code>HrmpChannelsConfig</code> keys are defined as follows:</p> <ul> <li><code>sender</code> number - parachain ID of the sender</li> <li><code>recipient</code> number - parachain ID of the recipient</li> <li><code>max_capacity</code> number - maximum capacity of the HRMP channel</li> <li><code>max_message_size</code> number - maximum message size allowed in the HRMP channel</li> </ul> </li> </ul>"},{"location":"develop/toolkit/parachains/spawn-chains/zombienet/write-tests/","title":"Write Tests","text":""},{"location":"develop/toolkit/parachains/spawn-chains/zombienet/write-tests/#introduction","title":"Introduction","text":"<p>Testing is a critical step in blockchain development, ensuring reliability, performance, and security. Zombienet simplifies this process with its intuitive Domain Specific Language (DSL), enabling developers to write natural-language test scripts tailored to their network needs.</p> <p>This guide provides an in-depth look at how to create and execute test scenarios using Zombienet's flexible testing framework. You\u2019ll learn how to define tests for metrics, logs, events, and more, allowing for comprehensive evaluation of your blockchain network\u2019s behavior and performance.</p>"},{"location":"develop/toolkit/parachains/spawn-chains/zombienet/write-tests/#testing-dsl","title":"Testing DSL","text":"<p>Zombienet provides a Domain Specific Language (DSL) for writing tests. The DSL is designed to be human-readable and allows you to write tests using natural language expressions. You can define assertions and tests against the spawned network using this DSL. This way, users can evaluate different metrics, such as:</p> <ul> <li>On-chain storage - the storage of each of the chains running via Zombienet</li> <li>Metrics - the metrics provided by the nodes</li> <li>Histograms - visual representations of metrics data</li> <li>Logs - detailed records of system activities and events</li> <li>System events - notifications of significant occurrences within the network</li> <li>Tracing - detailed analysis of execution paths and operations</li> <li>Custom API calls (through Polkadot.js) - personalized interfaces for interacting with the network</li> <li>Commands - instructions or directives executed by the network</li> </ul> <p>These abstractions are expressed by sentences defined in a natural language style. Therefore, each test line will be mapped to a test to run. Also, the test file (<code>*.zndsl</code>) includes pre-defined header fields used to define information about the suite, such as network configuration and credentials location.</p> <p>Note</p> <p>View the Testing DSL specification for more details on the Zombienet DSL.</p>"},{"location":"develop/toolkit/parachains/spawn-chains/zombienet/write-tests/#the-test-file","title":"The Test File","text":"<p>The test file is a text file with the extension <code>.zndsl</code>. It is divided into two parts: the header and the body. The header contains the network configuration and the credentials to use, while the body contains the tests to run.</p> <p>The header is defined by the following fields:</p> <ul> <li><code>description</code> string - long description of the test suite (optional)</li> <li><code>network</code> string - path to the network definition file, supported in both <code>.json</code> and <code>.toml</code> formats</li> <li><code>creds</code> string - credentials filename or path to use (available only with Kubernetes provider). Looks in the current directory or <code>$HOME/.kube/</code> if a filename is passed</li> </ul> <p>The body contains the tests to run. Each test is defined by a sentence in the DSL, which is mapped to a test to run. Each test line defines an assertion or a command to be executed against the spawned network.</p>"},{"location":"develop/toolkit/parachains/spawn-chains/zombienet/write-tests/#name","title":"Name","text":"<p>The test name in Zombienet is derived from the filename by removing any leading numeric characters before the first hyphen. For example, a file named <code>0001-zombienet-test.zndsl</code> will result in a test name of <code>zombienet-test</code>, which will be displayed in the test report output of the runner.</p>"},{"location":"develop/toolkit/parachains/spawn-chains/zombienet/write-tests/#assertions","title":"Assertions","text":"<p>Assertions are defined by sentences in the DSL that evaluate different metrics, such as on-chain storage, metrics, histograms, logs, system events, tracing, and custom API calls. Each assertion is defined by a sentence in the DSL, which is mapped to a test to run.</p> <ul> <li> <p><code>Well known functions</code> - already mapped test function</p> SyntaxExamples <p><code>node-name well-known_defined_test [within x seconds]</code></p> <pre><code>alice: is up\nalice: parachain 100 is registered within 225 seconds\nalice: parachain 100 block height is at least 10 within 250 seconds\n</code></pre> </li> <li> <p><code>Histogram</code> - get metrics from Prometheus, calculate the histogram, and assert on the target value</p> SyntaxExample <p><code>node-name reports histogram metric_name has comparator target_value samples in buckets [\"bucket\",\"bucket\",...] [within x seconds]</code></p> <pre><code>alice: reports histogram polkadot_pvf_execution_time has at least 2 samples in buckets [\"0.1\", \"0.25\", \"0.5\", \"+Inf\"] within 100 seconds\n</code></pre> </li> <li> <p><code>Metric</code> - get metric from Prometheus and assert on the target value</p> SyntaxExamples <p><code>node-name reports metric_name comparator target_value (e.g \"is at least x\", \"is greater than x\") [within x seconds]</code></p> <pre><code>alice: reports node_roles is 4\nalice: reports sub_libp2p_is_major_syncing is 0\n</code></pre> </li> <li> <p><code>Log line</code> - get logs from nodes and assert on the matching pattern</p> SyntaxExample <p><code>node-name log line (contains|matches) (regex|glob) \"pattern\" [within x seconds]</code></p> <pre><code>alice: log line matches glob \"rted #1\" within 10 seconds\n</code></pre> </li> <li> <p><code>Count of log lines</code> - get logs from nodes and assert on the number of lines matching pattern</p> SyntaxExample <p><code>node-name count of log lines (containing|matching) (regex|glob) \"pattern\" [within x seconds]</code></p> <pre><code>alice: count of log lines matching glob \"rted #1\" within 10 seconds\n</code></pre> </li> <li> <p><code>System events</code> - find a system event from subscription by matching a pattern</p> SyntaxExample <p><code>node-name system event (contains|matches)(regex| glob) \"pattern\" [within x seconds]</code></p> <pre><code>alice: system event matches \"\"paraId\":[0-9]+\" within 10 seconds\n</code></pre> </li> <li> <p><code>Tracing</code> - match an array of span names from the supplied <code>traceID</code></p> SyntaxExample <p><code>node-name trace with traceID contains [\"name\", \"name2\",...]</code></p> <pre><code>alice: trace with traceID 94c1501a78a0d83c498cc92deec264d9 contains [\"answer-chunk-request\", \"answer-chunk-request\"]\n</code></pre> </li> <li> <p><code>Custom JS scripts</code> - run a custom JavaScript script and assert on the return value</p> SyntaxExample <p><code>node-name js-script script_relative_path [return is comparator target_value] [within x seconds]</code></p> <pre><code>alice: js-script ./0008-custom.js return is greater than 1 within 200 seconds\n</code></pre> </li> <li> <p><code>Custom TS scripts</code> - run a custom TypeScript script and assert on the return value</p> SyntaxExample <p><code>node-name ts-script script_relative_path [return is comparator target_value] [within x seconds]</code></p> <pre><code>alice: ts-script ./0008-custom-ts.ts return is greater than 1 within 200 seconds\n</code></pre> </li> <li> <p><code>Backchannel</code> - wait for a value and register to use</p> SyntaxExample <p><code>node-name wait for var name and use as X [within x seconds]</code></p> <pre><code>alice: wait for name and use as X within 30 seconds\n</code></pre> </li> </ul>"},{"location":"develop/toolkit/parachains/spawn-chains/zombienet/write-tests/#commands","title":"Commands","text":"<p>Commands allow interaction with the nodes and can run pre-defined commands or an arbitrary command in the node. Commonly used commands are as follows:</p> <ul> <li> <p><code>restart</code> - stop the process and start again after the <code>X</code> amount of seconds or immediately</p> </li> <li> <p><code>pause</code> - pause (SIGSTOP) the process</p> </li> <li> <p><code>resume</code> - resume (SIGCONT) the process</p> </li> <li> <p><code>sleep</code> - sleep the test-runner for <code>x</code> amount of seconds</p> </li> </ul>"},{"location":"develop/toolkit/parachains/spawn-chains/zombienet/write-tests/#running-a-test","title":"Running a Test","text":"<p>To run a test against the spawned network, you can use the Zombienet DSL to define the test scenario. Follow these steps to create an example test:</p> <ol> <li> <p>Create a file named <code>spawn-a-basic-network-test.zndsl</code> <pre><code>touch spawn-a-basic-network-test.zndsl\n</code></pre></p> </li> <li> <p>Add the following code to the file you just created. spawn-a-basic-network-test.zndsl<pre><code>Description: Test the basic functionality of the network (minimal example)\nNetwork: ./spawn-a-basic-network.toml\nCreds: config\n\nalice: is up\nalice: parachain 100 is registered within 225 seconds\nalice: parachain 100 block height is at least 10 within 250 seconds\n\nbob: is up\nbob: parachain 100 is registered within 225 seconds\nbob: parachain 100 block height is at least 10 within 250 seconds\n\n# metrics\nalice: reports node_roles is 4\nalice: reports sub_libp2p_is_major_syncing is 0\n\nbob: reports node_roles is 4\n\ncollator01: reports node_roles is 4\n</code></pre></p> </li> </ol> <p>This test scenario checks to verify the following:</p> <ul> <li>Nodes are running</li> <li>The parachain with ID 100 is registered within a certain timeframe (255 seconds in this example)</li> <li>Parachain block height is at least a certain number within a timeframe (in this case, 10 within 255 seconds)</li> <li>Nodes are reporting metrics </li> </ul> <p>You can define any test scenario you need following the Zombienet DSL syntax.</p> <p>To run the test, execute the following command:</p> <pre><code>zombienet -p native test spawn-a-basic-network-test.zndsl\n</code></pre> <p>This command will execute the test scenario defined in the <code>spawn-a-basic-network-test.zndsl</code> file on the network. If successful, the terminal will display the test output, indicating whether the test passed or failed.</p>"},{"location":"develop/toolkit/parachains/spawn-chains/zombienet/write-tests/#example-test-files","title":"Example Test Files","text":"<p>The following example test files define two tests, a small network test and a big network test. Each test defines a network configuration file and credentials to use.</p> <p>The tests define assertions to evaluate the network\u2019s metrics and logs. The assertions are defined by sentences in the DSL, which are mapped to tests to run.</p> small-network-test.zndsl<pre><code>Description: Small Network test\nNetwork: ./0000-test-config-small-network.toml\nCreds: config\n\n# metrics\nalice: reports node_roles is 4\nalice: reports sub_libp2p_is_major_syncing is 0\n\n# logs\nbob: log line matches glob \"*rted #1*\" within 10 seconds\nbob: log line matches \"Imported #[0-9]+\" within 10 seconds\n</code></pre> <p>And the second test file:</p> big-network-test.zndsl<pre><code>Description: Big Network test\nNetwork: ./0001-test-config-big-network.toml\nCreds: config\n\n# metrics\nalice: reports node_roles is 4\nalice: reports sub_libp2p_is_major_syncing is 0\n\n# logs\nbob: log line matches glob \"*rted #1*\" within 10 seconds\nbob: log line matches \"Imported #[0-9]+\" within 10 seconds\n\n# custom js script\nalice: js-script ./0008-custom.js return is greater than 1 within 200 seconds\n\n# custom ts script\nalice: ts-script ./0008-custom-ts.ts return is greater than 1 within 200 seconds\n\n# backchannel\nalice: wait for name and use as X within 30 seconds\n\n# well know functions\nalice: is up\nalice: parachain 100 is registered within 225 seconds\nalice: parachain 100 block height is at least 10 within 250 seconds\n\n# histogram\nalice: reports histogram polkadot_pvf_execution_time has at least 2 samples in buckets [\"0.1\", \"0.25\", \"0.5\", \"+Inf\"] within 100 seconds\n\n# system events\nalice: system event matches \"\"paraId\":[0-9]+\" within 10 seconds\n\n# tracing\nalice: trace with traceID 94c1501a78a0d83c498cc92deec264d9 contains [\"answer-chunk-request\", \"answer-chunk-request\"]\n</code></pre>"},{"location":"images/","title":"Images","text":"<p>TODO</p>"},{"location":"infrastructure/","title":"Infrastructure","text":"<p>Running infrastructure on Polkadot is essential to supporting the network\u2019s performance and security. Operators must focus on reliability, ensure proper configuration, and meet the necessary hardware requirements to contribute effectively to the decentralized ecosystem.</p> <ul> <li>Not sure where to start? Visit the Choosing the Right Role section for guidance</li> <li>Ready to get started? Jump to In This Section to get started</li> </ul>"},{"location":"infrastructure/#choosing-the-right-role","title":"Choosing the Right Role","text":"<p>Selecting your role within the Polkadot ecosystem depends on your goals, resources, and expertise. Below are detailed considerations for each role:</p> <ul> <li> <p>Running a node:</p> <ul> <li>Purpose - a node provides access to network data and supports API queries. It is commonly used for:<ul> <li>Development and testing - offers a local instance to simulate network conditions and test applications</li> <li>Production use - acts as a data source for dApps, clients, and other applications needing reliable access to the blockchain</li> </ul> </li> <li>Requirements - moderate hardware resources to handle blockchain data efficiently</li> <li>Responsibilities - a node\u2019s responsibilities vary based on its purpose:<ul> <li>Development and testing - enables developers to test features, debug code, and simulate network interactions in a controlled environment</li> <li>Production use - provides consistent and reliable data access for dApps and other applications, ensuring minimal downtime</li> </ul> </li> </ul> </li> <li> <p>Running a validator:</p> <ul> <li>Purpose - validators play a critical role in securing the Polkadot relay chain. They validate parachain block submissions, participate in consensus, and help maintain the network's overall integrity</li> <li>Requirements - becoming a validator requires:<ul> <li>Staking - a variable amount of DOT tokens to secure the network and demonstrate commitment</li> <li>Hardware - high-performing hardware resources capable of supporting intensive blockchain operations</li> <li>Technical expertise - proficiency in setting up and maintaining nodes, managing updates, and understanding Polkadot's consensus mechanisms</li> <li>Community involvement - building trust and rapport within the community to attract nominators willing to stake with your validator</li> </ul> </li> <li>Responsibilities - validators have critical responsibilities to ensure network health:<ul> <li>Uptime - maintain near-constant availability to avoid slashing penalties for downtime or unresponsiveness</li> <li>Network security - participate in consensus and verify parachain transactions to uphold the network's security and integrity</li> <li>Availability - monitor the network for events and respond to issues promptly, such as misbehavior reports or protocol updates</li> </ul> </li> </ul> </li> </ul>"},{"location":"infrastructure/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"infrastructure/running-a-node/","title":"Running a Node","text":"<p>Running a node on the Polkadot network enables you to access blockchain data, interact with the network, and support decentralized applications (dApps). This guide will walk you through the process of setting up and connecting to a Polkadot node, including essential configuration steps for ensuring connectivity and security.</p>"},{"location":"infrastructure/running-a-node/#full-nodes-vs-bootnodes","title":"Full Nodes vs Bootnodes","text":"<p>Full nodes and bootnodes serve different roles within the network, each contributing in unique ways to connectivity and data access:</p> <ul> <li>Full node - stores blockchain data, validates transactions, and can serve as a source for querying data</li> <li>Bootnode - assists new nodes in discovering peers and connecting to the network, but doesn\u2019t store blockchain data</li> </ul> <p>The following sections describe the different types of full nodes\u2014pruned, archive, and light nodes\u2014and the unique features of each for various use cases.</p>"},{"location":"infrastructure/running-a-node/#types-of-full-nodes","title":"Types of Full Nodes","text":"<p>The three main types of nodes are as follows:</p> <ul> <li>Pruned node - prunes historical states of all finalized block states older than a specified number except for the genesis block's state</li> <li>Archive node - preserves all the past blocks and their states, making it convenient to query the past state of the chain at any given time. Archive nodes use a lot of disk space, which means they should be limited to use cases that require easy access to past on-chain data, such as block explorers</li> <li>Light node - has only the runtime and the current state but doesn't store past blocks, making them useful for resource-restricted devices</li> </ul> <p>Each node type can be configured to provide remote access to blockchain data via RPC endpoints, allowing external clients, like dApps or developers, to submit transactions, query data, and interact with the blockchain remotely.</p> <p>Tip</p> <p>On Stakeworld, you can find a list of the database sizes of Polkadot and Kusama nodes.</p>"},{"location":"infrastructure/running-a-node/#state-vs-block-pruning","title":"State vs. Block Pruning","text":"<p>A pruned node retains only a subset of finalized blocks, discarding older data. The two main types of pruning are:</p> <ul> <li>State pruning - removes the states of old blocks while retaining block headers</li> <li>Block pruning - removes both the full content of old blocks and their associated states, but keeps the block headers</li> </ul> <p>Despite these deletions, pruned nodes are still capable of performing many essential functions, such as displaying account balances, making transfers, setting up session keys, and participating in staking.</p>"},{"location":"infrastructure/running-a-node/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"infrastructure/running-a-node/setup-bootnode/","title":"Set Up a Bootnode","text":""},{"location":"infrastructure/running-a-node/setup-bootnode/#introduction","title":"Introduction","text":"<p>Bootnodes are essential for helping blockchain nodes discover peers and join the network. When a node starts, it needs to find other nodes, and bootnodes provide an initial point of contact. Once connected, a node can expand its peer connections and play its role in the network, like participating as a validator.</p> <p>This guide will walk you through setting up a Polkadot bootnode, configuring P2P, WebSocket (WS), secure WSS connections, and managing network keys. You'll also learn how to test your bootnode to ensure it is running correctly and accessible to other nodes.</p>"},{"location":"infrastructure/running-a-node/setup-bootnode/#prerequisites","title":"Prerequisites","text":"<p>Before you start, you need to have the following prerequisites:</p> <ul> <li>Verify a working Polkadot (<code>polkadot</code>) binary is available on your machine</li> <li>Ensure you have nginx installed. Please refer to the Installation Guide for help with installation if needed</li> <li>A VPS or other dedicated server setup</li> </ul>"},{"location":"infrastructure/running-a-node/setup-bootnode/#accessing-the-bootnode","title":"Accessing the Bootnode","text":"<p>Bootnodes must be accessible through three key channels to connect with other nodes in the network:</p> <ul> <li> <p>P2P - a direct peer-to-peer connection, set by:</p> <pre><code>--listen-addr /ip4/0.0.0.0/tcp/INSERT_PORT\n</code></pre> <p>Note</p> <p>This is not enabled by default on non-validator nodes like archive RPC nodes.</p> </li> <li> <p>P2P/WS - a WebSocket (WS) connection, also configured via <code>--listen-addr</code></p> </li> <li>P2P/WSS - a secure WebSocket (WSS) connection using SSL, often required for light clients. An SSL proxy is needed, as the node itself cannot handle certificates</li> </ul>"},{"location":"infrastructure/running-a-node/setup-bootnode/#node-key","title":"Node Key","text":"<p>A node key is the ED25519 key used by <code>libp2p</code> to assign your node an identity or peer ID. Generating a known node key for a bootnode is crucial, as it gives you a consistent key that can be placed in chain specifications as a known, reliable bootnode.</p> <p>Starting a node creates its node key in the <code>chains/INSERT_CHAIN/network/secret_ed25519</code> file.</p> <p>You can create a node key using:</p> <pre><code>polkadot key generate-node-key\n</code></pre> <p>This key can be used in the startup command line.</p> <p>It is imperative that you backup the node key. If it is included in the <code>polkadot</code> binary, it is hardcoded into the binary, which must be recompiled to change the key.</p>"},{"location":"infrastructure/running-a-node/setup-bootnode/#running-the-bootnode","title":"Running the Bootnode","text":"<p>A bootnode can be run as follows:</p> <pre><code>polkadot --chain polkadot \\\n--name dot-bootnode \\\n--listen-addr /ip4/0.0.0.0/tcp/30310 \\\n--listen-addr /ip4/0.0.0.0/tcp/30311/ws\n</code></pre> <p>This assigns the p2p to port 30310 and p2p/ws to port 30311. For the p2p/wss port, a proxy must be set up with a DNS name and a corresponding certificate. The following example is for the popular nginx server and enables p2p/wss on port 30312 by adding a proxy to the p2p/ws port 30311:</p> /etc/nginx/sites-enabled/dot-bootnode<pre><code>server {\n       listen       30312 ssl http2 default_server;\n       server_name  dot-bootnode.stakeworld.io;\n       root         /var/www/html;\n\n       ssl_certificate \"INSERT_YOUR_CERT\";\n       ssl_certificate_key \"INSERT_YOUR_KEY\";\n\n       location / {\n         proxy_buffers 16 4k;\n         proxy_buffer_size 2k;\n         proxy_pass http://localhost:30311;\n         proxy_http_version 1.1;\n         proxy_set_header Upgrade $http_upgrade;\n         proxy_set_header Connection \"Upgrade\";\n         proxy_set_header Host $host;\n   }\n\n}\n</code></pre>"},{"location":"infrastructure/running-a-node/setup-bootnode/#testing-bootnode-connection","title":"Testing Bootnode Connection","text":"<p>If the preceding node is running with DNS name <code>dot-bootnode.stakeworld.io</code>, which contains a proxy with a valid certificate and node-id <code>12D3KooWAb5MyC1UJiEQJk4Hg4B2Vi3AJdqSUhTGYUqSnEqCFMFg</code> then the following commands should output <code>syncing 1 peers</code>.</p> <p>Tip</p> <p>You can add <code>-lsub-libp2p=trace</code> on the end to get libp2p trace logging for debugging purposes.</p>"},{"location":"infrastructure/running-a-node/setup-bootnode/#p2p","title":"P2P","text":"<pre><code>polkadot --chain polkadot \\\n--base-path /tmp/node \\\n--name \"Bootnode testnode\" \\\n--reserved-only \\\n--reserved-nodes \"/dns/dot-bootnode.stakeworld.io/tcp/30310/p2p/12D3KooWAb5MyC1UJiEQJk4Hg4B2Vi3AJdqSUhTGYUqSnEqCFMFg\" \\\n--no-hardware-benchmarks\n</code></pre>"},{"location":"infrastructure/running-a-node/setup-bootnode/#p2pws","title":"P2P/WS","text":"<pre><code>polkadot --chain polkadot \\\n--base-path /tmp/node \\\n--name \"Bootnode testnode\" \\\n--reserved-only \\\n--reserved-nodes \"/dns/dot-bootnode.stakeworld.io/tcp/30311/ws/p2p/12D3KooWAb5MyC1UJiEQJk4Hg4B2Vi3AJdqSUhTGYUqSnEqCFMFg\" \\\n--no-hardware-benchmarks\n</code></pre>"},{"location":"infrastructure/running-a-node/setup-bootnode/#p2pwss","title":"P2P/WSS","text":"<pre><code>polkadot --chain polkadot \\\n--base-path /tmp/node \\\n--name \"Bootnode testnode\" \\\n--reserved-only \\\n--reserved-nodes \"/dns/dot-bootnode.stakeworld.io/tcp/30312/wss/p2p/12D3KooWAb5MyC1UJiEQJk4Hg4B2Vi3AJdqSUhTGYUqSnEqCFMFg\" \\\n--no-hardware-benchmarks\n</code></pre>"},{"location":"infrastructure/running-a-node/setup-full-node/","title":"Set Up a Node","text":""},{"location":"infrastructure/running-a-node/setup-full-node/#introduction","title":"Introduction","text":"<p>Running a node on Polkadot provides direct interaction with the network, enhanced privacy, and full control over RPC requests, transactions, and data queries. As the backbone of the network, nodes ensure decentralized data propagation, transaction validation, and seamless communication across the ecosystem.</p> <p>Polkadot supports multiple node types, including pruned, archive, and light nodes, each suited to specific use cases. During setup, you can use configuration flags to choose the node type you wish to run.</p> <p>This guide walks you through configuring, securing, and maintaining a node on Polkadot or any Polkadot SDK-based chain. It covers instructions for the different node types and how to safely expose your node's RPC server for external access. Whether you're building a local development environment, powering dApps, or supporting network decentralization, this guide provides all the essentials.</p>"},{"location":"infrastructure/running-a-node/setup-full-node/#set-up-a-node_1","title":"Set Up a Node","text":"<p>Now that you're familiar with the different types of nodes, this section will walk you through configuring, securing, and maintaining a node on Polkadot or any Polkadot SDK-based chain.</p>"},{"location":"infrastructure/running-a-node/setup-full-node/#prerequisites","title":"Prerequisites","text":"<p>Before getting started, ensure the following prerequisites are met:</p> <ul> <li>Ensure Rust is installed on your operating system</li> <li>Install the necessary dependencies for the Polkadot SDK</li> </ul> <p>Warning</p> <p>This setup is not recommended for validators. If you plan to run a validator, refer to the Running a Validator guide for proper instructions.</p>"},{"location":"infrastructure/running-a-node/setup-full-node/#install-and-build-the-polkadot-binary","title":"Install and Build the Polkadot Binary","text":"<p>This section will walk you through installing and building the Polkadot binary for different operating systems and methods.</p> macOS <p>To get started, update and configure the Rust toolchain by running the following commands:</p> <pre><code>source ~/.cargo/env\n\nrustup default stable\nrustup update\n\nrustup update nightly\nrustup target add wasm32-unknown-unknown --toolchain nightly\nrustup component add rust-src --toolchain stable-aarch64-apple-darwin\n</code></pre> <p>You can verify your installation by running:</p> <pre><code>rustup show\nrustup +nightly show\n</code></pre> <p>You should see output similar to the following:</p> <p> rustup show      rustup +nightly show&lt;/span <p>active toolchain ---------------- stable-aarch64-apple-darwin (default) rustc 1.82.0 (f6e511eec 2024-10-15) active toolchain ---------------- nightly-aarch64-apple-darwin (overridden by +toolchain on the command line)  rustc 1.84.0-nightly (03ee48451 2024-11-18) </p> <p>Then, run the following commands to clone and build the Polkadot binary:</p> <pre><code>git clone https://github.com/paritytech/polkadot-sdk polkadot-sdk\ncd polkadot-sdk\ncargo build --release\n</code></pre> <p>Depending upon the specs of your machine, compiling the binary may take an hour or more. After building the Polkadot node from source, the executable binary will be located in the <code>./target/release/polkadot</code> directory.</p> Windows <p>To get started, make sure that you have WSL and Ubuntu installed on your Windows machine.</p> <p>Once installed, you have a couple options for installing the Polkadot binary:</p> <ul> <li>If Rust is installed, then <code>cargo</code> can be used similar to the macOS instructions</li> <li>Or, the instructions in the Linux section can be used</li> </ul> Linux (pre-built binary) <p>To grab the latest release of the Polkadot binary, you can use <code>wget</code>:</p> <pre><code>wget https://github.com/paritytech/polkadot-sdk/releases/download/polkadot-INSERT_VERSION/polkadot\n</code></pre> <p>Ensure you note the executable binary's location, as you'll need to use it when running the start-up command. If you prefer, you can specify the output location of the executable binary with the <code>-O</code> flag, for example:</p> <pre><code>wget https://github.com/paritytech/polkadot-sdk/releases/download/polkadot-INSERT_VERSION/polkadot \\\n- O /var/lib/polkadot-data/polkadot\n</code></pre> <p>Info</p> <p>The nature of pre-built binaries means that they may not work on your particular architecture or Linux distribution. If you see an error like <code>cannot execute binary file: Exec format error</code> it likely means the binary is incompatible with your system. You will either need to compile the binary or use Docker.</p> <p>Ensure that you properly configure the permissions to make the Polkadot release binary executable:</p> <pre><code>sudo chmod +x polkadot\n</code></pre> Linux (compile binary) <p>The most reliable (although perhaps not the fastest) way of launching a full node is to compile the binary yourself. Depending on your machine's specs, this may take an hour or more.</p> <p>To get started, run the following commands to configure the Rust toolchain:</p> <pre><code>rustup default stable\nrustup update\nrustup update nightly\nrustup target add wasm32-unknown-unknown --toolchain nightly\nrustup target add wasm32-unknown-unknown --toolchain stable-x86_64-unknown-linux-gnu\nrustup component add rust-src --toolchain stable-x86_64-unknown-linux-gnu\n</code></pre> <p>You can verify your installation by running:</p> <pre><code>rustup show\n</code></pre> <p>You should see output similar to the following:</p> <p> rustup show      rustup +nightly show&lt;/span <p>active toolchain ---------------- stable-x86_64-unknown-linux-gnu (default) rustc 1.82.0 (f6e511eec 2024-10-15) </p> <p>Once Rust is configured, run the following commands to clone and build Polkadot:</p> <pre><code>git clone https://github.com/paritytech/polkadot-sdk polkadot-sdk\ncd polkadot-sdk\ncargo build --release\n</code></pre> <p>Compiling the binary may take an hour or more, depending on your machine's specs. After building the Polkadot node from the source, the executable binary will be located in the <code>./target/release/polkadot</code> directory.</p> Linux (snap package) <p>Polkadot can be installed as a snap package. If you don't already have Snap installed, take the following steps to install it:</p> <pre><code>sudo apt update\nsudo apt install snapd\n</code></pre> <p>Install the Polkadot snap package:</p> <pre><code>sudo snap install polkadot\n</code></pre> <p>Before continuing on with the following instructions, check out the Configure and Run Your Node section to learn more about the configuration options.</p> <p>To configure your Polkadot node with your desired options, you'll run a command similar to the following:</p> <pre><code>sudo snap set polkadot service-args=\"--name=MyName --chain=polkadot\"\n</code></pre> <p>Then to start the node service, run:</p> <pre><code>sudo snap start polkadot\n</code></pre> <p>You can review the logs to check on the status of the node: </p> <pre><code>snap logs polkadot -f\n</code></pre> <p>And at any time, you can stop the node service:</p> <pre><code>sudo snap stop polkadot\n</code></pre> <p>You can optionally prevent the service from stopping when snap is updated with the following command:</p> <pre><code>sudo snap set polkadot endure=true\n</code></pre>"},{"location":"infrastructure/running-a-node/setup-full-node/#use-docker","title":"Use Docker","text":"<p>As an additional option, you can use Docker to run your node in a container. Doing this is more advanced, so it's best left up to those already familiar with Docker or who have completed the other set-up instructions in this guide. You can review the latest versions on DockerHub.</p> <p>Be aware that when you run Polkadot in Docker, the process only listens on <code>localhost</code> by default. If you would like to connect to your node's services (RPC and Prometheus) you need to ensure that you run the node with the <code>--rpc-external</code>, and <code>--prometheus-external</code> commands.</p> <pre><code>docker run -p 9944:9944 -p 9615:9615 parity/polkadot:v1.16.2 --name \"my-polkadot-node-calling-home\" --rpc-external --prometheus-external\n</code></pre> <p>If you're running Docker on an Apple Silicon machine (e.g. M4), you'll need to adapt the command slightly:</p> <pre><code>docker run --platform linux/amd64 -p 9944:9944 -p 9615:9615 parity/polkadot:v1.16.2 --name \"kearsarge-calling-home\" --rpc-external --prometheus-external\n</code></pre>"},{"location":"infrastructure/running-a-node/setup-full-node/#configure-and-run-your-node","title":"Configure and Run Your Node","text":"<p>Now that you've installed and built the Polkadot binary, the next step is to configure the start-up command depending on the type of node that you want to run. You'll need to modify the start-up command accordingly based on the location of the binary. In some cases, it may be located within the\u00a0<code>./target/release/</code>\u00a0folder, so you'll need to replace\u00a0polkadot\u00a0with\u00a0<code>./target/release/polkadot</code>\u00a0in the following commands.</p> <p>Also, note that you can use the same binary for Polkadot as you would for Kusama or any other relay chain. You'll need to use the\u00a0<code>--chain</code>\u00a0flag to differentiate between chains.</p> <p>Note</p> <p>Not sure which type of node to run? Explore an overview of the different node types.</p> <p>The base commands for running a Polkadot node are as follows:</p> Default pruned nodeCustom pruned nodeArchive node <p>This uses the default pruning value of the last 256 blocks:</p> <pre><code>polkadot --chain polkadot \\\n--name \"INSERT_NODE_NAME\"\n</code></pre> <p>You can customize the pruning value, for example, to the last 1000 finalized blocks:</p> <pre><code>polkadot --chain polkadot \\\n--name INSERT_YOUR_NODE_NAME \\\n--state-pruning 1000 \\\n--blocks-pruning archive \\\n--rpc-cors all \\\n--rpc-methods safe\n</code></pre> <p>To support the full state, use the <code>archive</code> option:</p> <pre><code>polkadot --chain polkadot \\\n--name INSERT_YOUR_NODE_NAME \\\n--state-pruning archive \\\n--blocks-pruning archive \\\n</code></pre> <p>If you want to run an RPC node, please refer to the following RPC Configurations section.</p> <p>To review a complete list of the available commands, flags, and options, you can use the <code>--help</code> flag:</p> <pre><code>polkadot --help\n</code></pre> <p>Once you've fully configured your start-up command, you can execute it in your terminal and your node will start syncing.</p>"},{"location":"infrastructure/running-a-node/setup-full-node/#rpc-configurations","title":"RPC Configurations","text":"<p>The node startup settings allow you to choose what to expose, how many connections to expose, and which systems should be granted access through the RPC server.</p> <ul> <li>You can limit the methods to use with <code>--rpc-methods</code>; an easy way to set this to a safe mode is <code>--rpc-methods safe</code></li> <li>You can set your maximum connections through <code>--rpc-max-connections</code>, for example, <code>--rpc-max-connections 200</code></li> <li>By default, localhost and Polkadot.js can access the RPC server. You can change this by setting <code>--rpc-cors</code>. To allow access from everywhere, you can use <code>--rpc-cors all</code></li> </ul> <p>For a list of important flags when running RPC nodes, refer to the Parity DevOps documentation: Important Flags for Running an RPC Node.</p>"},{"location":"infrastructure/running-a-node/setup-full-node/#sync-your-node","title":"Sync Your Node","text":"<p>The syncing process will take a while, depending on your capacity, processing power, disk speed, and RAM. The process may be completed on a $10 DigitalOcean droplet in about ~36 hours. While syncing, your node name should be visible in gray on Polkadot Telemetry, and once it is fully synced, your node name will appear in white on\u00a0Polkadot Telemetry.</p> <p>A healthy node syncing blocks will output logs like the following:</p> 2024-11-19 23:49:57 Parity Polkadot 2024-11-19 23:49:57 \u270c\ufe0f version 1.14.1-7c4cd60da6d 2024-11-19 23:49:57 \u2764\ufe0f by Parity Technologies &lt;admin@parity.io&gt;, 2017-2024 2024-11-19 23:49:57 \ud83d\udccb Chain specification: Polkadot 2024-11-19 23:49:57 \ud83c\udff7 Node name: myPolkadotNode 2024-11-19 23:49:57 \ud83d\udc64 Role: FULL 2024-11-19 23:49:57 \ud83d\udcbe Database: RocksDb at /home/ubuntu/.local/share/polkadot/chains/polkadot/db/full 2024-11-19 23:50:00 \ud83c\udff7 Local node identity is: 12D3KooWDmhHEgPRJUJnUpJ4TFWn28EENqvKWH4dZGCN9TS51y9h 2024-11-19 23:50:00 Running libp2p network backend 2024-11-19 23:50:00 \ud83d\udcbb Operating system: linux 2024-11-19 23:50:00 \ud83d\udcbb CPU architecture: x86_64 2024-11-19 23:50:00 \ud83d\udcbb Target environment: gnu 2024-11-19 23:50:00 \ud83d\udcbb CPU: Intel(R) Xeon(R) CPU E3-1245 V2 @ 3.40GHz 2024-11-19 23:50:00 \ud83d\udcbb CPU cores: 4 2024-11-19 23:50:00 \ud83d\udcbb Memory: 32001MB 2024-11-19 23:50:00 \ud83d\udcbb Kernel: 5.15.0-113-generic 2024-11-19 23:50:00 \ud83d\udcbb Linux distribution: Ubuntu 22.04.5 LTS 2024-11-19 23:50:00 \ud83d\udcbb Virtual machine: no 2024-11-19 23:50:00 \ud83d\udce6 Highest known block at #9319 2024-11-19 23:50:00 \u303d\ufe0f Prometheus exporter started at 127.0.0.1:9615 2024-11-19 23:50:00 Running JSON-RPC server: addr=127.0.0.1:9944, allowed origins=[\"http://localhost:*\", \"http://127.0.0.1:*\", \"https://localhost:*\", \"https://127.0.0.1:*\", \"https://polkadot.js.org\"] 2024-11-19 23:50:00 \ud83c\udfc1 CPU score: 671.67 MiBs 2024-11-19 23:50:00 \ud83c\udfc1 Memory score: 7.96 GiBs 2024-11-19 23:50:00 \ud83c\udfc1 Disk score (seq. writes): 377.87 MiBs 2024-11-19 23:50:00 \ud83c\udfc1 Disk score (rand. writes): 147.92 MiBs 2024-11-19 23:50:00 \ud83e\udd69 BEEFY gadget waiting for BEEFY pallet to become available... 2024-11-19 23:50:00 \ud83d\udd0d Discovered new external address for our node: /ip4/37.187.93.17/tcp/30333/ws/p2p/12D3KooWDmhHEgPRJUJnUpJ4TFWn28EENqvKWH4dZGCN9TS51y9h 2024-11-19 23:50:01 \ud83d\udd0d Discovered new external address for our node: /ip6/2001:41d0:a:3511::1/tcp/30333/ws/p2p/12D3KooWDmhHEgPRJUJnUpJ4TFWn28EENqvKWH4dZGCN9TS51y9h 2024-11-19 23:50:05 \u2699\ufe0f Syncing, target=#23486325 (5 peers), best: #12262 (0x8fb5\u2026f310), finalized #11776 (0x9de1\u202632fb), \u2b07 430.5kiB/s \u2b06 17.8kiB/s 2024-11-19 23:50:10 \u2699\ufe0f Syncing 628.8 bps, target=#23486326 (6 peers), best: #15406 (0x9ce1\u20262d76), finalized #15360 (0x0e41\u2026a064), \u2b07 255.0kiB/s \u2b06 1.8kiB/s <p>Congratulations, you're now syncing a Polkadot full node! Remember that the process is identical when using any other Polkadot SDK-based chain, although individual chains may have chain-specific flag requirements.</p>"},{"location":"infrastructure/running-a-node/setup-full-node/#connect-to-your-node","title":"Connect to Your Node","text":"<p>Open Polkadot.js Apps and click the logo in the top left to switch the node. Activate the Development toggle and input your node's domain or IP address. The default WSS endpoint for a local node is:</p> <pre><code>ws://127.0.0.1:9944\n</code></pre>"},{"location":"infrastructure/running-a-validator/","title":"Running a Validator","text":"<p>Running a Polkadot validator is crucial for securing the network and maintaining its integrity. Validators play a key role in verifying parachain blocks, participating in consensus, and ensuring the reliability of the Polkadot relay chain.</p> <p>Learn the requirements for setting up a Polkadot validator node, along with detailed steps on how to install, run, upgrade, and maintain the node.</p>"},{"location":"infrastructure/running-a-validator/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"infrastructure/running-a-validator/#additional-resources","title":"Additional ResourcesLearn About Securing the NetworkExplore Rewards, Offenses, and SlashesCheck Out the Decentralized Nodes ProgramGet Help and Connect With Experts","text":"<p>Get a better understanding of Polkadot's trust model for parachains and the relay chain, including security mechanisms and how Polkadot ensures decentralization.</p> <p>Learn about Polkadot's offenses and slashing system, along with validator rewards, era points, and nominator payments.</p> <p>The Decentralized Nodes program aims to support Polkadot's security and decentralization by involving a diverse set of validators. Learn more and apply.</p> <p>For help, connect with the Polkadot Validator Lounge on Element, where both the team and experienced validators are ready to assist.</p>"},{"location":"infrastructure/running-a-validator/requirements/","title":"Validator Requirements","text":""},{"location":"infrastructure/running-a-validator/requirements/#introduction","title":"Introduction","text":"<p>Running a validator in the Polkadot ecosystem is essential for maintaining network security and decentralization. Validators are responsible for validating transactions and adding new blocks to the chain, ensuring the system operates smoothly. In return for their services, validators earn rewards. However, the role comes with inherent risks, such as slashing penalties for misbehavior or technical failures. If you\u2019re new to validation, starting on Kusama provides a lower-stakes environment to gain valuable experience before progressing to the Polkadot network.</p> <p>This guide covers everything you need to know about becoming a validator, including system requirements, staking prerequisites, and infrastructure setup. Whether you\u2019re deploying on a VPS or running your node on custom hardware, you\u2019ll learn how to optimize your validator for performance and security, ensuring compliance with network standards while minimizing risks.</p>"},{"location":"infrastructure/running-a-validator/requirements/#prerequisites","title":"Prerequisites","text":"<p>Running a validator requires solid system administration skills and a secure, well-maintained infrastructure. Below are the primary requirements you need to be aware of before getting started:</p> <ul> <li>System administration expertise - handling technical anomalies and maintaining node infrastructure is critical. Validators must be able to troubleshoot and optimize their setup</li> <li>Security - ensure your setup follows best practices for securing your node. Refer to the Secure Your Validator section to learn about important security measures</li> <li>Network choice - start with Kusama to gain experience. Look for \"Adjustments for Kusama\" throughout these guides for tips on adapting the provided instructions for the Kusama network</li> <li>Staking requirements - a minimum amount of native token (KSM or DOT) is required to be elected into the validator set. The required stake can come from your own holdings or from nominators</li> <li>Risk of slashing - any DOT you stake is at risk if your setup fails or your validator misbehaves. If you\u2019re unsure of your ability to maintain a reliable validator, consider nominating your DOT to a trusted validator</li> </ul>"},{"location":"infrastructure/running-a-validator/requirements/#technical-requirements","title":"Technical Requirements","text":"<p>Running a Polkadot validator node on Linux is the most common approach, especially for beginners. While you can use any VPS provider that meets the technical specifications, this guide uses Ubuntu 22.04. However, the steps should be adaptable to other Linux distributions.</p>"},{"location":"infrastructure/running-a-validator/requirements/#reference-hardware","title":"Reference Hardware","text":"<p>Polkadot validators rely on high-performance hardware to process blocks efficiently. The following specifications are based on benchmarking using two VM instances:</p> <ul> <li>Google Cloud Platform (GCP) - <code>n2-standard-8</code> instance</li> <li>Amazon Web Services (AWS) - <code>c6i.4xlarge</code> instance</li> </ul> <p>The recommended minimum hardware requirements to ensure a fully functional and performant validator are as follows:</p> <ul> <li> <p>CPU:</p> <ul> <li>x86-64 compatible</li> <li>Eight physical cores @ 3.4 GHz<ul> <li>Per Referenda #1051, this will be a hard requirement as of January 2025</li> </ul> </li> <li>Processor:<ul> <li>Intel - Ice Lake or newer (Xeon or Core series)</li> <li>AMD - Zen3 or newer (EPYC or Ryzen)</li> </ul> </li> <li>Simultaneous multithreading disabled:<ul> <li>Intel - Hyper-Threading</li> <li>AMD - SMT</li> </ul> </li> <li>Single-threaded performance is prioritized over higher cores count</li> </ul> </li> <li> <p>Storage:</p> <ul> <li>NVMe SSD - at least 1 TB for blockchain data (prioritize latency rather than throughput)</li> <li>Storage requirements will increase as the chain grows. For current estimates, see the current chain snapshot</li> </ul> </li> <li> <p>Memory:</p> <ul> <li>32 GB DDR4 ECC</li> </ul> </li> <li> <p>System:</p> <ul> <li>Linux Kernel 5.16 or newer</li> </ul> </li> <li> <p>Network:</p> <ul> <li>Symmetric networking speed of 500 Mbit/s is required to handle large numbers of parachains and ensure congestion control during peak times</li> </ul> </li> </ul> <p>While the hardware specs above are best practices and not strict requirements, subpar hardware may lead to performance issues and increase the risk of slashing.</p>"},{"location":"infrastructure/running-a-validator/requirements/#vps-provider-list","title":"VPS Provider List","text":"<p>When selecting a VPS provider for your validator node, prioritize reliability, consistent performance, and adherence to the specific hardware requirements set for Polkadot validators. The following server types have been tested and showed acceptable performance in benchmark tests. However, this is not an endorsement and actual performance may vary depending on your workload and VPS provider.</p> <ul> <li>Google Cloud Platform (GCP) - <code>c2</code> and <code>c2d</code> machine families offer high-performance configurations suitable for validators</li> <li>Amazon Web Services (AWS) - <code>c6id</code> machine family provides strong performance, particularly for I/O-intensive workloads</li> <li>OVH - can be a budget-friendly solution if it meets your minimum hardware specifications</li> <li>Digital Ocean - popular among developers, Digital Ocean's premium droplets offer configurations suitable for medium to high-intensity workloads</li> <li>Vultr - offers flexibility with plans that may meet validator requirements, especially for high-bandwidth needs</li> <li>Linode - provides detailed documentation, which can be helpful for setup</li> <li>Scaleway - offers high-performance cloud instances that can be suitable for validator nodes</li> <li>OnFinality - specialized in blockchain infrastructure, OnFinality provides validator-specific support and configurations</li> </ul> Acceptable use policies <p>Different VPS providers have varying acceptable use policies, and not all allow cryptocurrency-related activities. </p> <p>For example, Digital Ocean, requires explicit permission to use servers for cryptocurrency mining and defines unauthorized mining as network abuse in their acceptable use policy. </p> <p>Review the terms for your VPS provider to avoid account suspension or server shutdown due to policy violations.</p>"},{"location":"infrastructure/running-a-validator/requirements/#minimum-bond-requirement","title":"Minimum Bond Requirement","text":"<p>Before bonding DOT, ensure you meet the minimum bond requirement to start a validator instance. The minimum bond is the least DOT you need to stake to enter the validator set. To become eligible for rewards, your validator node must be nominated by enough staked tokens.</p> <p>For example, on November 19, 2024, the minimum stake backing a validator in Polkadot's era 1632 was 1,159,434.248 DOT. You can check the current minimum stake required using these tools:</p> <ul> <li>Chain State Values</li> <li>Subscan</li> <li>Staking Dashboard</li> </ul>"},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/","title":"Onboarding and Offboarding","text":"<p>Successfully onboarding and offboarding a Polkadot validator node is crucial to maintaining the security and integrity of the network. This process involves setting up, activating, deactivating, and securely managing your validator\u2019s key and staking details.</p> <p>This section provides guidance on how to set up, activate, and deactivate your validator.</p>"},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/#additional-resources","title":"Additional ResourcesReview the RequirementsLearn About Staking MechanicsMaintain Your NodeGet Help and Connect With Experts","text":"<p>Explore the technical and system requirements for running a Polkadot validator, including setup, hardware, staking prerequisites, and security best practices.</p> <p>Explore the staking mechanics in Polkadot, focusing on how they relate to validators, including offenses and slashes, as well as reward payouts.</p> <p>Learn how to manage your Polkadot validator node, including monitoring performance, running a backup validator for maintenance, and rotating keys.</p> <p>For help, connect with the Polkadot Validator Lounge on Element, where both the team and experienced validators are ready to assist.</p>"},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/set-up-validator/","title":"Set Up a Validator","text":""},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/set-up-validator/#introduction","title":"Introduction","text":"<p>Setting up a Polkadot validator node is essential for securing the network and earning staking rewards. This guide walks you through the technical steps to set up a validator, from installing the necessary software to managing keys and synchronizing your node with the chain.</p> <p>Running a validator requires a commitment to maintaining a stable, secure infrastructure. Validators are responsible for their own stakes and those of nominators who trust them with their tokens. Proper setup and ongoing management are critical to ensuring smooth operation and avoiding potential penalties such as slashing.</p>"},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/set-up-validator/#prerequisites","title":"Prerequisites","text":"<p>To get the most from this guide, ensure you've done the following before going forward:</p> <ul> <li>Read Validator Requirements and understand the recommended minimum skill level and hardware needs</li> <li>Read General Management, Upgrade Your Node, and Pause Validating and understand the tasks required to keep your validator operational</li> <li>Read Rewards Payout and understand how validator rewards are determined and paid out</li> <li>Read Offenses and Slashes and understand how validator performance and security can affect tokens staked by you or your nominators</li> </ul>"},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/set-up-validator/#initial-setup","title":"Initial Setup","text":"<p>Before you can begin running your validator, you'll need to configure your server environment to meet the operational and security standards required for validating. Configuration includes setting up time synchronization, ensuring critical security features are active, and installing the necessary binaries. Proper setup at this stage is essential to prevent issues like block production errors or being penalized for downtime. Below are the essential steps to get your system ready.</p>"},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/set-up-validator/#install-network-time-protocol-client","title":"Install Network Time Protocol Client","text":"<p>Accurate timekeeping is critical to ensure your validator is synchronized with the network. Validators need local clocks in sync with the blockchain to avoid missing block authorship opportunities. Using Network Time Protocol (NTP) is the standard solution to keep your system's clock accurate.</p> <p>If you are using Ubuntu version 18.04 or newer, the NTP Client should be installed by default. You can check whether you have the NTP client by running:</p> <pre><code>timedatectl\n</code></pre> <p>If NTP is running, you should see a message like the following:</p> <pre><code>System clock synchronized: yes\n</code></pre> <p>If NTP is not installed or running, you can install it using:</p> <pre><code>sudo apt-get install ntp\n</code></pre> <p>After installation, NTP will automatically start. To check its status:</p> <pre><code>sudo ntpq -p\n</code></pre> <p>This command will return a message with the status of the NTP synchronization. Skipping this step could result in your validator node missing blocks due to minor clock drift, potentially affecting its network performance.</p>"},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/set-up-validator/#verify-landlock-is-activated","title":"Verify Landlock is Activated","text":"<p>Landlock is an important security feature integrated into Linux kernels starting with version 5.13. It allows processes, even those without special privileges, to limit their access to the system to reduce the machine's attack surface. This feature is crucial for validators, as it helps ensure the security and stability of the node by preventing unauthorized access or malicious behavior.</p> <p>To use Landlock, ensure you use the reference kernel or newer versions. Most Linux distributions should already have Landlock activated. You can check if Landlock is activated on your machine by running the following command as root:</p> <pre><code>dmesg | grep landlock || journalctl -kg landlock\n</code></pre> <p>If Landlock is not activated, your system logs won't show any related output. In this case, you will need to activate it manually or ensure that your Linux distribution supports it. Most modern distributions with the required kernel version should have Landlock activated by default. However, if your system lacks support, you may need to build the kernel with Landlock activated. For more information on doing so, refer to the official kernel documentation.</p> <p>Implementing Landlock ensures your node operates in a restricted, self-imposed sandbox, limiting potential damage from security breaches or bugs. While not a mandatory requirement, enabling this feature greatly improves the security of your validator setup.</p>"},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/set-up-validator/#install-the-polkadot-binaries","title":"Install the Polkadot Binaries","text":"<p>You must install the Polkadot binaries required to run your validator node. These binaries include the main <code>polkadot</code>, <code>polkadot-prepare-worker</code>, and <code>polkadot-execute-worker</code> binaries. All three are needed to run a fully functioning validator node.</p> <p>Depending on your preference and operating system setup, there are multiple methods to install these binaries. Below are the main options:</p>"},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/set-up-validator/#install-from-official-releases","title":"Install from Official Releases","text":"<p>The preferred, most straightforward method to install the required binaries is downloading the latest versions from the official releases. You can visit the Github Releases page for the most current versions of the <code>polkadot</code>, <code>polkadot-prepare-worker</code>, and <code>polkadot-execute-worker</code> binaries.</p> <p>You can also download the binaries by using the following direct links and replacing <code>INSERT_VERSION_NUMBER</code> with the version number, e.g. <code>v1.16.1</code></p> <code>polkadot</code><code>polkadot-prepare-worker</code><code>polkadot-execute-worker</code> <pre><code>https://github.com/paritytech/polkadot-sdk/releases/download/polkadot-INSERT_VERSION_NUMBER/polkadot\n</code></pre> <pre><code>https://github.com/paritytech/polkadot-sdk/releases/download/polkadot-INSERT_VERSION_NUMBER/polkadot-prepare-worker\n</code></pre> <pre><code>https://github.com/paritytech/polkadot-sdk/releases/download/polkadot-INSERT_VERSION_NUMBER/polkadot-execute-worker\n</code></pre>"},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/set-up-validator/#install-with-package-managers","title":"Install with Package Managers","text":"<p>Users running Debian-based distributions like Ubuntu, or RPM-based distributions such as Fedora or CentOS can install the binaries via package managers.</p> Debian-based (Debian, Ubuntu) <p>Run the following commands as the root user to add the necessary repository and install the binaries:</p> <pre><code># Import the security@parity.io GPG key\ngpg --recv-keys --keyserver hkps://keys.mailvelope.com 9D4B2B6EB8F97156D19669A9FF0812D491B96798\ngpg --export 9D4B2B6EB8F97156D19669A9FF0812D491B96798 &gt; /usr/share/keyrings/parity.gpg\n# Add the Parity repository and update the package index\necho 'deb [signed-by=/usr/share/keyrings/parity.gpg] https://releases.parity.io/deb release main' &gt; /etc/apt/sources.list.d/parity.list\napt update\n# Install the `parity-keyring` package - This will ensure the GPG key\n# used by APT remains up-to-date\napt install parity-keyring\n# Install polkadot\napt install polkadot\n</code></pre> <p>After installation, ensure the binaries are properly installed by verifying the installation.</p> RPM-based (Fedora, CentOS)\" <p>Run the following commands as the root user to install the binaries on an RPM-based system:</p> <pre><code># Install dnf-plugins-core (This might already be installed)\ndnf install dnf-plugins-core\n# Add the repository and activate it\ndnf config-manager --add-repo https://releases.parity.io/rpm/polkadot.repo\ndnf config-manager --set-enabled polkadot\n# Install polkadot (You may have to confirm the import of the GPG key, which\n# should have the following fingerprint: 9D4B2B6EB8F97156D19669A9FF0812D491B96798)\ndnf install polkadot\n</code></pre> <p>After installation, ensure the binaries are properly installed by verifying the installation.</p>"},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/set-up-validator/#install-with-ansible","title":"Install with Ansible","text":"<p>You can also manage Polkadot installations using Ansible. This approach can be beneficial for users managing multiple validator nodes or requiring automated deployment. The Parity chain operations Ansible collection provides a Substrate node role for this purpose.</p>"},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/set-up-validator/#install-with-docker","title":"Install with Docker","text":"<p>If you prefer using Docker or an OCI-compatible container runtime, the official Polkadot Docker image can be pulled directly from Docker Hub.</p> <p>To pull the latest image, run the following command. Make sure to replace <code>INSERT_VERSION_NUMBER</code> with the appropriate version number, e.g. <code>v1.16.1</code></p> <pre><code>docker.io/parity/polkadot:INSERT_VERSION_NUMBER\n</code></pre>"},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/set-up-validator/#build-from-sources","title":"Build from Sources","text":"<p>You may build the binaries from source by following the instructions on the Polkadot SDK repository.</p>"},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/set-up-validator/#verify-installation","title":"Verify Installation","text":"<p>Once the Polkadot binaries are installed, it's essential to verify that everything is set up correctly and that all the necessary components are in place. Follow these steps to ensure the binaries are installed and functioning as expected.</p> <ol> <li> <p>Check the versions - run the following commands to verify the versions of the installed binaries:</p> <pre><code>polkadot --version\npolkadot-execute-worker --version\npolkadot-prepare-worker --version\n</code></pre> <p>The output should show the version numbers for each of the binaries. Ensure that the versions match and are consistent, similar to the following example (the specific version may vary):</p> <p>If the versions do not match or if there is an error, double-check that all the binaries were correctly installed and are accessible within your <code>$PATH</code>.</p> </li> <li> <p>Ensure all binaries are in the same directory - all the binaries must be in the same directory for the Polkadot validator node to function properly. If the binaries are not in the same location, move them to a unified directory and ensure this directory is added to your system's <code>$PATH</code></p> <p>To verify the <code>$PATH</code>, run the following command:</p> <pre><code>echo $PATH\n</code></pre> <p>If necessary, you can move the binaries to a shared location, such as <code>/usr/local/bin/</code>, and add it to your <code>$PATH</code>.</p> </li> </ol>"},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/set-up-validator/#run-a-validator-on-a-testnet","title":"Run a Validator on a TestNet","text":"<p>Running your validator on a test network like Westend or Kusama is a smart way to familiarize yourself with the process and identify any setup issues in a lower-stakes environment before joining the Polkadot MainNet.</p>"},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/set-up-validator/#choose-a-network","title":"Choose a Network","text":"<ul> <li>Westend - Polkadot's primary TestNet is open to anyone for testing purposes. Validator slots are intentionally limited to keep the network stable for the Polkadot release process, so it may not support as many validators at any given time</li> <li>Kusama - often called Polkadot's \u201ccanary network,\u201d Kusama has real economic value but operates with a faster and more experimental approach. Running a validator here provides an experience closer to MainNet with the benefit of more frequent validation opportunities with an era time of 6 hours vs 24 hours for Polkadot</li> </ul>"},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/set-up-validator/#synchronize-chain-data","title":"Synchronize Chain Data","text":"<p>After successfully installing and verifying the Polkadot binaries, the next step is to sync your node with the blockchain network. Synchronization is necessary to download and validate the blockchain data, ensuring your node is ready to participate as a validator. Follow these steps to sync your node:</p> <ol> <li> <p>Start syncing - you can run a full or warp sync</p> Full syncWarp sync <p>Polkadot defaults to using a full sync, which downloads and validates the entire blockchain history from the genesis block. Start the syncing process by running the following command:</p> <pre><code>polkadot\n</code></pre> <p>This command starts your Polkadot node in non-validator mode, allowing you to synchronize the chain data.</p> <p>You can opt to use warp sync which initially downloads only GRANDPA finality proofs and the latest finalized block's state. Use the following command to start a warp sync:</p> <pre><code>polkadot --sync warp\n</code></pre> <p>Warp sync ensures that your node quickly updates to the latest finalized state. The historical blocks are downloaded in the background as the node continues to operate.</p> Adjustments for TestNets <p>If you're planning to run a validator on a TetNet, you can specify the chain using the <code>--chain</code> flag. For example, the following will run a validator on Kusama:</p> <pre><code>polkadot --chain=kusama\n</code></pre> </li> <li> <p>Monitor sync progress - once the sync starts, you will see a stream of logs providing information about the node's status and progress. Here's an example of what the output might look like:</p> <p> polkadot 2021-06-17 03:07:07 Parity Polkadot 2021-06-17 03:07:07 \u270c\ufe0f version 0.9.5-95f6aa201-x86_64-linux-gnu 2021-06-17 03:07:07 \u2764\ufe0f by Parity Technologies &lt;admin@parity.io&gt;, 2017-2021 2021-06-17 03:07:07 \ud83d\udccb Chain specification: Polkadot 2021-06-17 03:07:07 \ud83c\udff7 Node name: boiling-pet-7554 2021-06-17 03:07:07 \ud83d\udc64 Role: FULL 2021-06-17 03:07:07 \ud83d\udcbe Database: RocksDb at /root/.local/share/polkadot/chains/polkadot/db 2021-06-17 03:07:07 \u26d3 Native runtime: polkadot-9050 (parity-polkadot-0.tx7.au0) 2021-06-17 03:07:10 \ud83c\udff7 Local node identity is: 12D3KooWLtXFWf1oGrnxMGmPKPW54xWCHAXHbFh4Eap6KXmxoi9u 2021-06-17 03:07:10 \ud83d\udce6 Highest known block at #17914 2021-06-17 03:07:10 \u303d\ufe0f Prometheus server started at 127.0.0.1:9615 2021-06-17 03:07:10 Listening for new connections on 127.0.0.1:9944 ... </p> <p>The output logs provide information such as the current block number, node name, and network connections. Monitor the sync progress and any errors that might occur during the process. Look for information about the latest processed block and compare it with the current highest block using tools like Telemetry or Polkadot.js Apps Explorer.</p> </li> </ol>"},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/set-up-validator/#database-snapshot-services","title":"Database Snapshot Services","text":"<p>If you'd like to speed up the process further, you can use a database snapshot. Snapshots are compressed backups of the blockchain's database directory and can significantly reduce the time required to sync a new node. Here are a few public snapshot providers:</p> <ul> <li>Stakeworld</li> <li>Polkachu</li> <li>Polkashots</li> </ul> <p>Warning</p> <p>Although snapshots are convenient, syncing from scratch is recommended for security purposes. If snapshots become corrupted and most nodes rely on them, the network could inadvertently run on a non-canonical chain.</p> Why am I unable to synchronize the chain with 0 peers? <p>Make sure you have libp2p port <code>30333</code> activated. It will take some time to discover other peers over the network.</p> <p></p>"},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/set-up-validator/#bond-dot","title":"Bond DOT","text":"<p>Once your validator node is synced, the next step is bonding DOT. A bonded account, or stash, holds your staked tokens (DOT) that back your validator node. Bonding your DOT means locking it for a period, during which it cannot be transferred or spent but is used to secure your validator's role in the network. Visit the Minimum Bond Requirement section for details on how much DOT is required.</p> <p>The following sections will guide you through bonding DOT for your validator.</p>"},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/set-up-validator/#bonding-dot-on-polkadotjs-apps","title":"Bonding DOT on Polkadot.js Apps","text":"<p>Once you're ready to bond your DOT, head over to the Polkadot.js Apps staking page by clicking the Network dropdown at the top of the page and selecting Staking.</p> <p>To get started with the bond submission, click on the Accounts tab, then the + Stash button, and then enter the following information:</p> <ol> <li>Stash account - select your stash account (which is the account with the DOT/KSM balance)</li> <li>Value bonded - enter how much DOT from the stash account you want to bond/stake. You are not required to bond all of the DOT in that account and you may bond more DOT at a later time. Be aware, withdrawing any bonded amount requires waiting for the unbonding period. The unbonding period is seven days for Kusama and 28 days for Polkadot</li> <li>Payment destination - add the recipient account for validator rewards. If you'd like to redirect payments to an account that is not the stash account, you can do it by entering the address here. Note that it is extremely unsafe to set an exchange address as the recipient of the staking rewards</li> </ol> <p>Once everything is filled in properly, select Bond and sign the transaction with your stash account. If successful, you should see an <code>ExtrinsicSuccess</code> message.</p> <p>Your bonded account will be available under Stashes. After refreshing the screen, you should now see a card with all your accounts. The bonded amount on the right corresponds to the funds bonded by the stash account.</p>"},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/set-up-validator/#set-session-keys","title":"Set Session Keys","text":"<p>Setting up your validator's session keys is essential to associate your node with your stash account on the Polkadot network. Validators use session keys to participate in the consensus process. Your validator can only perform its role in the network by properly setting session keys which consist of several key pairs for different parts of the protocol (e.g., GRANDPA, BABE). These keys must be registered on-chain and associated with your validator node to ensure it can participate in validating blocks.</p> <p>The following sections will cover generating session keys, submitting key data on-chain, and verifying that session keys are correctly set.</p>"},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/set-up-validator/#generate-session-keys","title":"Generate Session Keys","text":"<p>The Polkadot.js Apps UI and the CLI are the two primary methods used to generate session keys.</p> Use Polkadot.js Apps UIUse the CLI <ol> <li>Ensure that you are connected to your validator node through the Polkadot.js Apps interface</li> <li>In the Toolbox tab, navigate to RPC calls</li> <li>Select <code>author_rotateKeys</code> from the drop-down menu and run the command. This will generate new session keys in your node's keystore and return the result as a hex-encoded string</li> <li>Copy and save this hex-encoded output for the next step</li> </ol> <p>Generate session keys by running the following command on your validator node:</p> <pre><code>curl -H \"Content-Type: application/json\" \\\n-d '{\"id\":1, \"jsonrpc\":\"2.0\", \"method\": \"author_rotateKeys\", \"params\":[]}' \\\nhttp://localhost:9944\n</code></pre> <p>This command will return a hex-encoded string that is the concatenation of your session keys. Save this string for later use.</p>"},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/set-up-validator/#submit-transaction-to-set-keys","title":"Submit Transaction to Set Keys","text":"<p>Now that you have generated your session keys, you must submit them to the chain. Follow these steps:</p> <ol> <li>Go to the Network &gt; Staking &gt; Accounts section on Polkadot.js Apps</li> <li>Select Set Session Key on the bonding account you generated earlier</li> <li>Paste the hex-encoded session key string you generated (from either the UI or CLI) into the input field and submit the transaction</li> </ol> <p></p> <p>Once the transaction is signed and submitted, your session keys will be registered on-chain.</p>"},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/set-up-validator/#verify-session-key-setup","title":"Verify Session Key Setup","text":"<p>To verify that your session keys are properly set, you can use one of two RPC calls:</p> <ul> <li><code>hasKey</code> - checks if the node has a specific key by public key and key type</li> <li><code>hasSessionKeys</code> - verifies if your node has the full session key string associated with the validator</li> </ul> <p>For example, you can check session keys on the Polkadot.js Apps interface or by running an RPC query against your node. Once this is done, your validator node is ready for its role.</p>"},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/set-up-validator/#set-the-node-key","title":"Set the Node Key","text":"<p>Validators on Polkadot need a static network key (also known as the node key) to maintain a stable node identity. This key ensures that your validator can maintain a consistent peer ID, even across restarts, which is crucial for maintaining reliable network connections.</p> <p>Starting with Polkadot version 1.11, validators without a stable network key may encounter the following error on startup:</p> polkadot --validator --name \"INSERT_NAME_FROM_TELEMETRY\" Error: 0: Starting an authority without network key This is not a safe operation because other authorities in the network may depend on your node having a stable identity. Otherwise these other authorities may not being able to reach you. If it is the first time running your node you could use one of the following methods: 1. [Preferred] Separately generate the key with: INSERT_NODE_BINARY key generate-node-key --base-path INSERT_YOUR_BASE_PATH 2. [Preferred] Separately generate the key with: INSERT_NODE_BINARY key generate-node-key --file INSERT_YOUR_PATH_TO_NODE_KEY 3. [Preferred] Separately generate the key with: INSERT_NODE_BINARY key generate-node-key --default-base-path 4. [Unsafe] Pass --unsafe-force-node-key-generation and make sure you remove it for subsequent node restarts"},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/set-up-validator/#generate-the-node-key","title":"Generate the Node Key","text":"<p>Use one of the following methods to generate your node key:</p> Save to fileUse default path <p>The recommended solution is to generate a node key and save it to a file using the following command:</p> <pre><code>polkadot key generate-node-key --file INSERT_PATH_TO_NODE_KEY\n</code></pre> <p>You can also generate the node key with the following command, which will automatically save the key to the base path of your node:</p> <pre><code>polkadot key generate-node-key --default-base-path\n</code></pre> <p>Save the file path for reference. You will need it in the next step to configure your node with a static identity.</p>"},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/set-up-validator/#set-the-node-key_1","title":"Set the Node Key","text":"<p>After generating the node key, configure your node to use it by specifying the path to the key file when launching your node. Add the following flag to your validator node's startup command:</p> <pre><code>polkadot --node-key-file INSERT_PATH_TO_NODE_KEY\n</code></pre> <p>Following these steps ensures that your node retains its identity, making it discoverable by peers without the risk of conflicting identities across sessions. For further technical background, see Polkadot SDK Pull Request #3852 for the rationale behind requiring static keys.</p>"},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/set-up-validator/#validate","title":"Validate","text":"<p>Once your validator node is fully synced and ready, the next step is to ensure it's visible on the network and performing as expected. Below are steps for monitoring and managing your node on the Polkadot network.</p>"},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/set-up-validator/#verify-sync-via-telemetry","title":"Verify Sync via Telemetry","text":"<p>To confirm that your validator is live and synchronized with the Polkadot network, visit the Telemetry page. Telemetry provides real-time information on node performance and can help you check if your validator is connected properly. Search for your node by name. You can search all nodes currently active on the network, which is why you should use a unique name for easy recognition. Now, confirm that your node is fully synced by comparing the block height of your node with the network's latest block. Nodes that are fully synced will appear white in the list, while nodes that are not yet fully synced will appear gray.</p> <p>In the following example, a node named <code>techedtest</code> is successfully located and synchronized, ensuring it's prepared to participate in the network:</p> <p></p>"},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/set-up-validator/#activate-using-polkadotjs-apps","title":"Activate using Polkadot.js Apps","text":"<p>Follow these steps to use Polkadot.js Apps to activate your validator:</p> <ol> <li> <p>Go to the Validator tab in the Polkadot.js Apps UI and locate the section where you input the keys generated from <code>rotateKeys</code>. Paste the output from <code>author_rotateKeys</code>, which is a hex-encoded key that links your validator with its session keys:</p> <p></p> </li> <li> <p>Set a reward commission percentage if desired. You can set a percentage of the rewards to pay to your validator and the remainder pays to your nominators. A 100% commission rate indicates the validator intends to keep all rewards and is seen as a signal the validator is not seeking nominators</p> </li> <li>Toggle the allows new nominations option if your validator is open to more nominations from DOT holders</li> <li> <p>Once everything is configured, select Bond &amp; Validate to activate your validator status</p> <p></p> </li> </ol>"},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/set-up-validator/#monitor-validation-status-and-slots","title":"Monitor Validation Status and Slots","text":"<p>On the Staking tab in Polkadot.js Apps, you can see your validator's status, the number of available validator slots, and the nodes that have signaled their intent to validate. Your node may initially appear in the waiting queue, especially if the validator slots are full. The following is an example view of the Staking tab:</p> <p></p> <p>The validator set refreshes each era. If there's an available slot in the next era, your node may be selected to move from the waiting queue to the active validator set, allowing it to start validating blocks. If your validator is not selected, it remains in the waiting queue. Increasing your stake or gaining more nominators may improve your chance of being selected in future eras.</p>"},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/set-up-validator/#run-a-validator-using-systemd","title":"Run a Validator Using Systemd","text":"<p>Running your Polkadot validator as a systemd service is an effective way to ensure its high uptime and reliability. Using systemd allows your validator to automatically restart after server reboots or unexpected crashes, significantly reducing the risk of slashing due to downtime.</p> <p>This following sections will walk you through creating and managing a systemd service for your validator, allowing you to seamlessly monitor and control it as part of your Linux system. </p> <p>Ensure the following requirements are met before proceeding with the systemd setup:</p> <ul> <li>Confirm your system meets the requirements for running a validator</li> <li>Ensure you meet the minimum bond requirements for validating</li> <li>Verify the Polkadot binary is installed</li> </ul>"},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/set-up-validator/#create-the-systemd-service-file","title":"Create the Systemd Service File","text":"<p>First create a new unit file called <code>polkadot-validator.service</code> in <code>/etc/systemd/system/</code>:</p> <pre><code>touch /etc/systemd/system/polkadot-validator.service\n</code></pre> <p>In this unit file, you will write the commands that you want to run on server boot/restart:</p> /etc/systemd/system/polkadot-validator.service<pre><code>[Unit]\nDescription=Polkadot Node\nAfter=network.target\nDocumentation=https://github.com/paritytech/polkadot\n\n[Service]\nEnvironmentFile=-/etc/default/polkadot\nExecStart=/usr/bin/polkadot $POLKADOT_CLI_ARGS\nUser=polkadot\nGroup=polkadot\nRestart=always\nRestartSec=120\nCapabilityBoundingSet=\nLockPersonality=true\nNoNewPrivileges=true\nPrivateDevices=true\nPrivateMounts=true\nPrivateTmp=true\nPrivateUsers=true\nProtectClock=true\nProtectControlGroups=true\nProtectHostname=true\nProtectKernelModules=true\nProtectKernelTunables=true\nProtectSystem=strict\nRemoveIPC=true\nRestrictAddressFamilies=AF_INET AF_INET6 AF_NETLINK AF_UNIX\nRestrictNamespaces=false\nRestrictSUIDSGID=true\nSystemCallArchitectures=native\nSystemCallFilter=@system-service\nSystemCallFilter=landlock_add_rule landlock_create_ruleset landlock_restrict_self seccomp mount umount2\nSystemCallFilter=~@clock @module @reboot @swap @privileged\nSystemCallFilter=pivot_root\nUMask=0027\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <p>Restart Delay Recommendation</p> <p>It is recommended that a node's restart be delayed with <code>RestartSec</code> in the case of a crash. It's possible that when a node crashes, consensus votes in GRANDPA aren't persisted to disk. In this case, there is potential to equivocate when immediately restarting. Delaying the restart will allow the network to progress past potentially conflicting votes.</p>"},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/set-up-validator/#run-the-service","title":"Run the Service","text":"<p>Activate the systemd service to start on system boot by running:</p> <pre><code>systemctl enable polkadot-validator.service\n</code></pre> <p>To start the service manually, use:</p> <pre><code>systemctl start polkadot-validator.service\n</code></pre> <p>Check the service's status to confirm it is running:</p> <pre><code>systemctl status polkadot-validator.service\n</code></pre> <p>To view the logs in real-time, use journalctl like so:</p> <pre><code>journalctl -f -u polkadot-validator\n</code></pre> <p>With these steps, you can effectively manage and monitor your validator as a systemd service.</p> <p>Once your validator is active, it's officially part of Polkadot's security infrastructure. For questions or further support, you can reach out to the Polkadot Validator chat for tips and troubleshooting.</p>"},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/stop-validating/","title":"Stop Validating","text":""},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/stop-validating/#introduction","title":"Introduction","text":"<p>If you're ready to stop validating on Polkadot, there are essential steps to ensure a smooth transition while protecting your funds and account integrity. Whether you're taking a break for maintenance or unbonding entirely, you'll need to chill your validator, purge session keys, and unbond your tokens. This guide explains how to use Polkadot's tools and extrinsics to safely withdraw from validation activities, safeguarding your account's future usability.</p>"},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/stop-validating/#pause-versus-stop","title":"Pause Versus Stop","text":"<p>If you wish to remain a validator or nominator (for example, stopping for planned downtime or server maintenance), submitting the <code>chill</code> extrinsic in the <code>staking</code> pallet should suffice. Additional steps are only needed to unbond funds or reap an account.</p> <p>The following are steps to ensure a smooth stop to validation:</p> <ul> <li>Chill the validator</li> <li>Purge validator session keys</li> <li>Unbond your tokens</li> </ul>"},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/stop-validating/#chill-validator","title":"Chill Validator","text":"<p>When stepping back from validating, the first step is to chill your validator status. This action stops your validator from being considered for the next era without fully unbonding your tokens, which can be useful for temporary pauses like maintenance or planned downtime.</p> <p>Use the <code>staking.chill</code> extrinsic to initiate this. For more guidance on chilling your node, refer to the Pause Validating guide. You may also claim any pending staking rewards at this point.</p>"},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/stop-validating/#purge-validator-session-keys","title":"Purge Validator Session Keys","text":"<p>Purging validator session keys is a critical step in removing the association between your validator account and its session keys, which ensures that your account is fully disassociated from validator activities. The <code>session.purgeKeys</code> extrinsic removes the reference to your session keys from the stash or staking proxy account that originally set them.</p> <p>Here are a couple of important things to know about purging keys:</p> <ul> <li>Account used to purge keys - always use the same account to purge keys you originally used to set them, usually your stash or staking proxy account. Using a different account may leave an unremovable reference to the session keys on the original account, preventing its reaping</li> <li>Account reaping issue - failing to purge keys will prevent you from reaping (fully deleting) your stash account. If you attempt to transfer tokens without purging, you'll need to rebond, purge the session keys, unbond again, and wait through the unbonding period before any transfer</li> </ul>"},{"location":"infrastructure/running-a-validator/onboarding-and-offboarding/stop-validating/#unbond-your-tokens","title":"Unbond Your Tokens","text":"<p>After chilling your node and purging session keys, the final step is to unbond your staked tokens. This action removes them from staking and begins the unbonding period (usually 28 days for Polkadot and seven days for Kusama), after which the tokens will be transferable.</p> <p>To unbond tokens, go to Network &gt; Staking &gt; Account Actions on Polkadot.js Apps. Select your stash account, click on the dropdown menu, and choose Unbond Funds. Alternatively, you can use the <code>staking.unbond</code> extrinsic if you handle this via a staking proxy account.</p> <p>Once the unbonding period is complete, your tokens will be available for use in transactions or transfers outside of staking.</p>"},{"location":"infrastructure/running-a-validator/operational-tasks/","title":"Operational Tasks","text":"<p>Running a Polkadot validator node involves several key operational tasks to ensure secure and efficient participation in the network. In this section, you'll learn how to manage and maintain your validator node by monitoring its performance, conducting regular maintenance, and ensuring high availability through strategies like running a backup validator. You'll also find instructions on rotating your session keys to enhance security and minimize vulnerabilities. Mastering these tasks is essential for maintaining a reliable and trusted presence within your network.</p>"},{"location":"infrastructure/running-a-validator/operational-tasks/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"infrastructure/running-a-validator/operational-tasks/#additional-resources","title":"Additional ResourcesAccess Real-Time Validator MetricsStay Up to Date with Runtime Upgrades","text":"<p>Check the Polkadot Telemetry dashboard for real-time insights into node performance, including validator status, connectivity, block production, and software version to identify potential issues.</p> <p>Learn how to monitor the Polkadot network for upcoming upgrades, so you can prepare your validator node for any required updates or modifications.</p>"},{"location":"infrastructure/running-a-validator/operational-tasks/general-management/","title":"General Management","text":""},{"location":"infrastructure/running-a-validator/operational-tasks/general-management/#introduction","title":"Introduction","text":"<p>Validator performance is pivotal in maintaining the security and stability of the Polkadot network. As a validator, optimizing your setup ensures efficient transaction processing, minimizes latency, and maintains system reliability during high-demand periods. Proper configuration and proactive monitoring also help mitigate risks like slashing and service interruptions.</p> <p>This guide covers essential practices for managing a validator, including performance tuning techniques, security hardening, and tools for real-time monitoring. Whether you're fine-tuning CPU settings, configuring NUMA balancing, or setting up a robust alert system, these steps will help you build a resilient and efficient validator operation.</p>"},{"location":"infrastructure/running-a-validator/operational-tasks/general-management/#configuration-optimization","title":"Configuration Optimization","text":"<p>For those seeking to optimize their validator's performance, the following configurations can improve responsiveness, reduce latency, and ensure consistent performance during high-demand periods.</p>"},{"location":"infrastructure/running-a-validator/operational-tasks/general-management/#deactivate-simultaneous-multithreading","title":"Deactivate Simultaneous Multithreading","text":"<p>Polkadot validators operate primarily in single-threaded mode for critical paths, meaning optimizing for single-core CPU performance can reduce latency and improve stability. Deactivating simultaneous multithreading (SMT) can prevent virtual cores from affecting performance. SMT implementation is called Hyper-Threading on Intel and 2-way SMT on AMD Zen. The following will deactivate every other (vCPU) core:</p> <pre><code>for cpunum in $(cat /sys/devices/system/cpu/cpu*/topology/thread_siblings_list | cut -s -d, -f2- | tr ',' '\\n' | sort -un)\ndo\n  echo 0 &gt; /sys/devices/system/cpu/cpu$cpunum/online\ndone\n</code></pre> <p>To save the changes permanently, add <code>nosmt=force</code> as kernel parameter. Edit <code>/etc/default/grub</code> and add <code>nosmt=force</code> to <code>GRUB_CMDLINE_LINUX_DEFAULT</code> variable as follows:</p> <pre><code>sudo nano /etc/default/grub\n# Add to GRUB_CMDLINE_LINUX_DEFAULT\n</code></pre> /etc/default/grub<pre><code>GRUB_HIDDEN_TIMEOUT = 0;\nGRUB_HIDDEN_TIMEOUT_QUIET = true;\nGRUB_TIMEOUT = 10;\nGRUB_DISTRIBUTOR = `lsb_release -i -s 2&gt; /dev/null || echo Debian`;\nGRUB_CMDLINE_LINUX_DEFAULT = 'nosmt=force';\nGRUB_CMDLINE_LINUX = '';\n</code></pre> <p>After updating the variable, be sure to update GRUB to apply changes:</p> <pre><code>sudo update-grub\n</code></pre> <p>After the reboot, you should see that half of the cores are offline. To confirm, run:</p> <pre><code>lscpu --extended\n</code></pre>"},{"location":"infrastructure/running-a-validator/operational-tasks/general-management/#deactivate-automatic-numa-balancing","title":"Deactivate Automatic NUMA Balancing","text":"<p>Deactivating NUMA (Non-Uniform Memory Access) balancing for multi-CPU setups helps keep processes on the same CPU node, minimizing latency. Run the following command to deactivate NUMA balancing in runtime:</p> <pre><code>sysctl kernel.numa_balancing=0\n</code></pre> <p>To deactivate NUMA balancing permanently, add <code>numa_balancing=disable</code> to GRUB settings:</p> <pre><code>sudo nano /etc/default/grub\n# Add to GRUB_CMDLINE_LINUX_DEFAULT\n</code></pre> /etc/default/grub<pre><code>GRUB_DEFAULT = 0;\nGRUB_HIDDEN_TIMEOUT = 0;\nGRUB_HIDDEN_TIMEOUT_QUIET = true;\nGRUB_TIMEOUT = 10;\nGRUB_DISTRIBUTOR = `lsb_release -i -s 2&gt; /dev/null || echo Debian`;\nGRUB_CMDLINE_LINUX_DEFAULT = 'numa_balancing=disable';\nGRUB_CMDLINE_LINUX = '';\n</code></pre> <p>After updating the variable, be sure to update GRUB to apply changes:</p> <pre><code>sudo update-grub\n</code></pre> <p>Confirm the deactivation by running the following command:</p> <pre><code>sysctl -a | grep 'kernel.numa_balancing'\n</code></pre> <p>If you successfully deactivated NUMA balancing, the preceding command should return <code>0</code>.</p>"},{"location":"infrastructure/running-a-validator/operational-tasks/general-management/#spectre-and-meltdown-mitigations","title":"Spectre and Meltdown Mitigations","text":"<p>Spectre and Meltdown are well-known vulnerabilities in modern CPUs that exploit speculative execution to access sensitive data. These vulnerabilities have been patched in recent Linux kernels, but the mitigations can slightly impact performance, especially in high-throughput or containerized environments.</p> <p>If your security needs allow it, you may selectively deactivate specific mitigations for performance gains. The Spectre V2 and Speculative Store Bypass Disable (SSBD) for Spectre V4 apply to speculative execution and are particularly impactful in containerized environments. Deactivating them can help regain performance if your environment doesn't require these security layers.</p> <p>To selectively deactivate the Spectre mitigations, update the <code>GRUB_CMDLINE_LINUX_DEFAULT</code> variable in your /etc/default/grub configuration:</p> <pre><code>sudo nano /etc/default/grub\n# Add to GRUB_CMDLINE_LINUX_DEFAULT\n</code></pre> /etc/default/grub<pre><code>GRUB_DEFAULT = 0;\nGRUB_HIDDEN_TIMEOUT = 0;\nGRUB_HIDDEN_TIMEOUT_QUIET = true;\nGRUB_TIMEOUT = 10;\nGRUB_DISTRIBUTOR = `lsb_release -i -s 2&gt; /dev/null || echo Debian`;\nGRUB_CMDLINE_LINUX_DEFAULT =\n  'spec_store_bypass_disable=prctl spectre_v2_user=prctl';\n</code></pre> <p>After updating the variable, be sure to update GRUB to apply changes and then reboot:</p> <pre><code>sudo update-grub\nsudo reboot\n</code></pre> <p>This approach selectively deactivates the Spectre V2 and Spectre V4 mitigations, leaving other protections intact. For full security, keep mitigations activated unless there's a significant performance need, as disabling them could expose the system to potential attacks on affected CPUs.</p>"},{"location":"infrastructure/running-a-validator/operational-tasks/general-management/#monitor-your-node","title":"Monitor Your Node","text":"<p>Monitoring your node's performance is critical to maintaining network reliability and security. Tools like Prometheus and Grafana provide insights into block height, peer connections, CPU and memory usage, and more. This section walks through setting up these tools and configuring alerts to notify you of potential issues.</p>"},{"location":"infrastructure/running-a-validator/operational-tasks/general-management/#prepare-environment","title":"Prepare Environment","text":"<p>Before installing Prometheus, it's important to set up the environment securely to ensure Prometheus runs with restricted user privileges. You can set up Prometheus securely as follows:</p> <ol> <li>Create a Prometheus user - ensure Prometheus runs with minimal permissions   <pre><code>sudo useradd --no-create-home --shell /usr/sbin/nologin prometheus\n</code></pre></li> <li>Set up directories - create directories for configuration and data storage   <pre><code>sudo mkdir /etc/prometheus\nsudo mkdir /var/lib/prometheus\n</code></pre></li> <li>Change directory ownership - ensure Prometheus has access   <pre><code>sudo chown -R prometheus:prometheus /etc/prometheus\nsudo chown -R prometheus:prometheus /var/lib/prometheus\n</code></pre></li> </ol>"},{"location":"infrastructure/running-a-validator/operational-tasks/general-management/#install-and-configure-prometheus","title":"Install and Configure Prometheus","text":"<p>After preparing the environment; install and configure the latest version of Prometheus as follows:</p> <ol> <li>Download Prometheus - obtain the respective release binary for your system architecture from the Prometheus releases page. Replace the placeholder text with the respective release binary, e.g. <code>https://github.com/prometheus/prometheus/releases/download/v3.0.0/prometheus-3.0.0.linux-amd64.tar.gz</code> <pre><code>sudo apt-get update &amp;&amp; sudo apt-get upgrade\nwget INSERT_RELEASE_DOWNLOAD_LINK\ntar xfz prometheus-*.tar.gz\ncd prometheus-3.0.0.linux-amd64\n</code></pre></li> <li> <p>Set up Prometheus - copy binaries and directories, assign ownership of these files to the <code>prometheus</code> user, and clean up download directory as follows:</p> 1. Binaries2. Directories3. Clean up <pre><code>sudo cp ./prometheus /usr/local/bin/\nsudo cp ./promtool /usr/local/bin/\nsudo cp ./prometheus /usr/local/bin/\n</code></pre> <pre><code>sudo cp -r ./consoles /etc/prometheus\nsudo cp -r ./console_libraries /etc/prometheus\nsudo chown -R prometheus:prometheus /etc/prometheus/consoles\nsudo chown -R prometheus:prometheus /etc/prometheus/console_libraries\n</code></pre> <pre><code>cd .. &amp;&amp; rm -r prometheus*\n</code></pre> </li> <li> <p>Create <code>prometheus.yml</code> for configuration - run this command to define global settings, rule files, and scrape targets:     <pre><code>sudo nano /etc/prometheus/prometheus.yml\n</code></pre>     Prometheus is scraped every 5 seconds in this example configuration file, ensuring detailed internal metrics. Node metrics with customizable intervals are scraped from port <code>9615</code> by default.     prometheus-config.yml<pre><code>global:\n  scrape_interval: 15s\n  evaluation_interval: 15s\n\nrule_files:\n  # - \"first.rules\"\n  # - \"second.rules\"\n\nscrape_configs:\n  - job_name: 'prometheus'\n    scrape_interval: 5s\n    static_configs:\n      - targets: ['localhost:9090']\n  - job_name: 'substrate_node'\n    scrape_interval: 5s\n    static_configs:\n      - targets: ['localhost:9615']\n</code></pre></p> </li> <li> <p>Validate configuration with promtool - use the open source monitoring system to check your configuration     <pre><code>promtool check config /etc/prometheus/prometheus.yml\n</code></pre></p> </li> <li>Assign ownership - save the configuration file and change the ownership of the file to <code>prometheus</code> user     <pre><code>sudo chown prometheus:prometheus /etc/prometheus/prometheus.yml\n</code></pre></li> </ol>"},{"location":"infrastructure/running-a-validator/operational-tasks/general-management/#start-prometheus","title":"Start Prometheus","text":"<ol> <li> <p>Launch Prometheus - use the following command to launch Prometheus with a given configuration, set the storage location for metric data, and enable web console templates and libraries: </p> <pre><code>sudo -u prometheus /usr/local/bin/prometheus --config.file /etc/prometheus/prometheus.yml --storage.tsdb.path /var/lib/prometheus/ --web.console.templates=/etc/prometheus/consoles --web.console.libraries=/etc/prometheus/console_libraries\n</code></pre> <p>If you set the server up properly, you should see terminal output similar to the following:</p> </li> <li> <p>Verify access - verify you can access the Prometheus interface by visiting the following address:     <pre><code>http://SERVER_IP_ADDRESS:9090/graph\n</code></pre></p> <p>If the interface appears to work as expected, exit the process using <code>Control + C</code>.</p> </li> <li> <p>Create new systemd service file - this will automatically start the server during the boot process     <pre><code>sudo nano /etc/systemd/system/prometheus.service\n</code></pre>     Add the following code to the service file:</p> <p>prometheus.service<pre><code>[Unit]\nDescription=Prometheus Monitoring\nWants=network-online.target\nAfter=network-online.target\n\n[Service]\nUser=prometheus\nGroup=prometheus\nType=simple\nExecStart=/usr/local/bin/prometheus \\\n --config.file /etc/prometheus/prometheus.yml \\\n --storage.tsdb.path /var/lib/prometheus/ \\\n --web.console.templates=/etc/prometheus/consoles \\\n --web.console.libraries=/etc/prometheus/console_libraries\nExecReload=/bin/kill -HUP $MAINPID\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> Once you save the file, execute the following command to reload <code>systemd</code> and enable the service so that it will load automatically during the operating system's startup:</p> <p><pre><code>sudo systemctl daemon-reload &amp;&amp; sudo systemctl enable prometheus &amp;&amp; sudo systemctl start prometheus\n</code></pre> 4. Verify service - return to the Prometheus interface at the following address to verify the service is running: <pre><code>http://SERVER_IP_ADDRESS:9090/\n</code></pre></p> </li> </ol>"},{"location":"infrastructure/running-a-validator/operational-tasks/general-management/#install-and-configure-grafana","title":"Install and Configure Grafana","text":"<p>Grafana provides a powerful, customizable interface to visualize metrics collected by Prometheus. This guide follows Grafana's canonical installation instructions. To install and configure Grafana, follow these steps:</p> <ol> <li> <p>Install Grafana prerequisites - run the following commands to install the required packages:     <pre><code>sudo apt-get install -y apt-transport-https software-properties-common wget    \n</code></pre></p> </li> <li> <p>Import the GPG key:     <pre><code>sudo mkdir -p /etc/apt/keyrings/\nwget -q -O - https://apt.grafana.com/gpg.key | gpg --dearmor | sudo tee /etc/apt/keyrings/grafana.gpg &gt; /dev/null\n</code></pre></p> </li> <li> <p>Configure the stable release repo and update packages:     <pre><code>echo \"deb [signed-by=/etc/apt/keyrings/grafana.gpg] https://apt.grafana.com stable main\" | sudo tee -a /etc/apt/sources.list.d/grafana.list\nsudo apt-get update\n</code></pre></p> </li> <li> <p>Install the latest stable version of Grafana:     <pre><code>sudo apt-get install grafana\n</code></pre></p> </li> </ol> <p>After installing Grafana, you can move on to the configuration steps:</p> <ol> <li> <p>Set Grafana to auto-start - configure Grafana to start automatically on system boot and start the service     <pre><code>sudo systemctl daemon-reload\nsudo systemctl enable grafana-server.service\nsudo systemctl start grafana-server\n</code></pre></p> </li> <li> <p>Verify the Grafana service is running** with the following command:     <pre><code>sudo systemctl status grafana-server\n</code></pre> If necessary, you can stop or restart the service with the following commands:</p> <pre><code>sudo systemctl stop grafana-server\nsudo systemctl restart grafana-server\n</code></pre> </li> <li> <p>Access Grafana - open your browser, navigate to the following address, and use the default user and password <code>admin</code> to login:     <pre><code>http://SERVER_IP_ADDRESS:3000/login\n</code></pre></p> </li> </ol> <p>Change default port</p> <p>If you want run Grafana on another port, edit the file <code>/usr/share/grafana/conf/defaults.ini</code> with a command like: <pre><code>sudo vim /usr/share/grafana/conf/defaults.ini \n</code></pre> You can change the <code>http_port</code> value as desired. Then restart Grafana with: <pre><code>sudo systemctl restart grafana-server\n</code></pre></p> <p></p> <p>Follow these steps to visualize node metrics:</p> <ol> <li>Select the gear icon for settings to configure the Data Sources</li> <li>Select Add data source to define the data source </li> <li>Select Prometheus </li> <li>Enter <code>http://localhost:9090</code> in the URL field, then select Save &amp; Test. If you see the message \"Data source is working\" your connection is configured correctly </li> <li>Next, select Import from the menu bar on the left, select Prometheus in the dropdown list and select Import</li> <li>Finally, start your Polkadot node by running <code>./polkadot</code>. You should now be able to monitor your node's performance such as the current block height, network traffic, and running tasks on the Grafana dashboard </li> </ol> <p>Import via grafana.com</p> <p>The Grafana dashboards page features user created dashboards made available for public use. Visit \"Substrate Node Metrics\" for an example of available dashboards.</p>"},{"location":"infrastructure/running-a-validator/operational-tasks/general-management/#install-and-configure-alertmanager","title":"Install and Configure Alertmanager","text":"<p>The optional <code>Alertmanager</code> complements Prometheus by handling alerts and notifying users of potential issues. Follow these steps to install and configure <code>Alertmanager</code>:</p> <ol> <li>Download extract <code>Alertmanager</code> - download the latest version from the Prometheus Alertmanager releases page. Replace the placeholder text with the respective release binary, e.g. <code>https://github.com/prometheus/alertmanager/releases/download/v0.28.0-rc.0/alertmanager-0.28.0-rc.0.linux-amd64.tar.gz</code> <pre><code>wget INSERT_RELEASE_DOWNLOAD_LINK\ntar -xvzf alertmanager*\n</code></pre></li> <li>Move binaries and set permissions - copy the binaries to a system directory and set appropriate permissions     <pre><code>cd alertmanager-0.28.0-rc.0.linux-amd64\nsudo cp ./alertmanager /usr/local/bin/\nsudo cp ./amtool /usr/local/bin/\nsudo chown prometheus:prometheus /usr/local/bin/alertmanager\nsudo chown prometheus:prometheus /usr/local/bin/amtool\n</code></pre></li> <li> <p>Create configuration file - create a new <code>alertmanager.yml</code> file under <code>/etc/alertmanager</code> <pre><code>sudo mkdir /etc/alertmanager\nsudo nano /etc/alertmanager/alertmanager.yml\n</code></pre>     Add the following code to the configuration file to define email notifications:     alertmanager.yml<pre><code>global:\n  resolve_timeout: 1m\n\nroute:\n  receiver: 'gmail-notifications'\n\nreceivers:\n  - name: 'gmail-notifications'\n    email_configs:\n      - to: INSERT_YOUR_EMAIL\n        from: INSERT_YOUR_EMAIL\n        smarthost: smtp.gmail.com:587\n        auth_username: INSERT_YOUR_EMAIL\n        auth_identity: INSERT_YOUR_EMAIL\n        auth_password: INSERT_YOUR_APP_PASSWORD\n        send_resolved: true\n</code></pre></p> <p>App password</p> <p>You must generate an <code>app password</code> in your Gmail account to allow <code>Alertmanager</code> to send you alert notification emails.</p> <p>Ensure the configuration file has the correct permissions: <pre><code>sudo chown -R prometheus:prometheus /etc/alertmanager\n</code></pre> 4. Configure as a service - set up <code>Alertmanager</code> to run as a service by creating a systemd service file <pre><code>sudo nano /etc/systemd/system/alertmanager.service\n</code></pre> Add the following code to the service file: alertmanager.service<pre><code>[Unit]\nDescription=AlertManager Server Service\nWants=network-online.target\nAfter=network-online.target\n\n[Service]\nUser=root\nGroup=root\nType=simple\nExecStart=/usr/local/bin/alertmanager --config.file /etc/alertmanager/alertmanager.yml --web.external-url=http://SERVER_IP:9093 --cluster.advertise-address='0.0.0.0:9093'\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> Reload and enable the service <pre><code>sudo systemctl daemon-reload\nsudo systemctl enable alertmanager\nsudo systemctl start alertmanager\n</code></pre> Verify the service status using the following command: <pre><code>sudo systemctl status alertmanager\n</code></pre> If you have configured the <code>Alertmanager</code> properly, the Active field should display active (running) similar to below:</p> <p> sudo systemctl status alertmanager alertmanager.service - AlertManager Server Service Loaded: loaded (/etc/systemd/system/alertmanager.service; enabled; vendor preset: enabled) Active: active (running) since Thu 2020-08-20 22:01:21 CEST; 3 days ago Main PID: 20592 (alertmanager) Tasks: 70 (limit: 9830) CGroup: /system.slice/alertmanager.service </p> </li> </ol>"},{"location":"infrastructure/running-a-validator/operational-tasks/general-management/#grafana-plugin","title":"Grafana Plugin","text":"<p>There is an <code>Alertmanager</code> plugin in Grafana that can help you monitor alert information. Follow these steps to use the plugin: </p> <ol> <li>Install the plugin - use the following command:     <pre><code>sudo grafana-cli plugins install camptocamp-prometheus-alertmanager-datasource\n</code></pre></li> <li>Restart Grafana <pre><code>sudo systemctl restart grafana-server\n</code></pre></li> <li>Configure datasource - go to your Grafana dashboard <code>SERVER_IP:3000</code> and configure the <code>Alertmanager</code> datasource as follows:<ul> <li>Go to Configuration -&gt; Data Sources, and search for Prometheus Alertmanager </li> <li>Fill in the URL to your server location followed by the port number used in the <code>Alertmanager</code>. Select Save &amp; Test to test the connection</li> </ul> </li> <li>To monitor the alerts, import the 8010 dashboard, which is used for <code>Alertmanager</code>. Make sure to select the Prometheus Alertmanager in the last column then select Import</li> </ol>"},{"location":"infrastructure/running-a-validator/operational-tasks/general-management/#integrate-alertmanager","title":"Integrate Alertmanager","text":"<p>A few more steps are required to allow the Prometheus server to talk to the Alertmanager and to configure rules for detection and alerts. Complete the integration as follows:</p> <ol> <li>Update configuration - update the configuration file in the <code>etc/prometheus/prometheus.yml</code> to add the following code:     prometheus.yml<pre><code>rule_files:\n  - 'rules.yml'\n\nalerting:\n  alertmanagers:\n    - static_configs:\n        - targets:\n            - localhost:9093\n</code></pre></li> <li>Create rules file - here you will define the rules for detection and alerts     Run the following command to create the rules file:     <pre><code>sudo nano /etc/prometheus/rules.yml\n</code></pre>     If any of the conditions defined in the rules file are met, an alert will be triggered. The following sample rule checks for the node being down and triggers an email notification if an outage of more than five minutes is detected:     rules.yml<pre><code>groups:\n  - name: alert_rules\n    rules:\n      - alert: InstanceDown\n        expr: up == 0\n        for: 5m\n        labels:\n          severity: critical\n        annotations:\n          summary: 'Instance [{{ $labels.instance }}] down'\n          description: '[{{ $labels.instance }}] of job [{{ $labels.job }}] has been down for more than 5 minutes.'\n</code></pre>     See Alerting Rules and additional alerts in the Prometheus documentation to learn more about defining and using alerting rules.</li> <li>Update ownership of rules file - ensure user <code>prometheus</code> has access by running:     <pre><code>sudo chown prometheus:prometheus rules.yml\n</code></pre></li> <li>Check rules - ensure the rules defined in <code>rules.yml</code> are syntactically correct by running the following command:     <pre><code>sudo -u prometheus promtool check rules rules.yml\n</code></pre></li> <li>Restart Alertmanager <pre><code>sudo systemctl restart prometheus &amp;&amp; sudo systemctl restart alertmanager\n</code></pre></li> </ol> <p>Now you will receive an email alert if one of your rule triggering conditions is met.</p> Updated <code>prometheus.yml</code> <pre><code>global:\n  scrape_interval: 15s\n  evaluation_interval: 15s\n\nrule_files:\n  - 'rules.yml'\n\nalerting:\n  alertmanagers:\n    - static_configs:\n        - targets:\n            - localhost:9093\n\nscrape_configs:\n  - job_name: 'prometheus'\n    scrape_interval: 5s\n    static_configs:\n      - targets: ['localhost:9090']\n  - job_name: 'substrate_node'\n    scrape_interval: 5s\n    static_configs:\n      - targets: ['localhost:9615']\n</code></pre>"},{"location":"infrastructure/running-a-validator/operational-tasks/general-management/#secure-your-validator","title":"Secure Your Validator","text":"<p>Validators in Polkadot's Proof of Stake network play a critical role in maintaining network integrity and security by keeping the network in consensus and verifying state transitions. To ensure optimal performance and minimize risks, validators must adhere to strict guidelines around security and reliable operations.</p>"},{"location":"infrastructure/running-a-validator/operational-tasks/general-management/#key-management","title":"Key Management","text":"<p>Though they don't transfer funds, session keys are essential for validators as they sign messages related to consensus and parachains. Securing session keys is crucial as allowing them to be exploited or used across multiple nodes can lead to a loss of staked funds via slashing.</p> <p>Given the current limitations in high-availability setups and the risks associated with double-signing, it\u2019s recommended to run only a single validator instance. Keys should be securely managed, and processes automated to minimize human error.</p> <p>There are two approaches for generating session keys:</p> <ol> <li> <p>Generate and store in node - using the <code>author.rotateKeys</code> RPC call. For most users, generating keys directly within the client is recommended. You must submit a session certificate from your staking proxy to register new keys. See the How to Validate guide for instructions on setting keys</p> </li> <li> <p>Generate outside node and insert - using the <code>author.setKeys</code> RPC call. This flexibility accommodates advanced security setups and should only be used by experienced validator operators</p> </li> </ol>"},{"location":"infrastructure/running-a-validator/operational-tasks/general-management/#signing-outside-the-client","title":"Signing Outside the Client","text":"<p>Polkadot plans to support external signing, allowing session keys to reside in secure environments like Hardware Security Modules (HSMs). However, these modules can sign any payload they receive, potentially enabling an attacker to perform slashable actions.</p>"},{"location":"infrastructure/running-a-validator/operational-tasks/general-management/#secure-validator-mode","title":"Secure-Validator Mode","text":"<p>Polkadot's Secure-Validator mode offers an extra layer of protection through strict filesystem, networking, and process sandboxing. This secure mode is activated by default if the machine meets the following requirements:</p> <ol> <li>Linux (x86-64 architecture) - usually Intel or AMD</li> <li>Enabled <code>seccomp</code> - this kernel feature facilitates a more secure approach for process management on Linux. Verify by running:     <pre><code>cat /boot/config-`uname -r` | grep CONFIG_SECCOMP=\n</code></pre>   If <code>seccomp</code> is enabled, you should see output similar to the following:     <pre><code>CONFIG_SECCOMP=y\n</code></pre></li> </ol> <p>Note</p> <p>Optionally, Linux 5.13 may also be used, as it provides access to even more strict filesystem protections.</p>"},{"location":"infrastructure/running-a-validator/operational-tasks/general-management/#linux-best-practices","title":"Linux Best Practices","text":"<p>Follow these best practices to keep your validator secure:</p> <ul> <li>Use a non-root user for all operations</li> <li>Regularly apply OS security patches</li> <li>Enable and configure a firewall</li> <li>Use key-based SSH authentication; deactivate password-based login</li> <li>Regularly back up data and harden your SSH configuration. Visit this SSH guide for more details</li> </ul>"},{"location":"infrastructure/running-a-validator/operational-tasks/general-management/#validator-best-practices","title":"Validator Best Practices","text":"<p>Additional best practices can add an additional layer of security and operational reliability:</p> <ul> <li>Only run the Polkadot binary, and only listen on the configured p2p port</li> <li>Run on bare-metal machines, as opposed to virtual machines </li> <li>Provisioning of the validator machine should be automated and defined in code which is kept in private version control, reviewed, audited, and tested</li> <li>Generate and provide session keys in a secure way</li> <li>Start Polkadot at boot and restart if stopped for any reason </li> <li>Run Polkadot as a non-root user</li> <li>Establish and maintain an on-call rotation for managing alerts</li> <li>Establish and maintain a clear protocol with actions to perform for each level of each alert with an escalation policy</li> </ul>"},{"location":"infrastructure/running-a-validator/operational-tasks/general-management/#additional-resources","title":"Additional Resources","text":"<ul> <li>Certus One's Knowledge Base</li> <li>EOS Block Producer Security List</li> <li>HSM Policies and the Importance of Validator Security</li> </ul> <p>For additional guidance, connect with other validators and the Polkadot engineering team in the Polkadot Validator Lounge on Element.</p>"},{"location":"infrastructure/running-a-validator/operational-tasks/pause-validating/","title":"Pause Validating","text":""},{"location":"infrastructure/running-a-validator/operational-tasks/pause-validating/#introduction","title":"Introduction","text":"<p>If you need to temporarily stop participating in Polkadot staking activities without fully unbonding your funds, chilling your account allows you to do so efficiently. Chilling removes your node from active validation or nomination in the next era while keeping your funds bonded, making it ideal for planned downtimes or temporary pauses.</p> <p>This guide covers the steps for chilling as a validator or nominator, using the <code>chill</code> and <code>chillOther</code> extrinsics, and how these affect your staking status and nominations.</p>"},{"location":"infrastructure/running-a-validator/operational-tasks/pause-validating/#chilling-your-node","title":"Chilling Your Node","text":"<p>If you need to temporarily step back from staking without unbonding your funds, you can \"chill\" your account. Chilling pauses your active staking participation, setting your account to inactive in the next era while keeping your funds bonded.</p> <p>To chill your account, go to the Network &gt; Staking &gt; Account Actions page on Polkadot.js Apps, and select Stop. Alternatively, you can call the <code>chill</code> extrinsic in the Staking pallet. </p>"},{"location":"infrastructure/running-a-validator/operational-tasks/pause-validating/#staking-election-timing-considerations","title":"Staking Election Timing Considerations","text":"<p>When a node actively participates in staking but then chills, it will continue contributing for the remainder of the current era. However, its eligibility for the next election depends on the chill status at the start of the new era:</p> <ul> <li>Chilled during previous era - will not participate in the current era election and will remain inactive until reactivated -Chilled during current era - will not be selected for the next era's election -Chilled after current era - may be selected if it was active during the previous era and is now chilled</li> </ul>"},{"location":"infrastructure/running-a-validator/operational-tasks/pause-validating/#chilling-as-a-nominator","title":"Chilling as a Nominator","text":"<p>When you choose to chill as a nominator, your active nominations are reset. Upon re-entering the nominating process, you must reselect validators to support manually. Depending on preferences, these can be the same validators as before or a new set. Remember that your previous nominations won\u2019t be saved or automatically reactivated after chilling.</p> <p>While chilled, your nominator account remains bonded, preserving your staked funds without requiring a full unbonding process. When you\u2019re ready to start nominating again, you can issue a new nomination call to activate your bond with a fresh set of validators. This process bypasses the need for re-bonding, allowing you to maintain your stake while adjusting your involvement in active staking.</p>"},{"location":"infrastructure/running-a-validator/operational-tasks/pause-validating/#chilling-as-a-validator","title":"Chilling as a Validator","text":"<p>When you chill as a validator, your active validator status is paused. Although your nominators remain bonded to you, the validator bond will no longer appear as an active choice for new or revised nominations until reactivated. Any existing nominators who take no action will still have their stake linked to the validator, meaning they don\u2019t need to reselect the validator upon reactivation. However, if nominators adjust their stakes while the validator is chilled, they will not be able to nominate the chilled validator until it resumes activity.</p> <p>Upon reactivating as a validator, you must also reconfigure your validator preferences, such as commission rate and other parameters. These can be set to match your previous configuration or updated as desired. This step is essential for rejoining the active validator set and regaining eligibility for nominations.</p>"},{"location":"infrastructure/running-a-validator/operational-tasks/pause-validating/#chill-other","title":"Chill Other","text":"<p>Historical constraints in the runtime prevented unlimited nominators and validators from being supported. These constraints created a need for checks to keep the size of the staking system manageable. One of these checks is the <code>chillOther</code> extrinsic, allowing users to chill accounts that no longer met standards such as minimum staking requirements set through on-chain governance.</p> <p>This control mechanism included a <code>ChillThreshold</code>, which was structured to define how close to the maximum number of nominators or validators the staking system would be allowed to get before users could start chilling one another. With the passage of Referendum #90, the value for <code>maxNominatorCount</code> on Polkadot was set to <code>None</code>, effectively removing the limit on how many nominators and validators can participate. This means the <code>ChillThreshold</code> will never be met; thus, <code>chillOther</code> no longer has any effect.</p>"},{"location":"infrastructure/running-a-validator/operational-tasks/upgrade-your-node/","title":"Upgrade a Validator Node","text":""},{"location":"infrastructure/running-a-validator/operational-tasks/upgrade-your-node/#introduction","title":"Introduction","text":"<p>Upgrading a Polkadot validator node is essential for staying current with network updates and maintaining optimal performance. This guide covers routine and extended maintenance scenarios, including software upgrades and major server changes. Following these steps, you can manage session keys and transition smoothly between servers without risking downtime, slashing, or network disruptions. The process requires strategic planning, especially if you need to perform long-lead maintenance, ensuring your validator remains active and compliant.</p> <p>This guide will allow validators to seamlessly substitute an active validator server to allow for maintenance operations. The process can take several hours, so ensure you understand the instructions first and plan accordingly.</p>"},{"location":"infrastructure/running-a-validator/operational-tasks/upgrade-your-node/#prerequisites","title":"Prerequisites","text":"<p>Before beginning the upgrade process for your validator node, ensure the following:</p> <ul> <li>You have a fully functional validator setup with all required binaries installed. See Set Up a Validator and Validator Requirements for additional guidance</li> <li>Your VPS infrastructure has enough capacity to run a secondary validator instance temporarily for the upgrade process</li> </ul>"},{"location":"infrastructure/running-a-validator/operational-tasks/upgrade-your-node/#session-keys","title":"Session Keys","text":"<p>Session keys are used to sign validator operations and establish a connection between your validator node and your staking proxy account. These keys are stored in the client, and any change to them requires a waiting period. Specifically, if you modify your session keys, the change will take effect only after the current session is completed and two additional sessions have passed.</p> <p>Remembering this delayed effect when planning upgrades is crucial to ensure that your validator continues to function correctly and avoids interruptions. To learn more about session keys and their importance, visit the Keys section.</p>"},{"location":"infrastructure/running-a-validator/operational-tasks/upgrade-your-node/#keystore","title":"Keystore","text":"<p>Your validator server's <code>keystore</code> folder holds the private keys needed for signing network-level transactions. It is important not to duplicate or transfer this folder between validator instances. Doing so could result in multiple validators signing with the duplicate keys, leading to severe consequences such as equivocation slashing. Instead, always generate new session keys for each validator instance.</p> <p>The default path to the <code>keystore</code> is as follows:</p> <pre><code>/home/polkadot/.local/share/polkadot/chains/&lt;chain&gt;/keystore\n</code></pre> <p>Taking care to manage your keys securely ensures that your validator operates safely and without the risk of slashing penalties.</p>"},{"location":"infrastructure/running-a-validator/operational-tasks/upgrade-your-node/#upgrade-using-backup-validator","title":"Upgrade Using Backup Validator","text":"<p>The following instructions outline how to temporarily switch between two validator nodes. The original active validator is referred to as Validator A and the backup node used for maintenance purposes as Validator B.</p>"},{"location":"infrastructure/running-a-validator/operational-tasks/upgrade-your-node/#session-n","title":"Session <code>N</code>","text":"<ol> <li>Start Validator B - launch a secondary node and wait until it is fully synced with the network. Once synced, start it with the <code>--validator</code> flag. This node will now act as Validator B</li> <li>Generate session keys - create new session keys specifically for Validator B</li> <li>Submit the <code>set_key</code> extrinsic - use your staking proxy account to submit a <code>set_key</code> extrinsic, linking the session keys for Validator B to your staking setup</li> <li>Record the session - make a note of the session in which you executed this extrinsic</li> <li>Wait for session changes - allow the current session to end and then wait for two additional full sessions for the new keys to take effect</li> </ol> <p>Keep Validator A running</p> <p>It is crucial to keep Validator A operational during this entire waiting period. Since <code>set_key</code> does not take effect immediately, turning off Validator A too early may result in chilling or even slashing.</p>"},{"location":"infrastructure/running-a-validator/operational-tasks/upgrade-your-node/#session-n3","title":"Session <code>N+3</code>","text":"<p>At this stage, Validator B becomes your active validator. You can now safely perform any maintenance tasks on Validator A.</p> <p>Complete the following steps when you are ready to bring Validator A back online:</p> <ol> <li>Start Validator A - launch Validator A, sync the blockchain database, and ensure it is running with the <code>--validator</code> flag</li> <li>Generate new session keys for Validator A - create fresh session keys for Validator A</li> <li>Submit the <code>set_key</code> extrinsic - using your staking proxy account, submit a <code>set_key</code> extrinsic with the new Validator A session keys</li> <li>Record the session - again, make a note of the session in which you executed this extrinsic</li> </ol> <p>Keep Validator B active until the session during which you executed the <code>set-key</code> extrinsic completes plus two additional full sessions have passed. Once Validator A has successfully taken over, you can safely stop Validator B. This process helps ensure a smooth handoff between nodes and minimizes the risk of downtime or penalties. Verify the transition by checking for finalized blocks in the new session. The logs should indicate the successful change, similar to the example below:</p> INSERT_COMMAND 2019-10-28 21:44:13 Applying authority set change scheduled at block #450092 2019-10-28 21:44:13 Applying GRANDPA set change to new set with 20 authorities"},{"location":"infrastructure/staking-mechanics/","title":"Staking Mechanics","text":"<p>Gain a deep understanding of the staking mechanics in Polkadot, with a focus on how they impact validators. In this section, you'll explore key concepts such as offenses, slashing, and reward payouts, and learn how these mechanisms influence the behavior and performance of validators within the network. Understanding these elements is crucial for optimizing your validator's participation and ensuring alignment with Polkadot's governance and security protocols.</p>"},{"location":"infrastructure/staking-mechanics/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"infrastructure/staking-mechanics/#additional-resourcs","title":"Additional ResourcsLearn About Nominated Proof of StakingDive Deep into Slashing MechanismsReview Validator Rewards Metrics","text":"<p>Take a deeper dive into the fundamentals of Polkadot's Nominated Proof of Stake (NPoS) consensus mechanism.</p> <p>Read the Web3 Foundation's research article on slashing mechanisms for a comprehensive understanding of slashing, along with an in-depth examination of the offenses involved.</p> <p>Check out Dune's Polkadot Staking Rewards dashboard for a detailed look at validator-specific metrics over time, such as daily staking rewards, nominators count, reward points, and more.</p>"},{"location":"infrastructure/staking-mechanics/offenses-and-slashes/","title":"Offenses and Slashes","text":""},{"location":"infrastructure/staking-mechanics/offenses-and-slashes/#introduction","title":"Introduction","text":"<p>In Polkadot's Nominated Proof of Stake (NPoS) system, validator misconduct is deterred through a combination of slashing, disabling, and reputation penalties. Validators and nominators who stake tokens face consequences for validator misbehavior, which range from token slashes to restrictions on network participation.</p> <p>This page outlines the types of offenses recognized by Polkadot, including block equivocations and invalid votes, as well as the corresponding penalties. While some parachains may implement additional custom slashing mechanisms, this guide focuses on the offenses tied to staking within the Polkadot ecosystem.</p>"},{"location":"infrastructure/staking-mechanics/offenses-and-slashes/#offenses","title":"Offenses","text":"<p>Polkadot is a public permissionless network. As such, it has a mechanism to disincentivize offenses and incentivize good behavior. You can review the\u00a0parachain protocol to understand better the terminology used to describe offenses. Polkadot validator offenses fall into two categories: invalid votes and equivocations. </p>"},{"location":"infrastructure/staking-mechanics/offenses-and-slashes/#invalid-votes","title":"Invalid Votes","text":"<p>A validator will be penalized for inappropriate voting activity during the block inclusion and approval processes. The invalid voting related offenses are as follows:</p> <ul> <li>Backing an invalid block - a para-validator backs an invalid block for inclusion in a fork of the relay chain</li> <li><code>ForInvalid</code> vote - when acting as a secondary checker, the validator votes in favor of an invalid block</li> <li><code>AgainstValid</code> vote - when acting as a secondary checker, the validator votes against a valid block. This type of vote wastes network resources required to resolve the disparate votes and resulting dispute</li> </ul>"},{"location":"infrastructure/staking-mechanics/offenses-and-slashes/#equivocations","title":"Equivocations","text":"<p>Equivocation occurs when a validator produces statements that conflict with each other when producing blocks or voting. Unintentional equivocations usually occur when duplicate signing keys reside on the validator host. If keys are never duplicated, the probability of an honest equivocation slash decreases to near zero. The equivocation related offenses are as follows:</p> <ul> <li>Equivocation - the validator produces two or more of the same block or vote<ul> <li>GRANDPA and BEEFY equivocation - the validator signs two or more votes in the same round on different chains</li> <li>BABE equivocation - the validator produces two or more blocks on the relay chain in the same time slot</li> </ul> </li> <li>Double seconded equivocation - the validator attempts to second, or back, more than one block in the same round</li> <li>Seconded and valid equivocation - the validator seconds, or backs, a block and then attempts to hide their role as the responsible backer by later placing a standard validation vote</li> </ul>"},{"location":"infrastructure/staking-mechanics/offenses-and-slashes/#penalties","title":"Penalties","text":"<p>On Polkadot, offenses to the network incur different penalties depending on severity. There are three main penalties: slashing, disabling, and reputation changes.</p>"},{"location":"infrastructure/staking-mechanics/offenses-and-slashes/#slashing","title":"Slashing","text":"<p>Validators engaging in bad actor behavior in the network may be subject to slashing if they commit a qualifying offense. When a validator is slashed, they and their nominators lose a percentage of their staked DOT or KSM, from as little as 0.01% up to 100% based on the severity of the offense. Nominators are evaluated for slashing against their active validations at any given time. Validator nodes are evaluated as discrete entities, meaning an operator can't attempt to mitigate the offense on another node they operate in order to avoid a slash. </p> <p>Any slashed DOT or KSM will be added to the Treasury rather than burned or distributed as rewards. Moving slashed funds to the Treasury allows tokens to be quickly moved away from malicious validators while maintaining the ability to revert faulty slashes when needed.</p> <p>Multiple active nominations</p> <p>A nominator with a very large bond may nominate several validators in a single era. In this case, a slash is proportionate to the amount staked to the offending validator. Stake allocation and validator activation is controlled by the Phragm\u00e9n algorithm.</p> <p>A validator slash creates an <code>unapplied</code> state transition. You can view pending slashes on Polkadot.js Apps. The UI will display the slash per validator, the affected nominators, and the slash amounts. The unapplied state includes a 27-day grace period during which a governance proposal can be made to reverse the slash. Once this grace period expires, the slash is applied.</p>"},{"location":"infrastructure/staking-mechanics/offenses-and-slashes/#equivocation-slash","title":"Equivocation Slash","text":"<p>The Web3 Foundation's Slashing mechanisms page provides guidelines for evaluating the security threat level of different offenses and determining penalties proportionate to the threat level of the offense. Offenses requiring coordination between validators or extensive computational costs to the system will typically call for harsher penalties than those more likely to be unintentional than malicious. A description of potential offenses for each threat level and the corresponding penalties is as follows:</p> <ul> <li>Level 1 - honest misconduct such as isolated cases of unresponsiveness<ul> <li>Penalty - validator can be kicked out or slashed up to 0.1% of stake in the validator slot</li> </ul> </li> <li>Level 2 - misconduct that can occur honestly but is a sign of bad practices. Examples include repeated cases of unresponsiveness and isolated cases of equivocation<ul> <li>Penalty - slash of up to 1% of stake in the validator slot</li> </ul> </li> <li>Level 3 - misconduct that is likely intentional but of limited effect on the performance or security of the network. This level will typically include signs of coordination between validators. Examples include repeated cases of equivocation or isolated cases of unjustified voting on GRANDPA<ul> <li>Penalty - reduction in networking reputation metrics, slash of up to 10% of stake in the validator slot</li> </ul> </li> <li>Level 4 - misconduct that poses severe security or monetary risk to the system or mass collusion. Examples include signs of extensive coordination, creating a serious security risk to the system, or forcing the system to use extensive resources to counter the misconduct<ul> <li>Penalty - slash of up to 100% of stake in the validator slot</li> </ul> </li> </ul> <p>See the next section to understand how slash amounts for equivocations are calculated. If you want to know more details about slashing, please look at the research page on Slashing mechanisms.</p>"},{"location":"infrastructure/staking-mechanics/offenses-and-slashes/#slash-calculation-for-equivocation","title":"Slash Calculation for Equivocation","text":"<p>The slashing penalty for GRANDPA, BABE, and BEEFY equivocations is calculated using the formula below, where <code>x</code> represents the number of offenders and <code>n</code> is the total number of validators in the active set:</p> <pre><code>min((3 * x / n )^2, 1)\n</code></pre> <p>The following scenarios demonstrate how this formula means slash percentages can increase exponentially based on the number of offenders involved compared to the size of the validator pool:</p> <ul> <li> <p>Minor offense - assume 1 validator out of a 100 validator active set equivocates in a slot. A single validator committing an isolated offense is most likely a mistake rather than malicious attack on the network. This offense results in a 0.09% slash to the stake in the validator slot</p> <pre><code>flowchart LR\nN[\"Total Validators = 100\"]\nX[\"Offenders = 1\"]\nF[\"min(3 * 1 / 100)^2, 1) = 0.0009\"]\nG[\"0.09% slash of stake\"]\n\nN --&gt; F\nX --&gt; F\nF --&gt; G</code></pre> </li> <li> <p>Moderate offense - assume 5 validators out a 100 validator active set equivocate in a slot. This is a slightly more serious event as there may be some element of coordination involved. This offense results in a 2.25% slash to the stake in the validator slot</p> <pre><code>flowchart LR\nN[\"Total Validators = 100\"]\nX[\"Offenders = 5\"]\nF[\"min((3 * 5 / 100)^2, 1) = 0.0225\"]\nG[\"2.25% slash of stake\"]\n\nN --&gt; F\nX --&gt; F\nF --&gt; G</code></pre> </li> <li> <p>Major offense - assume 20 validators out a 100 validator active set equivocate in a slot. This is a major security threat as it possible represents a coordinated attack on the network. This offense results in a 36% slash and all slashed validators will also be chilled     <pre><code>flowchart LR\nN[\"Total Validators = 100\"]\nX[\"Offenders = 20\"]\nF[\"min((3 * 20 / 100)^2, 1) = 0.36\"]\nG[\"36% slash of stake\"]\n\nN --&gt; F\nX --&gt; F\nF --&gt; G</code></pre></p> </li> </ul> <p>The examples above show the risk of nominating or running many validators in the active set. While rewards grow linearly (two validators will get you approximately twice as many staking rewards as one), slashing grows exponentially. Going from a single validator equivocating to two validators equivocating causes a slash four time as much as the single validator.</p> <p>Validators may run their nodes on multiple machines to ensure they can still perform validation work if one of their nodes goes down. Still, validator operators should be cautious when setting these up. Equivocation is possible if they don't coordinate well in managing signing machines.</p>"},{"location":"infrastructure/staking-mechanics/offenses-and-slashes/#best-practices-to-avoid-slashing","title":"Best Practices to Avoid Slashing","text":"<p>The following are advised to node operators to ensure that they obtain pristine binaries or source code and to ensure the security of their node:</p> <ul> <li>Always download either source files or binaries from the official Parity repository</li> <li>Verify the hash of downloaded files</li> <li>Use the W3F secure validator setup or adhere to its principles</li> <li>Ensure essential security items are checked, use a firewall, manage user access, use SSH certificates</li> <li>Avoid using your server as a general-purpose system. Hosting a validator on your workstation or one that hosts other services increases the risk of maleficence</li> <li>Avoid cloning servers (copying all contents) when migrating to new hardware. If an image is needed, create it before generating keys</li> <li>High Availability (HA) systems are generally not recommended as equivocation may occur if concurrent operations happen\u2014such as when a failed server restarts or two servers are falsely online simultaneously</li> <li>Copying the keystore folder when moving a database between instances can cause equivocation. Even brief use of duplicated keystores can result in slashing</li> </ul> <p>Below are some examples of small equivocations that happened in the past:</p> Network Era Event Type Details Action Taken Polkadot 774 Small Equivocation The validator migrated servers and cloned the keystore folder. The on-chain event can be viewed on Subscan. The validator didn't submit a request for the slash to be canceled. Kusama 3329 Small Equivocation The validator operated a test machine with cloned keys. The test machine was online simultaneously as the primary, which resulted in a slash. Details can be found on Polkassembly. The validator requested a slash cancellation, but the council declined. Kusama 3995 Small Equivocation The validator noticed several errors, after which the client crashed, and a slash was applied. The validator recorded all events and opened GitHub issues to allow for technical opinions to be shared. Details can be found on Polkassembly. The validator requested to cancel the slash. The council approved the request as they believed the error wasn't operator-related."},{"location":"infrastructure/staking-mechanics/offenses-and-slashes/#slashing-across-eras","title":"Slashing Across Eras","text":"<p>There are three main difficulties to account for with slashing in NPoS:</p> <ul> <li>A nominator can nominate multiple validators and be slashed as a result of actions taken by any of them</li> <li>Until slashed, the stake is reused from era to era</li> <li>Slashable offenses can be found after the fact and out of order</li> </ul> <p>To balance this, the system applies only the maximum slash a participant can receive in a given time period rather than the sum. This ensures protection from excessive slashing.</p>"},{"location":"infrastructure/staking-mechanics/offenses-and-slashes/#disabling","title":"Disabling","text":"<p>The disabling mechanism is triggered when validators commit serious infractions, such as backing invalid blocks or engaging in equivocations. Disabling stops validators from performing specific actions after they have committed an offense. Disabling is further divided into:</p> <ul> <li>On-chain disabling - lasts for a whole era and stops validators from authoring blocks, backing, and initiating a dispute</li> <li>Off-chain disabling - lasts for a session, is caused by losing a dispute, and stops validators from initiating a dispute</li> </ul> <p>Off-chain disabling is always a lower priority than on-chain disabling. Off-chain disabling prioritizes disabling first backers and then approval checkers.</p> <p>Note</p> <p>The material in this guide reflects the changes introduced in Stage 2. For more details, refer to the State of Disabling issue on GitHub.</p>"},{"location":"infrastructure/staking-mechanics/offenses-and-slashes/#reputation-changes","title":"Reputation Changes","text":"<p>Some minor offenses, such as spamming, are only punished by networking reputation changes. Validators use a reputation metric when choosing which peers to connect with. The system adds reputation if a peer provides valuable data and behaves appropriately. If they provide faulty or spam data, the system reduces their reputation. If a validator loses enough reputation, their peers will temporarily close their channels to them. This helps in fighting against Denial of Service (DoS) attacks. Performing validator tasks under reduced reputation will be harder, resulting in lower validator rewards.</p>"},{"location":"infrastructure/staking-mechanics/offenses-and-slashes/#penalties-by-offense","title":"Penalties by Offense","text":"<p>Below, you can find a summary of penalties for specific offenses:</p> Offense Slash (%) On-Chain Disabling Off-Chain Disabling Reputational Changes Backing Invalid 100% Yes Yes (High Priority) No ForInvalid Vote - No Yes (Mid Priority) No AgainstValid Vote - No Yes (Low Priority) No GRANDPA / BABE / BEEFY Equivocations 0.01-100% Yes No No Seconded + Valid Equivocation - No No No Double Seconded Equivocation - No No Yes"},{"location":"infrastructure/staking-mechanics/rewards-payout/","title":"Rewards Payout","text":""},{"location":"infrastructure/staking-mechanics/rewards-payout/#introduction","title":"Introduction","text":"<p>Understanding how rewards are distributed to validators and nominators is essential for network participants. In Polkadot and Kusama, validators earn rewards based on their era points, which are accrued through actions like block production and parachain validation.</p> <p>This guide explains the payout scheme, factors influencing rewards, and how multiple validators affect returns. Validators can also share rewards with nominators, who contribute by staking behind them. By following the payout mechanics, validators can optimize their earnings and better engage with their nominators.</p>"},{"location":"infrastructure/staking-mechanics/rewards-payout/#era-points","title":"Era Points","text":"<p>The Polkadot ecosystem measures their reward cycles in a unit called an era. Kusama eras are approximately 6 hours long, and Polkadot eras are 24 hours. At the end of each era, validators are paid proportionally to the amount of era points they have collected. Era points are reward points earned for payable actions like:</p> <ul> <li>Issuing validity statements for parachain blocks</li> <li>Producing a non-uncle block in the relay chain</li> <li>Producing a reference to a previously unreferenced uncle block</li> <li>Producing a referenced uncle block</li> </ul> <p>Note</p> <p>An uncle block is a relay chain block that is valid in every regard but has failed to become canonical. This can happen when two or more validators are block producers in a single slot, and the block produced by one validator reaches the next block producer before the others. The lagging blocks are called uncle blocks.</p> <p>Payments occur at the end of every era.</p>"},{"location":"infrastructure/staking-mechanics/rewards-payout/#reward-variance","title":"Reward Variance","text":"<p>Rewards in Polkadot and Kusama staking systems can fluctuate due to differences in era points earned by para-validators and non-para-validators. Para-validators generally contribute more to the overall reward distribution due to their role in validating parachain blocks, thus influencing the variance in staking rewards.</p> <p>To illustrate this relationship:</p> <ul> <li>Para-validator era points tend to have a higher impact on the expected value of staking rewards compared to non-para-validator points</li> <li>The variance in staking rewards increases as the total number of validators grows relative to the number of para-validators</li> <li>In simpler terms, when more validators are added to the active set without increasing the para-validator pool, the disparity in rewards between validators becomes more pronounced</li> </ul> <p>However, despite this increased variance, rewards tend to even out over time due to the continuous rotation of para-validators across eras. The network's design ensures that over multiple eras, each validator has an equal opportunity to participate in para-validation, eventually leading to a balanced distribution of rewards.</p> Probability in Staking Rewards <p>This should only serve as a high-level overview of the probabilistic nature for staking rewards.</p> <p>Let:</p> <ul> <li><code>pe</code> = para-validator era points</li> <li><code>ne</code> = non-para-validator era points</li> <li><code>EV</code> = expected value of staking rewards</li> </ul> <p>Then, <code>EV(pe)</code> has more influence on the <code>EV</code> than <code>EV(ne)</code>.</p> <p>Since <code>EV(pe)</code> has a more weighted probability on the <code>EV</code>, the increase in variance against the <code>EV</code> becomes apparent between the different validator pools (aka. validators in the active set and the ones chosen to para-validate).</p> <p>Also, let:</p> <ul> <li><code>v</code> = the variance of staking rewards</li> <li><code>p</code> = number of para-validators</li> <li><code>w</code> = number validators in the active set</li> <li><code>e</code> = era</li> </ul> <p>Then, <code>v</code> \u2191 if <code>w</code> \u2191, as this reduces <code>p</code> : <code>w</code>, with respect to <code>e</code>.</p> <p>Increased <code>v</code> is expected, and initially keeping <code>p</code> \u2193 using the same para-validator set for all parachains ensures availability and voting. In addition, despite <code>v</code> \u2191 on an <code>e</code> to <code>e</code> basis, over time, the amount of rewards each validator receives will equal out based on the continuous selection of para-validators.</p> <p>There are plans to scale the active para-validation set in the future.</p>"},{"location":"infrastructure/staking-mechanics/rewards-payout/#payout-scheme","title":"Payout Scheme","text":"<p>Validator rewards are distributed equally among all validators in the active set, regardless of the total stake behind each validator. However, individual payouts may differ based on the number of era points a validator has earned. Although factors like network connectivity can affect era points, well-performing validators should accumulate similar totals over time.</p> <p>Validators can also receive tips from users, which incentivize them to include certain transactions in their blocks. Validators retain 100% of these tips.</p> <p>Rewards are paid out in the network's native token (DOT for Polkadot and KSM for Kusama). </p> <p>The following example illustrates a four member validator set with their names, amount they have staked, and how payout of rewards is divided. This scenario assumes all validators earned the same amount of era points and no one received tips: </p> <pre><code>%%Payout, 4 val set, A-D are validators/stakes, E is payout%%\n\nblock-beta\n    columns 1\n  block\n    A[\"Alice (18 DOT)\"]\n    B[\"Bob (9 DOT)\"]\n    C[\"Carol (8 DOT)\"]\n    D[\"Dave (7 DOT)\"]\n  end\n    space\n    E[\"Payout (8 DOT total)\"]:1\n    E --\"2 DOT\"--&gt; A\n    E --\"2 DOT\"--&gt; B\n    E --\"2 DOT\"--&gt; C\n    E --\"2 DOT\"--&gt; D </code></pre> <p>Note that this is different than most other Proof of Stake (PoS) systems. As long as a validator is in the validator set, it will receive the same block reward as every other validator. Validator Alice, who had 18 DOT staked, received the same 2 DOT reward in this era as Dave, who had only 7 DOT staked.</p>"},{"location":"infrastructure/staking-mechanics/rewards-payout/#running-multiple-validators","title":"Running Multiple Validators","text":"<p>Running multiple validators can offer a more favorable risk/reward ratio compared to running a single one. If you have sufficient DOT or nominators staking on your validators, maintaining multiple validators within the active set can yield higher rewards.</p> <p>In the preceding section, with 18 DOT staked and no nominators, Alice earned 2 DOT in one era. This example uses DOT, but the same principles apply for KSM on the Kusama network. By managing stake across multiple validators, you can potentially increase overall returns. Recall the set of validators from the preceding section:</p> <pre><code>%%Payout, 4 val set, A-D are validators/stakes, E is payout%%\n\nblock-beta\n    columns 1\n  block\n    A[\"Alice (18 DOT)\"]\n    B[\"Bob (9 DOT)\"]\n    C[\"Carol (8 DOT)\"]\n    D[\"Dave (7 DOT)\"]\n  end\n    space\n    E[\"Payout (8 DOT total)\"]:1\n    E --\"2 DOT\"--&gt; A\n    E --\"2 DOT\"--&gt; B\n    E --\"2 DOT\"--&gt; C\n    E --\"2 DOT\"--&gt; D </code></pre> <p>Now, assume Alice decides to split their stake and run two validators, each with a nine DOT stake. This validator set only has four spots and priority is given to validators with a larger stake. In this example, Dave has the smallest stake and loses his spot in the validator set. Now, Alice will earn two shares of the total payout each era as illustrated below:</p> <pre><code>%%Payout, 4 val set, A-D are validators/stakes, E is payout%%\n\nblock-beta\n    columns 1\n  block\n    A[\"Alice (9 DOT)\"]\n    F[\"Alice (9 DOT)\"]\n    B[\"Bob (9 DOT)\"]\n    C[\"Carol (8 DOT)\"]\n  end\n    space\n    E[\"Payout (8 DOT total)\"]:1\n    E --\"2 DOT\"--&gt; A\n    E --\"2 DOT\"--&gt; B\n    E --\"2 DOT\"--&gt; C\n    E --\"2 DOT\"--&gt; F </code></pre> <p>With enough stake, you could run more than two validators. However, each validator must have enough stake behind it to maintain a spot in the validator set.</p>"},{"location":"infrastructure/staking-mechanics/rewards-payout/#nominators-and-validator-payments","title":"Nominators and Validator Payments","text":"<p>A nominator's stake allows them to vote for validators and earn a share of the rewards without managing a validator node. Although staking rewards depend on validator activity during an era, validators themselves never control or own nominator rewards. To trigger payouts, anyone can call the <code>staking.payoutStakers</code> or <code>staking.payoutStakerByPage</code> methods, which mint and distribute rewards directly to the recipients. This trustless process ensures nominators receive their earned rewards.</p> <p>Validators set a commission rate as a percentage of the block reward, affecting how rewards are shared with nominators. A 0% commission means the validator keeps only rewards from their self-stake, while a 100% commission means they retain all rewards, leaving none for nominators.</p> <p>The following examples model splitting validator payments between nominator and validator using various commission percentages. For simplicity, these examples assume a Polkadot-SDK based relay chain that uses DOT as a native token and a single nominator per validator. Calculations of KSM reward payouts for Kusama follow the same formula. </p> <p>Start with the original validator set from the previous section: </p> <pre><code>block-beta\n    columns 1\n  block:e\n    A[\"Alice (18 DOT)\"]\n    B[\"Bob (9 DOT)\"]\n    C[\"Carol (8 DOT)\"]\n    D[\"Dave (7 DOT)\"]\n  end\n    space\n    E[\"Payout (8 DOT total)\"]:1\n    E --\"2 DOT\"--&gt; A\n    E --\"2 DOT\"--&gt; B\n    E --\"2 DOT\"--&gt; C\n    E --\"2 DOT\"--&gt; D </code></pre> <p>The preceding diagram shows each validator receiving a 2 DOT payout, but doesn't account for sharing rewards with nominators. The following diagram shows what nominator payout might look like for validator Alice. Alice has a 20% commission rate and holds 50% of the stake for their validator:</p> <pre><code>\nflowchart TD\n    A[\"Gross Rewards = 2 DOT\"]\n    E[\"Commission = 20%\"]\n    F[\"Alice Validator Payment = 0.4 DOT\"]\n    G[\"Total Stake Rewards = 1.6 DOT\"]\n    B[\"Alice Validator Stake = 18 DOT\"]\n    C[\"9 DOT Alice (50%)\"]\n    H[\"Alice Stake Reward = 0.8 DOT\"]\n    I[\"Total Alice Validator Reward = 1.2 DOT\"]\n    D[\"9 DOT Nominator (50%)\"]\n    J[\"Total Nominator Reward = 0.8 DOT\"]\n\n    A --&gt; E\n    E --(2 x 0.20)--&gt; F\n    F --(2 - 0.4)--&gt; G\n    B --&gt; C\n    B --&gt; D\n    C --(1.6 x 0.50)--&gt; H\n    H --(0.4 + 0.8)--&gt; I\n    D --(1.60 x 0.50)--&gt; J</code></pre> <p>Notice the validator commission rate is applied against the gross amount of rewards for the era. The validator commission is subtracted from the total rewards. After the commission is paid to the validator, the remaining amount is split among stake owners according to their percentage of the total stake. A validator's total rewards for an era include their commission plus their piece of the stake rewards. </p> <p>Now, consider a different scenario for validator Bob where the commission rate is 40%, and Bob holds 33% of the stake for their validator:</p> <pre><code>\nflowchart TD\n    A[\"Gross Rewards = 2 DOT\"]\n    E[\"Commission = 40%\"]\n    F[\"Bob Validator Payment = 0.8 DOT\"]\n    G[\"Total Stake Rewards = 1.2 DOT\"]\n    B[\"Bob Validator Stake = 9 DOT\"]\n    C[\"3 DOT Bob (33%)\"]\n    H[\"Bob Stake Reward = 0.4 DOT\"]\n    I[\"Total Bob Validator Reward = 1.2 DOT\"]\n    D[\"6 DOT Nominator (67%)\"]\n    J[\"Total Nominator Reward = 0.8 DOT\"]\n\n    A --&gt; E\n    E --(2 x 0.4)--&gt; F\n    F --(2 - 0.8)--&gt; G\n    B --&gt; C\n    B --&gt; D\n    C --(1.2 x 0.33)--&gt; H\n    H --(0.8 + 0.4)--&gt; I\n    D --(1.2 x 0.67)--&gt; J</code></pre> <p>Bob holds a smaller percentage of their node's total stake, making their stake reward smaller than Alice's. In this scenario, Bob makes up the difference by charging a 40% commission rate and ultimately ends up with the same total payment as Alice. Each validator will need to find their ideal balance between the amount of stake and commission rate to attract nominators while still making running a validator worthwhile.</p>"},{"location":"polkadot-protocol/","title":"Learn About the Polkadot Protocol","text":"<p>The Polkadot protocol is designed to enable scalable, secure, and interoperable networks. It introduces a unique multichain architecture that allows independent blockchains, known as parachains, to operate seamlessly while benefiting from the shared security of the relay chain. Polkadot\u2019s decentralized governance ensures that network upgrades and decisions are community-driven, while its cross-chain messaging and interoperability features make it a hub for multichain applications.</p> <p>This section provides a technical overview of Polkadot, exploring its architecture, core concepts, and key components. Whether you're new to blockchain or an experienced developer, you'll gain insights into how Polkadot enables scalable, interoperable, and decentralized networks.</p>"},{"location":"polkadot-protocol/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"polkadot-protocol/glossary/","title":"Glossary","text":"<p>Key definitions, concepts, and terminology specific to the Polkadot ecosystem are included here.</p> <p>Additional glossaries from around the ecosystem you might find helpful:</p> <ul> <li>Polkadot Wiki Glossary</li> <li>Polkadot SDK Glossary</li> </ul>"},{"location":"polkadot-protocol/glossary/#authority","title":"Authority","text":"<p>The role in a blockchain that can participate in consensus mechanisms. </p> <ul> <li>GRANDPA - the authorities vote on chains they consider final </li> <li>Blind Assignment of Blockchain Extension (BABE) - the authorities are also block authors </li> </ul> <p>Authority sets can be used as a basis for consensus mechanisms such as the Nominated Proof of Stake (NPoS) protocol.</p>"},{"location":"polkadot-protocol/glossary/#authority-round-aura","title":"Authority Round (Aura)","text":"<p>A deterministic consensus protocol where block production is limited to a rotating list of authorities that take turns creating blocks. In authority round (Aura) consensus, most online authorities are assumed to be honest. It is often used in combination with\u00a0GRANDPA\u00a0as a\u00a0hybrid consensus\u00a0protocol.</p> <p>Learn more by reading the official Aura consensus algorithm wiki article.</p>"},{"location":"polkadot-protocol/glossary/#blind-assignment-of-blockchain-extension-babe","title":"Blind Assignment of Blockchain Extension (BABE)","text":"<p>A block authoring protocol similar to Aura, except authorities win slots based on a Verifiable Random Function (VRF) instead of the round-robin selection method. The winning authority can select a chain and submit a new block.</p> <p>Learn more by reading the official Web3 Foundation BABE research document.</p>"},{"location":"polkadot-protocol/glossary/#block-author","title":"Block Author","text":"<p>The node responsible for the creation of a block, also called block producers. In a Proof of Work (PoW) blockchain, these nodes are called miners.</p>"},{"location":"polkadot-protocol/glossary/#byzantine-fault-tolerance-bft","title":"Byzantine Fault Tolerance (BFT)","text":"<p>The ability of a distributed computer network to remain operational if a certain proportion of its nodes or authorities are defective or behaving maliciously.</p> <p>Note</p> <p>A distributed network is typically considered Byzantine fault tolerant if it can remain functional, with up to one-third of nodes assumed to be defective, offline, actively malicious, and part of a coordinated attack.</p>"},{"location":"polkadot-protocol/glossary/#byzantine-failure","title":"Byzantine Failure","text":"<p>The loss of a network service due to node failures that exceed the proportion of nodes required to reach consensus.</p>"},{"location":"polkadot-protocol/glossary/#practical-byzantine-fault-tolerance-pbft","title":"Practical Byzantine Fault Tolerance (pBFT)","text":"<p>An early approach to Byzantine fault tolerance (BFT), practical Byzantine fault tolerance (pBFT) systems tolerate Byzantine behavior from up to one-third of participants.</p> <p>The communication overhead for such systems is <code>O(n\u00b2)</code>, where <code>n</code> is the number of nodes (participants) in the system.</p>"},{"location":"polkadot-protocol/glossary/#call","title":"Call","text":"<p>In the context of pallets containing functions to be dispatched to the runtime, <code>Call</code> is an enumeration data type that describes the functions that can be dispatched with one variant per pallet. A <code>Call</code> represents a dispatch data structure object.</p>"},{"location":"polkadot-protocol/glossary/#chain-specification","title":"Chain Specification","text":"<p>A chain specification file defines the properties required to run a node in an active or new Polkadot SDK-built network. It often contains the initial genesis runtime code, network properties (such as the network's name), the initial state for some pallets, and the boot node list. The chain specification file makes it easy to use a single Polkadot SDK codebase as the foundation for multiple independently configured chains.</p>"},{"location":"polkadot-protocol/glossary/#collator","title":"Collator","text":"<p>An author of a parachain network. They aren't authorities in themselves, as they require a relay chain to coordinate consensus.</p> <p>More details are found on the Polkadot Collator Wiki.</p>"},{"location":"polkadot-protocol/glossary/#collective","title":"Collective","text":"<p>Most often used to refer to an instance of the Collective pallet on Polkadot SDK-based networks such as Kusama or Polkadot if the Collective pallet is part of the FRAME-based runtime for the network.</p>"},{"location":"polkadot-protocol/glossary/#consensus","title":"Consensus","text":"<p>Consensus is the process blockchain nodes use to agree on a chain's canonical fork. It is composed of authorship, finality, and fork-choice rule. In the Polkadot ecosystem, these three components are usually separate and the term consensus often refers specifically to authorship.</p> <p>See also hybrid consensus.</p>"},{"location":"polkadot-protocol/glossary/#consensus-algorithm","title":"Consensus Algorithm","text":"<p>Ensures a set of actors\u2014who don't necessarily trust each other\u2014can reach an agreement about the state as the result of some computation. Most consensus algorithms assume that up to one-third of the actors or nodes can be Byzantine fault tolerant.</p> <p>Consensus algorithms are generally concerned with ensuring two properties:</p> <ul> <li>Safety - indicating that all honest nodes eventually agreed on the state of the chain</li> <li>Liveness - indicating the ability of the chain to keep progressing</li> </ul>"},{"location":"polkadot-protocol/glossary/#consensus-engine","title":"Consensus Engine","text":"<p>The node subsystem responsible for consensus tasks.</p> <p>For detailed information about the consensus strategies of the Polkadot network, see the Polkadot Consensus blog series.</p> <p>See also hybrid consensus.</p>"},{"location":"polkadot-protocol/glossary/#coretime","title":"Coretime","text":"<p>The time allocated for utilizing a core, measured in relay chain blocks. There are two types of coretime: on-demand and bulk.</p> <p>On-demand coretime refers to coretime acquired through bidding in near real-time for the validation of a single parachain block on one of the cores reserved specifically for on-demand orders. They are available as an on-demand coretime pool. Set of cores that are available on-demand. Cores reserved through bulk coretime could also be made available in the on-demand coretime pool, in parts or in entirety.</p> <p>Bulk coretime is a fixed duration of continuous coretime represented by an NFT that can be split, shared, or resold. It is managed by the Broker pallet.</p>"},{"location":"polkadot-protocol/glossary/#development-phrase","title":"Development Phrase","text":"<p>A mnemonic phrase that is intentionally made public.</p> <p>Well-known development accounts, such as Alice, Bob, Charlie, Dave, Eve, and Ferdie, are generated from the same secret phrase:</p> <pre><code>bottom drive obey lake curtain smoke basket hold race lonely fit walk\n</code></pre> <p>Many tools in the Polkadot SDK ecosystem, such as <code>subkey</code>, allow you to implicitly specify an account using a derivation path such as <code>//Alice</code>.</p>"},{"location":"polkadot-protocol/glossary/#digest","title":"Digest","text":"<p>An extensible field of the block header that encodes information needed by several actors in a blockchain network, including:</p> <ul> <li>Light clients for chain synchronization</li> <li>Consensus engines for block verification</li> <li>The runtime itself, in the case of pre-runtime digests</li> </ul>"},{"location":"polkadot-protocol/glossary/#dispatchable","title":"Dispatchable","text":"<p>Function objects that act as the entry points in FRAME pallets. Internal or external entities can call them to interact with the blockchain\u2019s state. They are a core aspect of the runtime logic, handling transactions and other state-changing operations.</p>"},{"location":"polkadot-protocol/glossary/#events","title":"Events","text":"<p>A means of recording that some particular state transition happened.</p> <p>In the context of FRAME, events are composable data types that each pallet can individually define. Events in FRAME are implemented as a set of transient storage items inspected immediately after a block has been executed and reset during block initialization.</p>"},{"location":"polkadot-protocol/glossary/#executor","title":"Executor","text":"<p>A means of executing a function call in a given runtime with a set of dependencies. There are two orchestration engines in Polkadot SDK, WebAssembly and native.</p> <ul> <li> <p>The native executor uses a natively compiled runtime embedded in the node to execute calls. This is a performance optimization available to up-to-date nodes</p> </li> <li> <p>The WebAssembly executor uses a Wasm binary and a Wasm interpreter to execute calls. The binary is guaranteed to be up-to-date regardless of the version of the blockchain node because it is persisted in the state of the Polkadot SDK-based chain</p> </li> </ul>"},{"location":"polkadot-protocol/glossary/#existential-deposit","title":"Existential Deposit","text":"<p>The minimum balance an account is allowed to have in the Balances pallet. Accounts cannot be created with a balance less than the existential deposit amount. </p> <p>If an account balance drops below this amount, the Balances pallet uses a FRAME System API to drop its references to that account.</p> <p>If the Balances pallet reference to an account is dropped, the account can be reaped.</p>"},{"location":"polkadot-protocol/glossary/#extrinsic","title":"Extrinsic","text":"<p>A general term for data that originates outside the runtime, is included in a block, and leads to some action. This includes user-initiated transactions and inherent transactions placed into the block by the block builder.</p> <p>It is a SCALE-encoded array typically consisting of a version number, signature, and varying data types indicating the resulting runtime function to be called. Extrinsics can take two forms: inherents and transactions. </p> <p>For more technical details, see the Polkadot spec.</p>"},{"location":"polkadot-protocol/glossary/#fork-choice-rulestrategy","title":"Fork Choice Rule/Strategy","text":"<p>A fork choice rule or strategy helps determine which chain is valid when reconciling several network forks. A common fork choice rule is the longest chain, in which the chain with the most blocks is selected.</p>"},{"location":"polkadot-protocol/glossary/#frame-framework-for-runtime-aggregation-of-modularized-entities","title":"FRAME (Framework for Runtime Aggregation of Modularized Entities)","text":"<p>Enables developers to create blockchain runtime environments from a modular set of components called pallets. It utilizes a set of procedural macros to construct runtimes.</p> <p>Visit the Polkadot SDK docs for more details on FRAME.</p>"},{"location":"polkadot-protocol/glossary/#full-node","title":"Full Node","text":"<p>A node that prunes historical states, keeping only recently finalized block states to reduce storage needs. Full nodes provide current chain state access and allow direct submission and validation of extrinsics, maintaining network decentralization.</p>"},{"location":"polkadot-protocol/glossary/#genesis-configuration","title":"Genesis Configuration","text":"<p>A mechanism for specifying the initial state of a blockchain. By convention, this initial state or first block is commonly referred to as the genesis state or genesis block. The genesis configuration for Polkadot SDK-based chains is accomplished by way of a chain specification file.</p>"},{"location":"polkadot-protocol/glossary/#grandpa","title":"GRANDPA","text":"<p>A deterministic finality mechanism for blockchains that is implemented in the Rust programming language.</p> <p>The formal specification is maintained by the Web3 Foundation.</p>"},{"location":"polkadot-protocol/glossary/#header","title":"Header","text":"<p>A structure that aggregates the information used to summarize a block. Primarily, it consists of cryptographic information used by light clients to get minimally secure but very efficient chain synchronization.</p>"},{"location":"polkadot-protocol/glossary/#hybrid-consensus","title":"Hybrid Consensus","text":"<p>A blockchain consensus protocol that consists of independent or loosely coupled mechanisms for block production and finality.</p> <p>Hybrid consensus allows the chain to grow as fast as probabilistic consensus protocols, such as Aura, while maintaining the same level of security as deterministic finality consensus protocols, such as GRANDPA.</p>"},{"location":"polkadot-protocol/glossary/#inherent-transactions","title":"Inherent Transactions","text":"<p>A special type of unsigned transaction, referred to as inherents, that enables a block authoring node to insert information that doesn't require validation directly into a block.</p> <p>Only the block-authoring node that calls the inherent transaction function can insert data into its block. In general, validators assume the data inserted using an inherent transaction is valid and reasonable even if it can't be deterministically verified.</p>"},{"location":"polkadot-protocol/glossary/#json-rpc","title":"JSON-RPC","text":"<p>A stateless, lightweight remote procedure call protocol encoded in JavaScript Object Notation (JSON). JSON-RPC provides a standard way to call functions on a remote system by using JSON.</p> <p>For Polkadot SDK, this protocol is implemented through the Parity JSON-RPC crate.</p>"},{"location":"polkadot-protocol/glossary/#keystore","title":"Keystore","text":"<p>A subsystem for managing keys for the purpose of producing new blocks.</p>"},{"location":"polkadot-protocol/glossary/#kusama","title":"Kusama","text":"<p>Kusama is a Polkadot SDK-based blockchain that implements a design similar to the Polkadot network.</p> <p>Kusama is a canary network and is referred to as Polkadot's \"wild cousin.\"</p> <p>As a canary network, Kusama is expected to be more stable than a test network like Westend but less stable than a production network like Polkadot. Kusama is controlled by its network participants and is intended to be stable enough to encourage meaningful experimentation.</p>"},{"location":"polkadot-protocol/glossary/#libp2p","title":"libp2p","text":"<p>A peer-to-peer networking stack that allows the use of many transport mechanisms, including WebSockets (usable in a web browser).</p> <p>Polkadot SDK uses the Rust implementation of the <code>libp2p</code> networking stack.</p>"},{"location":"polkadot-protocol/glossary/#light-client","title":"Light Client","text":"<p>A type of blockchain node that doesn't store the chain state or produce blocks.</p> <p>A light client can verify cryptographic primitives and provides a remote procedure call (RPC) server, enabling blockchain users to interact with the network.</p>"},{"location":"polkadot-protocol/glossary/#metadata","title":"Metadata","text":"<p>Data that provides information about one or more aspects of a system. The metadata that exposes information about a Polkadot SDK blockchain enables you to interact with that system.</p>"},{"location":"polkadot-protocol/glossary/#nominated-proof-of-stake-npos","title":"Nominated Proof of Stake (NPoS)","text":"<p>A method for determining validators or authorities based on a willingness to commit their stake to the proper functioning of one or more block-producing nodes.</p>"},{"location":"polkadot-protocol/glossary/#oracle","title":"Oracle","text":"<p>An entity that connects a blockchain to a non-blockchain data source. Oracles enable the blockchain to access and act upon information from existing data sources and incorporate data from non-blockchain systems and services.</p>"},{"location":"polkadot-protocol/glossary/#origin","title":"Origin","text":"<p>A FRAME primitive that identifies the source of a dispatched function call into the runtime. The FRAME System pallet defines three built-in origins. As a pallet developer, you can also define custom origins, such as those defined by the Collective pallet.</p>"},{"location":"polkadot-protocol/glossary/#pallet","title":"Pallet","text":"<p>A module that can be used to extend the capabilities of a FRAME-based runtime. Pallets bundle domain-specific logic with runtime primitives like events and storage items.</p>"},{"location":"polkadot-protocol/glossary/#parachain","title":"Parachain","text":"<p>A parachain is a blockchain that derives shared infrastructure and security from a relay chain. You can learn more about parachains on the Polkadot Wiki.</p>"},{"location":"polkadot-protocol/glossary/#paseo","title":"Paseo","text":"<p>Paseo TestNet provisions testing on Polkadot's \"production\" runtime, which means less chance of feature or code mismatch when developing parachain apps. Specifically, after the Polkadot Technical fellowship proposes a runtime upgrade for Polkadot, this TestNet is updated, giving a period where the TestNet will be ahead of Polkadot to allow for testing.</p>"},{"location":"polkadot-protocol/glossary/#polkadot","title":"Polkadot","text":"<p>The Polkadot network is a blockchain that serves as the central hub of a heterogeneous blockchain network. It serves the role of the relay chain and provides shared infrastructure and security to support parachains.</p>"},{"location":"polkadot-protocol/glossary/#relay-chain","title":"Relay Chain","text":"<p>Relay chains are blockchains that provide shared infrastructure and security to the parachains in the network. In addition to providing consensus capabilities, relay chains allow parachains to communicate and exchange digital assets without needing to trust one another.</p>"},{"location":"polkadot-protocol/glossary/#rococo","title":"Rococo","text":"<p>A parachain test network for the Polkadot network. The Rococo network is a Polkadot SDK-based blockchain with an October 14, 2024 deprecation date. Development teams are encouraged to use the Paseo TestNet instead.</p>"},{"location":"polkadot-protocol/glossary/#runtime","title":"Runtime","text":"<p>The runtime provides the state transition function for a node. In Polkadot SDK, the runtime is stored as a Wasm binary in the chain state.</p>"},{"location":"polkadot-protocol/glossary/#slot","title":"Slot","text":"<p>A fixed, equal interval of time used by consensus engines such as Aura and BABE. In each slot, a subset of authorities is permitted, or obliged, to author a block.</p>"},{"location":"polkadot-protocol/glossary/#sovereign-account","title":"Sovereign Account","text":"<p>The unique account identifier for each chain in the relay chain ecosystem. It is often used in cross-consensus (XCM) interactions to sign XCM messages sent to the relay chain or other chains in the ecosystem.</p> <p>The sovereign account for each chain is a root-level account that can only be accessed using the Sudo pallet or through governance. The account identifier is calculated by concatenating the Blake2 hash of a specific text string and the registered parachain identifier.</p>"},{"location":"polkadot-protocol/glossary/#ss58-address-format","title":"SS58 Address Format","text":"<p>A public key address based on the Bitcoin <code>Base-58-check</code> encoding. Each Polkadot SDK SS58 address uses a <code>base-58</code> encoded value to identify a specific account on a specific Polkadot SDK-based chain</p> <p>The canonical <code>ss58-registry</code> provides additional details about the address format used by different Polkadot SDK-based chains, including the network prefix and website used for different networks</p>"},{"location":"polkadot-protocol/glossary/#state-transition-function-stf","title":"State Transition Function (STF)","text":"<p>The logic of a blockchain that determines how the state changes when a block is processed. In Polkadot SDK, the state transition function is effectively equivalent to the runtime.</p>"},{"location":"polkadot-protocol/glossary/#storage-item","title":"Storage Item","text":"<p>FRAME primitives that provide type-safe data persistence capabilities to the runtime. Learn more in the storage items reference document in the Polkadot SDK.</p>"},{"location":"polkadot-protocol/glossary/#substrate","title":"Substrate","text":"<p>A flexible framework for building modular, efficient, and upgradeable blockchains. Substrate is written in the Rust programming language and is maintained by Parity Technologies.</p>"},{"location":"polkadot-protocol/glossary/#transaction","title":"Transaction","text":"<p>An extrinsic that includes a signature that can be used to verify the account authorizing it inherently or via signed extensions.</p>"},{"location":"polkadot-protocol/glossary/#transaction-era","title":"Transaction Era","text":"<p>A definable period expressed as a range of block numbers during which a transaction can be included in a block. Transaction eras are used to protect against transaction replay attacks if an account is reaped and its replay-protecting nonce is reset to zero.</p>"},{"location":"polkadot-protocol/glossary/#trie-patricia-merkle-tree","title":"Trie (Patricia Merkle Tree)","text":"<p>A data structure used to represent sets of key-value pairs and enables the items in the data set to be stored and retrieved using a cryptographic hash. Because incremental changes to the data set result in a new hash, retrieving data is efficient even if the data set is very large. With this data structure, you can also prove whether the data set includes any particular key-value pair without access to the entire data set.</p> <p>In Polkadot SDK-based blockchains, state is stored in a trie data structure that supports the efficient creation of incremental digests. This trie is exposed to the runtime as a simple key/value map where both keys and values can be arbitrary byte arrays.</p>"},{"location":"polkadot-protocol/glossary/#validator","title":"Validator","text":"<p>A validator is a node that participates in the consensus mechanism of the network. Its roles include block production, transaction validation, network integrity, and security maintenance.</p>"},{"location":"polkadot-protocol/glossary/#webassembly-wasm","title":"WebAssembly (Wasm)","text":"<p>An execution architecture that allows for the efficient, platform-neutral expression of deterministic, machine-executable logic.</p> <p>Wasm can be compiled from many languages, including the Rust programming language. Polkadot SDK-based chains use a Wasm binary to provide portable runtimes that can be included as part of the chain's state.</p>"},{"location":"polkadot-protocol/glossary/#weight","title":"Weight","text":"<p>A convention used in Polkadot SDK-based blockchains to measure and manage the time it takes to validate a block. Polkadot SDK defines one unit of weight as one picosecond of execution time on reference hardware.</p> <p>The maximum block weight should be equivalent to one-third of the target block time with an allocation of one-third each for:</p> <ul> <li>Block construction</li> <li>Network propagation</li> <li>Import and verification</li> </ul> <p>By defining weights, you can trade-off the number of transactions per second and the hardware required to maintain the target block time appropriate for your use case. Weights are defined in the runtime, meaning you can tune them using runtime updates to keep up with hardware and software improvements.</p>"},{"location":"polkadot-protocol/glossary/#westend","title":"Westend","text":"<p>Westend is a Parity-maintained, Polkadot SDK-based blockchain that serves as a test network for the Polkadot network.</p>"},{"location":"polkadot-protocol/architecture/","title":"Architecture","text":"<p>Explore Polkadot's architecture, including the relay chain, parachains, and system chains, and discover the role each component plays in the broader ecosystem.</p>"},{"location":"polkadot-protocol/architecture/#a-brief-look-at-polkadots-chain-ecosystem","title":"A Brief Look at Polkadot\u2019s Chain Ecosystem","text":"<p>The following provides a brief overview of the role of each chain:</p> <ul> <li> <p>Polkadot chain - the central hub and main chain responsible for the overall security, consensus, and interoperability between all connected chains</p> </li> <li> <p>System chains - specialized chains that provide essential services to the ecosystem, like the Asset Hub, Bridge Hub, and Coretime chain</p> </li> <li> <p>Parachains -  individual, specialized blockchains that run parallel to the relay chain and are connected to it</p> </li> </ul> <p>Learn more about these components by checking out the articles in this section.</p>"},{"location":"polkadot-protocol/architecture/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"polkadot-protocol/architecture/parachains/","title":"Parachains","text":"<p>Explore how parachains achieve consensus and leverage shared security through Polkadot\u2019s relay chain and validators within the network\u2019s architecture.</p>"},{"location":"polkadot-protocol/architecture/parachains/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"polkadot-protocol/architecture/parachains/consensus/","title":"Parachain Consensus","text":""},{"location":"polkadot-protocol/architecture/parachains/consensus/#introduction","title":"Introduction","text":"<p>Parachains are independent blockchains built with the Polkadot SDK, designed to leverage Polkadot\u2019s relay chain for shared security and transaction finality. These specialized chains operate as part of Polkadot\u2019s execution sharding model, where each parachain manages its own state and transactions while relying on the relay chain for validation and consensus.</p> <p>At the core of parachain functionality are collators, specialized nodes that sequence transactions into blocks and maintain the parachain\u2019s state. Collators optimize Polkadot\u2019s architecture by offloading state management from the relay chain, allowing relay chain validators to focus solely on validating parachain blocks.</p> <p>This guide explores how parachain consensus works, including the roles of collators and validators, and the steps involved in securing parachain blocks within Polkadot\u2019s scalable and decentralized framework.</p>"},{"location":"polkadot-protocol/architecture/parachains/consensus/#the-role-of-collators","title":"The Role of Collators","text":"<p>Collators are responsible for sequencing end-user transactions into blocks and maintaining the current state of their respective parachains. Their role is akin to Ethereum\u2019s sequencers but optimized for Polkadot's architecture.</p> <p>Key responsibilities include:</p> <ul> <li>Transaction sequencing - organizing transactions into Proof of Validity (PoV) blocks</li> <li>State management - maintaining parachain states without burdening the relay chain validators</li> <li>Consensus participation - sending PoV blocks to relay chain validators for approval</li> </ul>"},{"location":"polkadot-protocol/architecture/parachains/consensus/#consensus-and-validation","title":"Consensus and Validation","text":"<p>Parachain consensus operates in tandem with the relay chain, leveraging Nominated Proof of Stake (NPoS) for shared security. The process ensures parachain transactions achieve finality through the following steps:</p> <ol> <li>Packaging transactions - collators bundle transactions into PoV blocks (parablocks)</li> <li>Submission to validator - parablocks are submitted to a randomly selected subset of relay chain validators, known as paravalidators</li> <li>Validation of PoV Blocks - paravalidators use the parachain\u2019s state transition function (already available on the relay chain) to verify transaction validity</li> <li>Backing and inclusion - if a sufficient number of positive validations are received, the parablock is backed and included via a para-header on the relay chain</li> </ol> <p>The following sections describe the actions taking place during each stage of the process. </p>"},{"location":"polkadot-protocol/architecture/parachains/consensus/#path-of-a-parachain-block","title":"Path of a Parachain Block","text":"<p>Polkadot achieves scalability through execution sharding, where each parachain operates as an independent shard with its own blockchain and state. Shared security for all parachains is provided by the relay chain, powered by Nominated Proof of Staking (NPoS). This framework allows parachains to focus on transaction processing and state management, while the relay chain ensures validation and finality.</p> <p>The journey parachain transactions follow to reach consensus and finality can be described as follows:</p> <ul> <li> <p>Collators and parablocks:</p> <ul> <li>Collators, specialized nodes on parachains, package network transactions into Proof of Validity (PoV) blocks, also called parablocks</li> <li>These parablocks are sent to a subset of relay chain validators, known as paravalidators, for validation</li> <li>The parachain's state transition function (Wasm blob) is not re-sent, as it is already stored on the relay chain</li> </ul> </li> </ul> <pre><code>flowchart TB\n    %% Subgraph: Parachain\n    subgraph Parachain\n        direction LR\n        Txs[Network Transactions]\n        Collator[Collator Node]\n        ParaBlock[ParaBlock + PoV]\n        Txs --&gt;|Package Transactions| Collator\n        Collator --&gt;|Create| ParaBlock\n    end\n\n    subgraph Relay[\"Relay Chain\"]\n        ParaValidator\n    end\n\n    %% Main Flow\n    Parachain --&gt;|Submit To| Relay</code></pre> <ul> <li> <p>Validation by paravalidators:</p> <ul> <li>Paravalidators are groups of approximately five relay chain validators, randomly assigned to parachains and shuffled every minute</li> <li>Each paravalidator downloads the parachain's Wasm blob and validates the parablock by ensuring all transactions comply with the parachain\u2019s state transition rules</li> <li>Paravalidators sign positive or negative validation statements based on the block\u2019s validity</li> </ul> </li> <li> <p>Backing and approval:</p> <ul> <li>If a parablock receives sufficient positive validation statements, it is backed and included on the relay chain as a para-header</li> <li>An additional approval process resolves disputes. If a parablock contains invalid transactions, additional validators are tasked with verification</li> <li>Validators who back invalid parablocks are penalized through slashing, creating strong incentives for honest behavior</li> </ul> </li> </ul> <pre><code>flowchart\n    subgraph RelayChain[\"Relay Chain\"]\n        direction TB\n        subgraph InitialValidation[\"Initial Validation\"]\n            direction LR\n            PValidators[ParaValidators]\n            Backing[Backing\\nProcess]\n            Header[Submit Para-header\\non Relay Chain]\n        end\n        subgraph Secondary[\"Secondary Validation\"]\n            Approval[Approval\\nProcess]\n            Dispute[Dispute\\nResolution]\n            Slashing[Slashing\\nMechanism]\n        end\n\n    end\n\n\n    %% Validation Process\n    PValidators --&gt;|Download\\nWasm\\nValidate Block| Backing\n    Backing --&gt;|If Valid\\nSignatures| Header\n    InitialValidation --&gt;|Additional\\nVerification| Secondary\n\n    %% Dispute Flow\n    Approval --&gt;|If Invalid\\nDetected| Dispute\n    Dispute --&gt;|Penalize\\nDishonest\\nValidators| Slashing</code></pre> <p>It is important to understand that relay chain blocks do not store full parachain blocks (parablocks). Instead, they include para-headers, which serve as summaries of the backed parablocks. The complete parablock remains within the parachain network, maintaining its autonomy while relying on the relay chain for validation and finality.</p>"},{"location":"polkadot-protocol/architecture/parachains/consensus/#where-to-go-next","title":"Where to Go Next","text":"<p>For more technical details, refer to the:</p> <ul> <li>Parachain Wiki page</li> <li>Polkadot SDK Implementation Guide section</li> </ul>"},{"location":"polkadot-protocol/architecture/parachains/overview/","title":"Overview","text":""},{"location":"polkadot-protocol/architecture/parachains/overview/#introduction","title":"Introduction","text":"<p>A parachain is a coherent, application-specific blockchain that derives security from its respective relay chain. Parachains on Polkadot are each their own separate, fully functioning blockchain. The primary difference between a parachain and a regular, \"solo\" blockchain is that the relay chain verifies the state of all parachains that are connected to it.  In many ways, parachains can be thought of as a \"cynical\" rollup, as the crypto-economic protocol used (ELVES) assumes the worst-case scenario, rather than the typical optimistic approach that many roll-up mechanisms take. Once enough validators attest that a block is valid, then the probability of that block being valid is high.</p> <p>As each parachain\u2019s state is validated by the relay chain, the relay chain represents the collective state of all parachains.</p> <pre><code>flowchart TB\n    subgraph \"Relay Chain\"\n        RC[Relay Chain Validators]\n        State[Collective State Validation]\n    end\n\n    PA[Parachain A]\n    PB[Parachain B]\n    PC[Parachain C]\n\n    RC --&gt;|Validate State| PA\n    RC --&gt;|Validate State| PB\n    RC --&gt;|Validate State| PC\n\n    State --&gt;|Represents Collective\\nParachain State| RC\n\n    note[\"ELVES Protocol:\\n- Crypto-economic security\\n- Assumes worst-case scenario\\n- High probability validation\"]</code></pre> <p>Coherent Systems</p> <p>Coherency refers to the degree of synchronization, consistency, and interoperability between different components or chains within a system. It encompasses the internal coherence of individual chains and the external coherence between chains regarding how they interact.</p> <p>A single-state machine like Ethereum is very coherent, as all of its components (smart contracts, dApps/applications, staking, consensus) operate within a single environment with the downside of less scalability. Multi-protocol state machines, such as Polkadot, offer less coherency due to their sharded nature but more scalability due to the parallelization of their architecture.</p> <p>Parachains are coherent, as they are self-contained environments with domain-specific functionality.</p> <p>Parachains enable parallelization of different services within the same network. However, unlike most layer two rollups, parachains don't suffer the same interoperability pitfalls that most rollups suffer. Cross-Consensus Messaging (XCM) provides a common communication format for each parachain and can be configured to allow a parachain to communicate with just the relay chain or certain parachains. </p> <p>The diagram below highlights the flexibility of the Polkadot ecosystem, where each parachain specializes in a distinct domain. This example illustrates how parachains, like DeFi and GameFi, leverage XCM for cross-chain operations such as asset transfers and credential verification.</p> <pre><code>flowchart TB\n    subgraph \"Polkadot Relay Chain\"\n        RC[Relay Chain\\nCross-Consensus\\nRouting]\n    end\n\n    subgraph \"Parachain Ecosystem\"\n        direction TB\n        DeFi[DeFi Parachain\\nFinancial Services]\n        GameFi[GameFi Parachain\\nGaming Ecosystem]\n        NFT[NFT Parachain\\nDigital Collectibles]\n        Identity[Identity Parachain\\nUser Verification]\n    end\n\n    DeFi &lt;--&gt;|XCM: Asset Transfer| GameFi\n    GameFi &lt;--&gt;|XCM: Token Exchange| NFT\n    Identity &lt;--&gt;|XCM: Credential Verification| DeFi\n\n    RC --&gt;|Validate &amp; Route XCM| DeFi\n    RC --&gt;|Validate &amp; Route XCM| GameFi\n    RC --&gt;|Validate &amp; Route XCM| NFT\n    RC --&gt;|Validate &amp; Route XCM| Identity\n\n    note[\"XCM Features:\\n- Standardized Messaging\\n- Cross-Chain Interactions\\n- Secure Asset/Data Transfer\"]</code></pre> <p>Most parachains are built using the Polkadot SDK, which provides all the tools to create a fully functioning parachain. However, it is possible to construct a parachain that can inherit the security of the relay chain as long as it implements the correct mechanisms expected by the relay chain.</p>"},{"location":"polkadot-protocol/architecture/parachains/overview/#state-transition-functions-runtimes","title":"State Transition Functions (Runtimes)","text":"<p>At their core, parachains, like most blockchains, are deterministic, finite-state machines that are often backed by game theory and economics. The previous state of the parachain, combined with external input in the form of extrinsics, allows the state machine to progress forward, one block at a time.</p> <p>Deterministic State Machines</p> <p>Determinism refers to the concept that a particular input will always produce the same output. State machines are algorithmic machines that state changes based on their inputs to produce a new, updated state.</p> <pre><code>stateDiagram-v2\n    direction LR\n    [*] --&gt; StateA : Initial State\n\n    StateA --&gt; STF : Extrinsics/Transactions\n    STF --&gt; StateB : Deterministic Transformation\n    StateB --&gt; [*] : New State</code></pre> <p>The primary driver of this progression is the state transition function (STF), commonly referred to as a runtime. Each time a block is submitted, it represents the next proposed state for a parachain. By applying the state transition function to the previous state and including a new block that contains the proposed changes in the form of a list of extrinsics/transactions, the runtime defines just exactly how the parachain is to advance from state A to state B.</p> <p>The STF in a Polkadot SDK-based chain is compiled to Wasm and uploaded on the relay chain. This STF is crucial for the relay chain to validate the state changes coming from the parachain, as it is used to ensure that all proposed state transitions are happening correctly as part of the validation process.</p> <p>Wasm Runtimes</p> <p>For more information on the Wasm meta protocol that powers runtimes, see the Polkadot SDK Rust Docs: WASM Meta Protocol</p>"},{"location":"polkadot-protocol/architecture/parachains/overview/#shared-security-validated-by-the-relay-chain","title":"Shared Security: Validated by the Relay Chain","text":"<p>The relay chain provides a layer of economic security for its parachains. Parachains submit proof of validation (PoV) data to the relay chain for validation through collators, upon which the relay chains' validators ensure the validity of this data in accordance with the STF for that particular parachain. In other words, the consensus for a parachain follows the relay chain. While parachains choose how a block is authored, what it contains, and who authors it, the relay chain ultimately provides finality and consensus for those blocks.</p> <p>The Parachains Protocol</p> <p>For more information regarding the parachain and relay chain validation process, view the Polkadot Wiki: Parachains' Protocol Overview: Protocols' Summary</p> <p>Parachains need at least one honest collator to submit PoV data to the relay chain. Without this, the parachain can't progress. The mechanisms that facilitate this are found in the Cumulus portion of the Polkadot SDK, some of which are found in the <code>cumulus_pallet_parachain_system</code></p>"},{"location":"polkadot-protocol/architecture/parachains/overview/#cryptoeconomic-security-elves-protocol","title":"Cryptoeconomic Security: ELVES Protocol","text":"<p>The ELVES (Economic Last Validation Enforcement System) protocol forms the foundation of Polkadot's cryptoeconomic security model. ELVES assumes a worst-case scenario by enforcing strict validation rules before any state transitions are finalized. Unlike optimistic approaches that rely on post-facto dispute resolution, ELVES ensures that validators collectively confirm the validity of a block before it becomes part of the parachain's state.</p> <p>Validators are incentivized through staking and penalized for malicious or erroneous actions, ensuring adherence to the protocol. This approach minimizes the probability of invalid states being propagated across the network, providing robust security for parachains.</p>"},{"location":"polkadot-protocol/architecture/parachains/overview/#interoperability","title":"Interoperability","text":"<p>Polkadot's interoperability framework allows parachains to communicate with each other, fostering a diverse ecosystem of interconnected blockchains. Through Cross-Consensus Messaging (XCM), parachains can transfer assets, share data, and invoke functionalities on other chains securely. This standardized messaging protocol ensures that parachains can interact with the relay chain and each other, supporting efficient cross-chain operations.</p> <p>The XCM protocol mitigates common interoperability challenges in isolated blockchain networks, such as fragmented ecosystems and limited collaboration. By enabling decentralized applications to leverage resources and functionality across parachains, Polkadot promotes a scalable, cooperative blockchain environment that benefits all participants.</p>"},{"location":"polkadot-protocol/architecture/parachains/overview/#where-to-go-next","title":"Where to Go Next","text":"<p>For further information about the consensus protocol used by parachains, see the Consensus page.</p>"},{"location":"polkadot-protocol/architecture/polkadot-chain/","title":"The Polkadot Relay Chain","text":"<p>Explore the relay chain\u2019s role in Polkadot, providing shared security, consensus, and enabling agile coretime for parachains to purchase blockspace on-demand.</p>"},{"location":"polkadot-protocol/architecture/polkadot-chain/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"polkadot-protocol/architecture/polkadot-chain/agile-coretime/","title":"Agile Coretime","text":""},{"location":"polkadot-protocol/architecture/polkadot-chain/agile-coretime/#introduction","title":"Introduction","text":"<p>Agile Coretime is the scheduling framework on Polkadot that lets parachains efficiently access cores, which comprise an active validator set tasked with parablock validation. As the first blockchain to enable a flexible scheduling system for blockspace production, Polkadot offers unparalleled adaptability for parachains.</p> <p>Cores can be designated to a parachain either continuously through bulk coretime or dynamically via on-demand coretime. Additionally, Polkadot supports scheduling multiple cores in parallel through elastic scaling, which is a feature under active development on Polkadot. This flexibility empowers parachains to optimize their resource usage and block production according to their unique needs.</p> <p>In this guide, you'll learn how bulk coretime enables continuous core access with features like interlacing and splitting, and how on-demand coretime provides flexible, pay-per-use scheduling for parachains. For a deep dive on Agile Coretime and its terminology, refer to the Wiki doc.</p>"},{"location":"polkadot-protocol/architecture/polkadot-chain/agile-coretime/#bulk-coretime","title":"Bulk Coretime","text":"<p>Bulk coretime is a fixed duration of continuous coretime represented by an NFT that can be purchased through coretime sales in DOT and can be split, shared, or resold. Currently, the duration of bulk coretime is set to 28 days. Coretime purchased in bulk and assigned to a single parachain is eligible for a price-capped renewal, providing a form of rent-controlled access, which is important for predicting the running costs in the near future. Suppose the bulk coretime is interlaced or split or is kept idle without assigning it to a parachain. In that case, it will be ineligible for the price-capped renewal.</p>"},{"location":"polkadot-protocol/architecture/polkadot-chain/agile-coretime/#coretime-interlacing","title":"Coretime Interlacing","text":"<p>It is the action of dividing bulk coretime across multiple parachains that produce blocks spaced uniformly in time. For example, think of multiple parachains taking turns producing blocks, demonstrating a simple form of interlacing. This feature can be used by parachains with a low transaction volume and need not continuously produce blocks.</p>"},{"location":"polkadot-protocol/architecture/polkadot-chain/agile-coretime/#coretime-splitting","title":"Coretime Splitting","text":"<p>It is the action of dividing bulk coretime into multiple contiguous regions. This feature can be used by parachains that need to produce blocks continuously but do not require the whole 28 days of bulk coretime and require only part of it.</p>"},{"location":"polkadot-protocol/architecture/polkadot-chain/agile-coretime/#on-demand-coretime","title":"On-Demand Coretime","text":"<p>Polkadot has dedicated cores assigned to provide core time on demand. These cores are excluded from the coretime sales and are reserved for on-demand parachains, which pay in DOT per block.</p>"},{"location":"polkadot-protocol/architecture/polkadot-chain/overview/","title":"Overview","text":""},{"location":"polkadot-protocol/architecture/polkadot-chain/overview/#introduction","title":"Introduction","text":"<p>Polkadot is a next-generation blockchain protocol designed to support a multi-chain future by enabling secure communication and interoperability between different blockchains. Built as a Layer-0 protocol, Polkadot introduces innovations like application-specific Layer-1 chains (parachains), shared security through Nominated Proof of Stake (NPoS), and seamless cross-chain interactions via its native Cross-Consensus Messaging Format (XCM).</p> <p>This guide covers key aspects of Polkadot\u2019s architecture, including its high-level protocol structure, runtime upgrades, blockspace commoditization, and the role of its native token, DOT, in governance, staking, and resource allocation.</p>"},{"location":"polkadot-protocol/architecture/polkadot-chain/overview/#polkadot-10","title":"Polkadot 1.0","text":"<p>Polkadot 1.0 represents the state of Polkadot as of 2023, coinciding with the release of Polkadot runtime v1.0.0. This section will focus on Polkadot 1.0, along with philosophical insights into network resilience and blockspace.</p> <p>As a Layer-0 blockchain, Polkadot contributes to the multi-chain vision through several key innovations and initiatives, including:</p> <ul> <li> <p>Application-specific Layer-1 blockchains (parachains) - Polkadot's sharded network allows for parallel transaction processing, with shards that can have unique state transition functions, enabling custom-built L1 chains optimized for specific applications</p> </li> <li> <p>Shared security and scalability - L1 chains connected to Polkadot benefit from its Nominated Proof of Stake (NPoS) system, providing security out-of-the-box without the need to bootstrap their own</p> </li> <li> <p>Secure interoperability - Polkadot's native interoperability enables seamless data and value exchange between parachains. This interoperability can also be used outside of the ecosystem for bridging with external networks</p> </li> <li> <p>Resilient infrastructure - decentralized and scalable, Polkadot ensures ongoing support for development and community initiatives via its on-chain treasury and governance</p> </li> <li> <p>Rapid L1 development - the Polkadot SDK allows fast, flexible creation and deployment of Layer-1 chains</p> </li> <li> <p>Cultivating the next generation of Web3 developers - Polkadot supports the growth of Web3 core developers through initiatives such as:</p> <ul> <li>Polkadot Blockchain Academy</li> <li>Polkadot Alpha Program</li> <li>EdX courses</li> <li>Rust and Substrate courses (coming soon)</li> </ul> </li> </ul>"},{"location":"polkadot-protocol/architecture/polkadot-chain/overview/#high-level-architecture","title":"High-Level Architecture","text":"<p>Polkadot features a chain that serves as the central component of the system. This chain is depicted as a ring encircled by several parachains that are connected to it.</p> <p>According to Polkadot's design, any blockchain that can compile to WebAssembly (Wasm) and adheres to the Parachains Protocol becomes a parachain on the Polkadot network.</p> <p>Here\u2019s a high-level overview of the Polkadot protocol architecture:</p> <p></p> <p>Parachains propose blocks to Polkadot validators, who check for availability and validity before finalizing them. With the relay chain providing security, collators\u2014full nodes of parachains\u2014can focus on their tasks without needing strong incentives.</p> <p>The Cross-Consensus Messaging Format (XCM) allows parachains to exchange messages freely, leveraging the chain's security for trust-free communication.</p> <p>In order to interact with chains that want to use their own finalization process (e.g., Bitcoin), Polkadot has bridges that offer two-way compatibility, meaning that transactions can be made between different parachains.</p>"},{"location":"polkadot-protocol/architecture/polkadot-chain/overview/#polkadots-additional-functionalities","title":"Polkadot's Additional Functionalities","text":"<p>The Polkadot chain oversees crowdloans and auctions. Chain cores were leased through auctions for three-month periods, up to a maximum of two years.</p> <p>Crowdloans enabled users to securely lend funds to teams for lease deposits in exchange for pre-sale tokens, which is the only way to access slots on Polkadot 1.0.</p> <p>Note</p> <p>Auctions are deprecated in favor of coretime.</p> <p>Additionally, the chain handles staking, accounts, balances, and governance.</p>"},{"location":"polkadot-protocol/architecture/polkadot-chain/overview/#agile-coretime","title":"Agile Coretime","text":"<p>The new and more efficient way of obtaining core on Polkadot is to go through the process of purchasing coretime.</p> <p>Agile coretime improves the efficient use of Polkadot's network resources and offers economic flexibility for developers, extending Polkadot's capabilities far beyond the original vision outlined in the whitepaper.</p> <p>It enables parachains to purchase monthly \"bulk\" allocations of coretime (the time allocated for utilizing a core, measured in Polkadot relay chain blocks), ensuring heavy-duty parachains that can author a block every six seconds with Asynchronous Backing can reliably renew their coretime each month. Although six-second block times are now the default, parachains have the option of producing blocks less frequently.</p> <p>Renewal orders are prioritized over new orders, offering stability against price fluctuations and helping parachains budget more effectively for project costs.</p>"},{"location":"polkadot-protocol/architecture/polkadot-chain/overview/#polkadots-resilience","title":"Polkadot's Resilience","text":"<p>Decentralization is a vital component of blockchain networks, but it comes with trade-offs:</p> <ul> <li>An overly decentralized network may face challenges in reaching consensus and require significant energy to operate</li> <li>Also, a network that achieves consensus quickly risks centralization, making it easier to manipulate or attack</li> </ul> <p>A network should be decentralized enough to prevent manipulative or malicious influence. In this sense, decentralization is a tool for achieving resilience.</p> <p>Polkadot 1.0 currently achieves resilience through several strategies:</p> <ul> <li> <p>Nominated Proof of Stake (NPoS) - this ensures that the stake per validator is maximized and evenly distributed among validators</p> </li> <li> <p>Decentralized nodes - designed to encourage operators to join the network. This program aims to expand and diversify the validators in the ecosystem who aim to become independent of the program during their term. Feel free to explore more about the program on the official Decentralized Nodes page</p> </li> <li> <p>On-chain treasury and governance - known as OpenGov, this system allows every decision to be made through public referenda, enabling any token holder to cast a vote</p> </li> </ul>"},{"location":"polkadot-protocol/architecture/polkadot-chain/overview/#polkadots-blockspace","title":"Polkadot's Blockspace","text":"<p>Polkadot 1.0\u2019s design allows for the commoditization of blockspace.</p> <p>Blockspace is a blockchain's capacity to finalize and commit operations, encompassing its security, computing, and storage capabilities. Its characteristics can vary across different blockchains, affecting security, flexibility, and availability.</p> <ul> <li> <p>Security - measures the robustness of blockspace in Proof of Stake (PoS) networks linked to the stake locked on validator nodes, the variance in stake among validators, and the total number of validators. It also considers social centralization (how many validators are owned by single operators) and physical centralization (how many validators run on the same service provider)</p> </li> <li> <p>Flexibility - reflects the functionalities and types of data that can be stored, with high-quality data essential to avoid bottlenecks in critical processes</p> </li> <li> <p>Availability - indicates how easily users can access blockspace. It should be easily accessible, allowing diverse business models to thrive, ideally regulated by a marketplace based on demand and supplemented by options for \"second-hand\" blockspace</p> </li> </ul> <p>Polkadot is built on core blockspace principles, but there's room for improvement. Tasks like balance transfers, staking, and governance are managed on the relay chain.</p> <p>Delegating these responsibilities to system chains could enhance flexibility and allow the relay chain to concentrate on providing shared security and interoperability.</p> <p>Note</p> <p>For more information about blockspace, watch Robert Habermeier\u2019s interview or read his technical blog post.</p>"},{"location":"polkadot-protocol/architecture/polkadot-chain/overview/#dot-token","title":"DOT Token","text":"<p>DOT is the native token of the Polkadot network, much like BTC for Bitcoin and Ether for the Ethereum blockchain. DOT has 10 decimals, uses the Planck base unit, and has a balance type of <code>u128</code>. The same is true for Kusama's KSM token with the exception of having 12 decimals.</p> Redenomination of DOT <p>Polkadot conducted a community poll, which ended on 27 July 2020 at block 888,888, to decide whether to redenominate the DOT token. The stakeholders chose to redenominate the token, changing the value of 1 DOT from 1e12 plancks to 1e10 plancks.</p> <p>Importantly, this did not affect the network's total number of base units (plancks); it only affects how a single DOT is represented.</p> <p>The redenomination became effective 72 hours after transfers were enabled, occurring at block 1,248,328 on 21 August 2020 around 16:50 UTC.</p>"},{"location":"polkadot-protocol/architecture/polkadot-chain/overview/#the-planck-unit","title":"The Planck Unit","text":"<p>The smallest unit of account balance on Substrate-based blockchains (such as Polkadot and Kusama) is called Planck, named after the Planck length, the smallest measurable distance in the physical universe.</p> <p>Similar to how BTC's smallest unit is the Satoshi and ETH's is the Wei, Polkadot's native token DOT equals 1e10 Planck, while Kusama's native token KSM equals 1e12 Planck.</p>"},{"location":"polkadot-protocol/architecture/polkadot-chain/overview/#uses-for-dot","title":"Uses for DOT","text":"<p>DOT serves three primary functions within the Polkadot network:</p> <ul> <li>Governance - it is used to participate in the governance of the network</li> <li>Staking - DOT is staked to support the network's operation and security</li> <li>Buying coretime - used to purchase coretime in-bulk or on-demand and access the  chain to benefit from Polkadot's security and interoperability</li> </ul> <p>Additionally, DOT can serve as a transferable token. For example, DOT, held in the treasury, can be allocated to teams developing projects that benefit the Polkadot ecosystem.</p>"},{"location":"polkadot-protocol/architecture/polkadot-chain/overview/#jam-and-the-road-ahead","title":"JAM and the Road Ahead","text":"<p>The Join-Accumulate Machine (JAM) represents a transformative redesign of Polkadot's core architecture, envisioned as the successor to the current relay chain. Unlike traditional blockchain architectures, JAM introduces a unique computational model that processes work through two primary functions:</p> <ul> <li>Join - handles data integration</li> <li>Accumulate - folds computations into the chain's state</li> </ul> <p>JAM removes many of the opinions and constraints of the current relay chain while maintaining its core security properties. Expected improvements include:</p> <ul> <li>Permissionless code execution - JAM is designed to be more generic and flexible, allowing for permissionless code execution through services that can be deployed without governance approval</li> <li>More effective block time utilization - JAM's efficient pipeline processing model places the prior state root in block headers instead of the posterior state root, enabling more effective utilization of block time for computations</li> </ul> <p>This architectural evolution promises to enhance Polkadot's scalability and flexibility while maintaining robust security guarantees. JAM is planned to be rolled out to Polkadot as a single, complete upgrade rather than a stream of smaller updates. This approach seeks to minimize the developer overhead required to address any breaking changes.</p>"},{"location":"polkadot-protocol/architecture/polkadot-chain/pos-consensus/","title":"Proof of Stake Consensus","text":""},{"location":"polkadot-protocol/architecture/polkadot-chain/pos-consensus/#introduction","title":"Introduction","text":"<p>Polkadot's Proof of Stake consensus model leverages a unique hybrid approach by design to promote decentralized and secure network operations. In traditional Proof of Stake (PoS) systems, a node's ability to validate transactions is tied to its token holdings, which can lead to centralization risks and limited validator participation. Polkadot addresses these concerns through its Nominated Proof of Stake (NPoS) model and a combination of advanced consensus mechanisms to ensure efficient block production and strong finality guarantees. This combination enables the Polkadot network to scale while maintaining security and decentralization.</p>"},{"location":"polkadot-protocol/architecture/polkadot-chain/pos-consensus/#nominated-proof-of-stake","title":"Nominated Proof of Stake","text":"<p>Polkadot uses Nominated Proof of Stake (NPoS) to select the validator set and secure the network. This model is designed to maximize decentralization and security by balancing the roles of validators and nominators.</p> <ul> <li>Validators - play a key role in maintaining the network's integrity. They produce new blocks, validate parachain blocks, and ensure the finality of transactions across the relay chain</li> <li>Nominators - support the network by selecting validators to back with their stake. This mechanism allows users who don't want to run a validator node to still participate in securing the network and earn rewards based on the validators they support</li> </ul> <p>In Polkadot's NPoS system, nominators can delegate their tokens to trusted validators, giving them voting power in selecting validators while spreading security responsibilities across the network.</p>"},{"location":"polkadot-protocol/architecture/polkadot-chain/pos-consensus/#hybrid-consensus","title":"Hybrid Consensus","text":"<p>Polkadot employs a hybrid consensus model that combines two key protocols: a finality gadget called GRANDPA and a block production mechanism known as BABE. This hybrid approach enables the network to benefit from both rapid block production and provable finality, ensuring security and performance.</p> <p>The hybrid consensus model has some key advantages:</p> <ul> <li> <p>Probabilistic finality - with BABE constantly producing new blocks, Polkadot ensures that the network continues to make progress, even when a final decision has not yet been reached on which chain is the true canonical chain</p> </li> <li> <p>Provable finality - GRANDPA guarantees that once a block is finalized, it can never be reverted, ensuring that all network participants agree on the finalized chain</p> </li> </ul> <p>By using separate protocols for block production and finality, Polkadot can achieve rapid block creation and strong guarantees of finality while avoiding the typical trade-offs seen in traditional consensus mechanisms.</p>"},{"location":"polkadot-protocol/architecture/polkadot-chain/pos-consensus/#block-production-babe","title":"Block Production - BABE","text":"<p>Blind Assignment for Blockchain Extension (BABE) is Polkadot's block production mechanism, working with GRANDPA to ensure blocks are produced consistently across the network. As validators participate in BABE, they are assigned block production slots through a randomness-based lottery system. This helps determine which validator is responsible for producing a block at a given time. BABE shares similarities with Ouroboros Praos but differs in key aspects like chain selection rules and slot timing.</p> <p>Key features of BABE include:</p> <ul> <li> <p>Epochs and slots - BABE operates in phases called epochs, each of which is divided into slots (around 6 seconds per slot). Validators are assigned slots at the beginning of each epoch based on stake and randomness</p> </li> <li> <p>Randomized block production - validators enter a lottery to determine which will produce a block in a specific slot. This randomness is sourced from the relay chain's randomness cycle</p> </li> <li> <p>Multiple block producers per slot - in some cases, more than one validator might win the lottery for the same slot, resulting in multiple blocks being produced. These blocks are broadcasted, and the network's fork choice rule helps decide which chain to follow</p> </li> <li> <p>Handling empty slots - if no validators win the lottery for a slot, a secondary selection algorithm ensures that a block is still produced. Validators selected through this method always produce a block, ensuring no slots are skipped</p> </li> </ul> <p>BABE's combination of randomness and slot allocation creates a secure, decentralized system for consistent block production while also allowing for fork resolution when multiple validators produce blocks for the same slot.</p> Additional Information <ul> <li>Refer to the BABE paper for further technical insights, including cryptographic details and formal proofs</li> <li>Visit the Block Production Lottery section of the Polkadot Protocol Specification for technical definitions and formulas</li> </ul>"},{"location":"polkadot-protocol/architecture/polkadot-chain/pos-consensus/#validator-participation","title":"Validator Participation","text":"<p>In BABE, validators participate in a lottery for every slot to determine whether they are responsible for producing a block during that slot. This process's randomness ensures a decentralized and unpredictable block production mechanism.</p> <p>There are two lottery outcomes for any given slot that initiate additional processes:</p> <ul> <li> <p>Multiple validators in a slot - due to the randomness, multiple validators can be selected to produce a block for the same slot. When this happens, each validator produces a block and broadcasts it to the network resulting in a race condition. The network's topology and latency then determine which block reaches the majority of nodes first. BABE allows both chains to continue building until the finalization process resolves which one becomes canonical. The Fork Choice rule is then used to decide which chain the network should follow</p> </li> <li> <p>No validators in a slot - on occasions when no validator is selected by the lottery, a secondary validator selection algorithm steps in. This backup ensures that a block is still produced, preventing skipped slots. However, if the primary block produced by a verifiable random function (VRF)-selected validator exists for that slot, the secondary block will be ignored. As a result, every slot will have either a primary or a secondary block</p> </li> </ul> <p>This design ensures continuous block production, even in cases of multiple competing validators or an absence of selected validators.</p>"},{"location":"polkadot-protocol/architecture/polkadot-chain/pos-consensus/#finality-gadget-grandpa","title":"Finality Gadget - GRANDPA","text":"<p>GRANDPA (GHOST-based Recursive ANcestor Deriving Prefix Agreement) serves as the finality gadget for Polkadot's relay chain. Operating alongside the BABE block production mechanism, it ensures provable finality, giving participants confidence that blocks finalized by GRANDPA cannot be reverted.</p> <p>Key features of GRANDPA include:</p> <ul> <li>Independent finality service \u2013 GRANDPA runs separately from the block production process, operating in parallel to ensure seamless finalization</li> <li>Chain-based finalization \u2013 instead of finalizing one block at a time, GRANDPA finalizes entire chains, speeding up the process significantly</li> <li>Batch finalization \u2013 can finalize multiple blocks in a single round, enhancing efficiency and minimizing delays in the network</li> <li>Partial synchrony tolerance \u2013 GRANDPA works effectively in a partially synchronous network environment, managing both asynchronous and synchronous conditions</li> <li>Byzantine fault tolerance \u2013 can handle up to 1/5 Byzantine (malicious) nodes, ensuring the system remains secure even when faced with adversarial behavior</li> </ul> What is GHOST? <p>GHOST (Greedy Heaviest-Observed Subtree) is a consensus protocol used in blockchain networks to select the heaviest branch in a block tree. Unlike traditional longest-chain rules, GHOST can more efficiently handle high block production rates by considering the weight of subtrees rather than just the chain length.</p>"},{"location":"polkadot-protocol/architecture/polkadot-chain/pos-consensus/#probabilistic-vs-provable-finality","title":"Probabilistic vs. Provable Finality","text":"<p>In traditional Proof of Work (PoW) blockchains, finality is probabilistic. As blocks are added to the chain, the probability that a block is final increases, but it can never be guaranteed. Eventual consensus means that over time, all nodes will agree on a single version of the blockchain, but this process can be unpredictable and slow.</p> <p>Conversely, GRANDPA provides provable finality, which means that once a block is finalized, it is irreversible. By using Byzantine fault-tolerant agreements, GRANDPA finalizes blocks more efficiently and securely than probabilistic mechanisms like Nakamoto consensus. Like Ethereum's Casper the Friendly Finality Gadget(FFG), GRANDPA ensures that finalized blocks cannot be reverted, offering stronger guarantees of consensus.</p> Additional Information <p>For more details, including formal proofs and detailed algorithms, see the GRANDPA paper.</p>"},{"location":"polkadot-protocol/architecture/polkadot-chain/pos-consensus/#fork-choice","title":"Fork Choice","text":"<p>The fork choice of the relay chain combines BABE and GRANDPA:</p> <ol> <li>BABE must always build on the chain that GRANDPA has finalized</li> <li>When there are forks after the finalized head, BABE builds on the chain with the most primary blocks to provide probabilistic finality </li> </ol> <p></p> <p>In the preceding diagram, finalized blocks are black, and non-finalized blocks are yellow. Primary blocks are labeled '1', and secondary blocks are labeled '2.' The topmost chain is the longest chain originating from the last finalized block, but it is not selected because it only has one primary block at the time of evaluation. In comparison, the one below it originates from the last finalized block and has three primary blocks.</p>"},{"location":"polkadot-protocol/architecture/polkadot-chain/pos-consensus/#bridging-beefy","title":"Bridging - BEEFY","text":"<p>Bridge Efficiency Enabling Finality Yielder (BEEFY) is a specialized protocol that extends the finality guarantees provided by GRANDPA. It is specifically designed to facilitate efficient bridging between Polkadot relay chains (such as Polkadot and Kusama) and external blockchains like Ethereum. While GRANDPA is well-suited for finalizing blocks within Polkadot, it has limitations when bridging external chains that weren't built with Polkadot's interoperability features in mind. BEEFY addresses these limitations by ensuring other networks can efficiently verify finality proofs.</p> <p>Key features of BEEFY include:</p> <ul> <li>Efficient finality proof verification - BEEFY enables external networks to easily verify Polkadot finality proofs, ensuring seamless communication between chains</li> <li>Merkle Mountain Ranges (MMR) - this data structure is used to efficiently store and transmit proofs between chains, optimizing data storage and reducing transmission overhead</li> <li>ECDSA signature schemes - BEEFY uses ECDSA signatures, which are widely supported on Ethereum and other EVM-based chains, making integration with these ecosystems smoother</li> <li>Light client optimization - BEEFY reduces the computational burden on light clients by allowing them to check for a super-majority of validator votes rather than needing to process all validator signatures, improving performance</li> </ul> Additional Information <p>For more details, including technical definitions and formulas, see Bridge design (BEEFY) in the Polkadot Protocol Specification.</p>"},{"location":"polkadot-protocol/architecture/polkadot-chain/pos-consensus/#resources","title":"Resources","text":"<ul> <li>GRANDPA Rust implementation</li> <li>GRANDPA Pallet</li> <li>Block Production and Finalization in Polkadot - Bill Laboon explains how BABE and GRANDPA work together to produce and finalize blocks on Kusama </li> <li>Block Production and Finalization in Polkadot: Understanding the BABE and GRANDPA Protocols - Bill Laboon's MIT Cryptoeconomic Systems 2020 academic talk describing Polkadot's hybrid consensus model in-depth</li> </ul>"},{"location":"polkadot-protocol/architecture/system-chains/","title":"System Chains","text":"<p>Discover the unique role and functionality each of Polkadot\u2019s system chains, including the Asset Hub, Bridge Hub, and Coretime chain, provides to the ecosystem.</p>"},{"location":"polkadot-protocol/architecture/system-chains/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"polkadot-protocol/architecture/system-chains/asset-hub/","title":"Asset Hub","text":""},{"location":"polkadot-protocol/architecture/system-chains/asset-hub/#introduction","title":"Introduction","text":"<p>The Asset Hub is a critical component in the Polkadot ecosystem, enabling the management of fungible and non-fungible assets across the network. Since the relay chain focuses on maintaining security and consensus without direct asset management, Asset Hub provides a streamlined platform for creating, managing, and using on-chain assets in a fee-efficient manner. This guide outlines the core features of Asset Hub, including how it handles asset operations, cross-chain transfers, and asset integration using XCM, as well as essential tools like API Sidecar and <code>TxWrapper</code> for developers working with on-chain assets.</p>"},{"location":"polkadot-protocol/architecture/system-chains/asset-hub/#assets-basics","title":"Assets Basics","text":"<p>In the Polkadot ecosystem, the relay chain does not natively support additional assets beyond its native token (DOT for Polkadot, KSM for Kusama). The Asset Hub parachain on Polkadot and Kusama provides a fungible and non-fungible assets framework. Asset Hub allows developers and users to create, manage, and use assets across the ecosystem.</p> <p>Asset creators can use Asset Hub to track their asset issuance across multiple parachains and manage assets through operations such as minting, burning, and transferring. Projects that need a standardized method of handling on-chain assets will find this particularly useful. The fungible asset interface provided by Asset Hub closely resembles Ethereum's ERC-20 standard but is directly integrated into Polkadot's runtime, making it more efficient in terms of speed and transaction fees.</p> <p>Integrating with Asset Hub offers several key benefits, particularly for infrastructure providers and users:</p> <ul> <li>Support for non-native on-chain assets - Asset Hub enables seamless asset creation and management, allowing projects to develop tokens or assets that can interact with the broader ecosystem</li> <li>Lower transaction fees - Asset Hub offers significantly lower transaction costs\u2014approximately one-tenth of the fees on the relay chain, providing cost-efficiency for regular operations</li> <li>Reduced deposit requirements - depositing assets in Asset Hub is more accessible, with deposit requirements that are around one one-hundredth of those on the relay chain</li> <li>Payment of transaction fees with non-native assets - users can pay transaction fees in assets other than the native token (DOT or KSM), offering more flexibility for developers and users</li> </ul> <p>Assets created on the Asset Hub are stored as part of a map, where each asset has a unique ID that links to information about the asset, including details like:</p> <ul> <li>The management team</li> <li>The total supply</li> <li>The number of accounts holding the asset</li> <li>Sufficiency for account existence - whether the asset alone is enough to maintain an account without a native token balance</li> <li>The metadata of the asset, including its name, symbol, and the number of decimals for representation</li> </ul> <p>Some assets can be regarded as sufficient to maintain an account's existence, meaning that users can create accounts on the network without needing a native token balance (i.e., no existential deposit required). Developers can also set minimum balances for their assets. If an account's balance drops below the minimum, the balance is considered dust and may be cleared.</p>"},{"location":"polkadot-protocol/architecture/system-chains/asset-hub/#assets-pallet","title":"Assets Pallet","text":"<p>The Polkadot SDK's Assets pallet is a powerful module designated for creating and managing fungible asset classes with a fixed supply. It offers a secure and flexible way to issue, transfer, freeze, and destroy assets. The pallet supports various operations and includes permissioned and non-permissioned functions to cater to simple and advanced use cases.</p> <p>Visit the Assets Pallet Rust docs for more in-depth information.</p>"},{"location":"polkadot-protocol/architecture/system-chains/asset-hub/#key-features","title":"Key Features","text":"<p>Key features of the Assets pallet include:</p> <ul> <li>Asset issuance - allows the creation of a new asset, where the total supply is assigned to the creator's account</li> <li>Asset transfer - enables transferring assets between accounts while maintaining a balance in both accounts</li> <li>Asset freezing - prevents transfers of a specific asset from one account, locking it from further transactions</li> <li>Asset destruction - allows accounts to burn or destroy their holdings, removing those assets from circulation</li> <li>Non-custodial transfers - a non-custodial mechanism to enable one account to approve a transfer of assets on behalf of another</li> </ul>"},{"location":"polkadot-protocol/architecture/system-chains/asset-hub/#main-functions","title":"Main Functions","text":"<p>The Assets pallet provides a broad interface for managing fungible assets. Some of the main dispatchable functions include:</p> <ul> <li><code>create()</code> - create a new asset class by placing a deposit, applicable when asset creation is permissionless</li> <li><code>issue()</code> - mint a fixed supply of a new asset and assign it to the creator's account</li> <li><code>transfer()</code> - transfer a specified amount of an asset between two accounts</li> <li><code>approve_transfer()</code> - approve a non-custodial transfer, allowing a third party to move assets between accounts</li> <li><code>destroy()</code> - destroy an entire asset class, removing it permanently from the chain</li> <li><code>freeze()</code> and <code>thaw()</code> - administrators or privileged users can lock or unlock assets from being transferred</li> </ul> <p>For a full list of dispatchable and privileged functions, see the dispatchables Rust docs.</p>"},{"location":"polkadot-protocol/architecture/system-chains/asset-hub/#querying-functions","title":"Querying Functions","text":"<p>The Assets pallet exposes several key querying functions that developers can interact with programmatically. These functions allow you to query asset information and perform operations essential for managing assets across accounts. The two main querying functions are:</p> <ul> <li> <p><code>balance(asset_id, account)</code> - retrieves the balance of a given asset for a specified account. Useful for checking the holdings of an asset class across different accounts</p> </li> <li> <p><code>total_supply(asset_id)</code> - returns the total supply of the asset identified by <code>asset_id</code>. Allows users to verify how much of the asset exists on-chain</p> </li> </ul> <p>In addition to these basic functions, other utility functions are available for querying asset metadata and performing asset transfers. You can view the complete list of querying functions in the Struct Pallet Rust docs.</p>"},{"location":"polkadot-protocol/architecture/system-chains/asset-hub/#permission-models-and-roles","title":"Permission Models and Roles","text":"<p>The Assets pallet incorporates a robust permission model, enabling control over who can perform specific operations like minting, transferring, or freezing assets. The key roles within the permission model are:</p> <ul> <li>Admin - can freeze (preventing transfers) and forcibly transfer assets between accounts. Admins also have the power to reduce the balance of an asset class across arbitrary accounts. They manage the more sensitive and administrative aspects of the asset class</li> <li>Issuer - responsible for minting new tokens. When new assets are created, the Issuer is the account that controls their distribution to other accounts</li> <li>Freezer - can lock the transfer of assets from an account, preventing the account holder from moving their balance. This function is useful for freezing accounts involved in disputes or fraud</li> <li>Owner - has overarching control, including destroying an entire asset class. Owners can also set or update the Issuer, Freezer, and Admin roles</li> </ul> <p>These permissions provide fine-grained control over assets, enabling developers and asset managers to ensure secure, controlled operations. Each of these roles is crucial for managing asset lifecycles and ensuring that assets are used appropriately across the network.</p>"},{"location":"polkadot-protocol/architecture/system-chains/asset-hub/#asset-freezing","title":"Asset Freezing","text":"<p>The Assets pallet allows you to freeze assets. This feature prevents transfers or spending from a specific account, effectively locking the balance of an asset class until it is explicitly unfrozen. Asset freezing is beneficial when assets are restricted due to security concerns or disputes.</p> <p>Freezing assets is controlled by the Freezer role, as mentioned earlier. Only the account with the Freezer privilege can perform these operations. Here are the key freezing functions:</p> <ul> <li><code>freeze(asset_id, account)</code> - locks the specified asset of the account. While the asset is frozen, no transfers can be made from the frozen account</li> <li><code>thaw(asset_id, account)</code> - corresponding function for unfreezing, allowing the asset to be transferred again</li> </ul> <p>This approach enables secure and flexible asset management, providing administrators the tools to control asset movement in special circumstances.</p>"},{"location":"polkadot-protocol/architecture/system-chains/asset-hub/#non-custodial-transfers-approval-api","title":"Non-Custodial Transfers (Approval API)","text":"<p>The Assets pallet also supports non-custodial transfers through the Approval API. This feature allows one account to approve another account to transfer a specific amount of its assets to a third-party recipient without granting full control over the account's balance. Non-custodial transfers enable secure transactions where trust is required between multiple parties.</p> <p>Here's a brief overview of the key functions for non-custodial asset transfers:</p> <ul> <li><code>approve_transfer(asset_id, delegate, amount)</code> - approves a delegate to transfer up to a certain amount of the asset on behalf of the original account holder</li> <li><code>cancel_approval(asset_id, delegate)</code> - cancels a previous approval for the delegate. Once canceled, the delegate no longer has permission to transfer the approved amount</li> <li><code>transfer_approved(asset_id, owner, recipient, amount)</code> - executes the approved asset transfer from the owner\u2019s account to the recipient. The delegate account can call this function once approval is granted</li> </ul> <p>These delegated operations make it easier to manage multi-step transactions and dApps that require complex asset flows between participants.</p>"},{"location":"polkadot-protocol/architecture/system-chains/asset-hub/#foreign-assets","title":"Foreign Assets","text":"<p>Foreign assets in Asset Hub refer to assets originating from external blockchains or parachains that are registered in the Asset Hub. These assets are typically native tokens from other parachains within the Polkadot ecosystem or bridged tokens from external blockchains such as Ethereum.</p> <p>Once a foreign asset is registered in the Asset Hub by its originating blockchain's root origin, users are able to send these tokens to the Asset Hub and interact with them as they would any other asset within the Polkadot ecosystem.</p>"},{"location":"polkadot-protocol/architecture/system-chains/asset-hub/#handling-foreign-assets","title":"Handling Foreign Assets","text":"<p>The Foreign Assets pallet, an instance of the Assets pallet, manages these assets. Since foreign assets are integrated into the same interface as native assets, developers can use the same functionalities, such as transferring and querying balances. However, there are important distinctions when dealing with foreign assets.</p> <ul> <li> <p>Asset identifier - unlike native assets, foreign assets are identified using an XCM Multilocation rather than a simple numeric <code>AssetId</code>. This multilocation identifier represents the cross-chain location of the asset and provides a standardized way to reference it across different parachains and relay chains</p> </li> <li> <p>Transfers - once registered in the Asset Hub, foreign assets can be transferred between accounts, just like native assets. Users can also send these assets back to their originating blockchain if supported by the relevant cross-chain messaging mechanisms</p> </li> </ul>"},{"location":"polkadot-protocol/architecture/system-chains/asset-hub/#integration","title":"Integration","text":"<p>Asset Hub supports a variety of integration tools that make it easy for developers to manage assets and interact with the blockchain in their applications. The tools and libraries provided by Parity Technologies enable streamlined operations, such as querying asset information, building transactions, and monitoring cross-chain asset transfers.</p> <p>Developers can integrate Asset Hub into their projects using these core tools:</p>"},{"location":"polkadot-protocol/architecture/system-chains/asset-hub/#api-sidecar","title":"API Sidecar","text":"<p>API Sidecar is a RESTful service that can be deployed alongside Polkadot and Kusama nodes. It provides endpoints to retrieve real-time blockchain data, including asset information. When used with Asset Hub, Sidecar allows querying:</p> <ul> <li>Asset look-ups - retrieve specific assets using <code>AssetId</code></li> <li>Asset balances - view the balance of a particular asset on Asset Hub</li> </ul> <p>Public instances of API Sidecar connected to Asset Hub are available, such as:</p> <ul> <li>Polkadot Asset Hub Sidecar</li> <li>Kusama Asset Hub Sidecar</li> </ul> <p>These public instances are primarily for ad-hoc testing and quick checks.</p>"},{"location":"polkadot-protocol/architecture/system-chains/asset-hub/#txwrapper","title":"TxWrapper","text":"<p><code>TxWrapper</code> is a library that simplifies constructing and signing transactions for Polkadot SDK-based chains, including Polkadot and Kusama. This tool includes support for working with Asset Hub, enabling developers to:</p> <ul> <li>Construct offline transactions</li> <li>Leverage asset-specific functions such as minting, burning, and transferring assets</li> </ul> <p><code>TxWrapper</code> provides the flexibility needed to integrate asset operations into custom applications while maintaining the security and efficiency of Polkadot's transaction model.</p>"},{"location":"polkadot-protocol/architecture/system-chains/asset-hub/#asset-transfer-api","title":"Asset Transfer API","text":"<p>Asset Transfer API is a library focused on simplifying the construction of asset transfers for Polkadot SDK-based chains that involve system parachains like Asset Hub. It exposes a reduced set of methods that facilitate users sending transfers to other parachains or locally. Refer to the cross-chain support table for the current status of cross-chain support development.</p> <p>Key features include:</p> <ul> <li>Support for cross-chain transfers between parachains</li> <li>Streamlined transaction construction with support for the necessary parachain metadata</li> </ul> <p>The API supports various asset operations, such as paying transaction fees with non-native tokens and managing asset liquidity.</p>"},{"location":"polkadot-protocol/architecture/system-chains/asset-hub/#parachain-node","title":"Parachain Node","text":"<p>To fully leverage the Asset Hub's functionality, developers will need to run a system parachain node. Setting up an Asset Hub node allows users to interact with the parachain in real time, syncing data and participating in the broader Polkadot ecosystem. Guidelines for setting up an Asset Hub node are available in the Parity documentation.</p> <p>Using these integration tools, developers can manage assets seamlessly and integrate Asset Hub functionality into their applications, leveraging Polkadot's powerful infrastructure.</p>"},{"location":"polkadot-protocol/architecture/system-chains/asset-hub/#xcm-transfer-monitoring","title":"XCM Transfer Monitoring","text":"<p>Since Asset Hub facilitates cross-chain asset transfers across the Polkadot ecosystem, XCM transfer monitoring becomes an essential practice for developers and infrastructure providers. This section outlines how to monitor the cross-chain movement of assets between parachains, the relay chain, and other systems.</p>"},{"location":"polkadot-protocol/architecture/system-chains/asset-hub/#monitor-xcm-deposits","title":"Monitor XCM Deposits","text":"<p>As assets move between chains, tracking the cross-chain transfers in real time is crucial. Whether assets are transferred via a teleport from system parachains or through a reserve-backed transfer from any other parachain, each transfer emits a relevant event (such as the <code>balances.minted</code> event).</p> <p>To ensure accurate monitoring of these events:</p> <ul> <li>Track XCM deposits - query every new block created in the relay chain or Asset Hub, loop through the events array, and filter for any <code>balances.minted</code> events which confirm the asset was successfully transferred to the account</li> <li>Track event origins - each <code>balances.minted</code> event points to a specific address. By monitoring this, service providers can verify that assets have arrived in the correct account</li> </ul>"},{"location":"polkadot-protocol/architecture/system-chains/asset-hub/#track-xcm-information-back-to-the-source","title":"Track XCM Information Back to the Source","text":"<p>While the <code>balances.minted</code> event confirms the arrival of assets, there may be instances where you need to trace the origin of the cross-chain message that triggered the event. In such cases, you can:</p> <ol> <li>Query the relevant chain at the block where the <code>balances.minted</code> event was emitted</li> <li>Look for a <code>messageQueue(Processed)</code> event within that block's initialization. This event contains a parameter (<code>Id</code>) that identifies the cross-chain message received by the relay chain or Asset Hub. You can use this <code>Id</code> to trace the message back to its origin chain, offering full visibility of the asset transfer's journey</li> </ol>"},{"location":"polkadot-protocol/architecture/system-chains/asset-hub/#practical-monitoring-examples","title":"Practical Monitoring Examples","text":"<p>The preceding sections outline the process of monitoring XCM deposits to specific accounts and then tracing back the origin of these deposits. The process of tracking an XCM transfer and the specific events to monitor may vary based on the direction of the XCM message. Here are some examples to showcase the slight differences:</p> <ul> <li>Transfer from parachain to relay chain - track <code>parachainsystem(UpwardMessageSent)</code> on the parachain and <code>messagequeue(Processed)</code> on the relay chain</li> <li>Transfer from relay chain to parachain - track <code>xcmPallet(sent)</code> on the relay chain and <code>dmpqueue(ExecutedDownward)</code> on the parachain</li> <li>Transfer between parachains - track <code>xcmpqueue(XcmpMessageSent)</code> on the system parachain and <code>xcmpqueue(Success)</code> on the destination parachain</li> </ul>"},{"location":"polkadot-protocol/architecture/system-chains/asset-hub/#monitor-for-failed-xcm-transfers","title":"Monitor for Failed XCM Transfers","text":"<p>Sometimes, XCM transfers may fail due to liquidity or other errors. Failed transfers emit specific error events, which are key to resolving issues in asset transfers. Monitoring for these failure events helps catch issues before they affect asset balances.</p> <ul> <li>Relay chain to system parachain - look for the <code>dmpqueue(ExecutedDownward)</code> event on the parachain with an <code>Incomplete</code> outcome and an error type such as <code>UntrustedReserveLocation</code></li> <li>Parachain to parachain - monitor for <code>xcmpqueue(Fail)</code> on the destination parachain with error types like <code>TooExpensive</code></li> </ul> <p>For detailed error management in XCM, see Gavin Wood's blog post on XCM Execution and Error Management.</p>"},{"location":"polkadot-protocol/architecture/system-chains/bridge-hub/","title":"Bridge Hub","text":""},{"location":"polkadot-protocol/architecture/system-chains/bridge-hub/#introduction","title":"Introduction","text":"<p>The Bridge Hub system parachain plays a crucial role in facilitating trustless interactions between Polkadot, Kusama, Ethereum, and other blockchain ecosystems. By implementing on-chain light clients and supporting protocols like BEEFY and GRANDPA, Bridge Hub ensures seamless message transmission and state verification across chains. It also provides essential pallets for sending and receiving messages, making it a cornerstone of Polkadot\u2019s interoperability framework. With built-in support for XCM (Cross-Consensus Messaging), Bridge Hub enables secure, efficient communication between diverse blockchain networks.</p> <p>This guide covers the architecture, components, and deployment of the Bridge Hub system. You'll explore its trustless bridging mechanisms, key pallets for various blockchains, and specific implementations like Snowbridge and the Polkadot &lt;&gt; Kusama bridge. By the end, you'll understand how Bridge Hub enhances connectivity within the Polkadot ecosystem and beyond.</p>"},{"location":"polkadot-protocol/architecture/system-chains/bridge-hub/#trustless-bridging","title":"Trustless Bridging","text":"<p>Bridge Hub provides a mode of trustless bridging through its implementation of on-chain light clients and trustless relayers. The target chain and source chain both provide ways of verifying one another's state and actions (such as a transfer) based on the consensus and finality of both chains rather than an external mechanism controlled by a third party.</p> <p>BEEFY (Bridge Efficiency Enabling Finality Yielder) is instrumental in this solution. It provides a more efficient way to verify the consensus on the relay chain. It allows the participants in a network to verify finality proofs, meaning a remote chain like Ethereum can verify the state of Polkadot at a given block height.</p> <p>Info</p> <p>In this context, \"trustless\" refers to the lack of need to trust a human when interacting with various system components. Trustless systems are based instead on trusting mathematics, cryptography, and code.</p> <p>Trustless bridges are essentially two one-way bridges, where each chain has a method of verifying the state of the other in a trustless manner through consensus proofs.</p> <p>For example, the Ethereum and Polkadot bridging solution that Snowbridge implements involves two light clients: one which verifies the state of Polkadot and the other which verifies the state of Ethereum. The light client for Polkadot is implemented in the runtime as a pallet, whereas the light client for Ethereum is implemented as a smart contract on the beacon chain.</p>"},{"location":"polkadot-protocol/architecture/system-chains/bridge-hub/#bridging-components","title":"Bridging Components","text":"<p>In any given Bridge Hub implementation (Kusama, Polkadot, or other relay chains), there are a few primary pallets that are utilized:</p> <ul> <li>Pallet Bridge GRANDPA - an on-chain GRANDPA light client for Substrate based chains</li> <li>Pallet Bridge Parachains - a finality module for parachains</li> <li>Pallet Bridge Messages - a pallet which allows sending, receiving, and tracking of inbound and outbound messages </li> <li>Pallet XCM Bridge - a pallet which, with the Bridge Messages pallet, adds XCM support to bridge pallets</li> </ul>"},{"location":"polkadot-protocol/architecture/system-chains/bridge-hub/#ethereum-specific-support","title":"Ethereum-Specific Support","text":"<p>Bridge Hub also has a set of components and pallets that support a bridge between Polkadot and Ethereum through Snowbridge.</p> <p>To view the complete list of which pallets are included in Bridge Hub, visit the Subscan Runtime Modules page. Alternatively, the source code for those pallets can be found in the Polkadot SDK Snowbridge Pallets repository.</p>"},{"location":"polkadot-protocol/architecture/system-chains/bridge-hub/#deployed-bridges","title":"Deployed Bridges","text":"<ul> <li>Snowbridge - a general-purpose, trustless bridge between Polkadot and Ethereum</li> <li>Hyperbridge - a cross-chain solution built as an interoperability coprocessor, providing state-proof-based interoperability across all blockchains</li> <li>Polkadot &lt;&gt; Kusama Bridge - a bridge that utilizes relayers to bridge the Polkadot and Kusama relay chains trustlessly</li> </ul>"},{"location":"polkadot-protocol/architecture/system-chains/bridge-hub/#where-to-go-next","title":"Where to Go Next","text":"<ul> <li>Go over the Bridge Hub README in the Polkadot SDK Bridge-hub Parachains repository</li> <li>Take a deeper dive into bridging architecture in the Polkadot SDK High-Level Bridge documentation</li> <li>Read more about BEEFY and Bridging in the Polkadot Wiki: Bridging: BEEFY</li> </ul>"},{"location":"polkadot-protocol/architecture/system-chains/coretime/","title":"Coretime","text":""},{"location":"polkadot-protocol/architecture/system-chains/coretime/#introduction","title":"Introduction","text":"<p>The Coretime system chain facilitates the allocation, procurement, sale, and scheduling of bulk coretime, enabling tasks (such as parachains) to utilize the computation and security provided by Polkadot. </p> <p>The Broker pallet, along with Cross Consensus Messaging (XCM), enables this functionality to be delegated to the system chain rather than the relay chain. Using XCMP's Upward Message Passing (UMP) to the relay chain allows for core assignments to take place for a task registered on the relay chain.</p> <p>The Fellowship RFC\u00a0RFC-1: Agile Coretime contains the specification for the Coretime system chain and coretime as a concept.</p> <p>Besides core management, its responsibilities include: </p> <ul> <li>The number of cores that should be made available</li> <li>Which tasks should be running on which cores and in what ratios</li> <li>Accounting information for the on-demand pool</li> </ul> <p>From the relay chain, it expects the following via Downward Message Passing (DMP):</p> <ul> <li>The number of cores available to be scheduled</li> <li>Account information on on-demand scheduling</li> </ul> <p>The details for this interface can be found in RFC-5: Coretime Interface.</p>"},{"location":"polkadot-protocol/architecture/system-chains/coretime/#bulk-coretime-assignment","title":"Bulk Coretime Assignment","text":"<p>The Coretime chain allocates coretime before its usage. It also manages the ownership of a core. As cores are made up of regions (by default, one core is a single region), a region is recognized as a non-fungible asset. The Coretime chain exposes Regions over XCM as an NFT. Users can transfer individual regions, partition, interlace, or allocate them to a task. Regions describe how a task may use a core.</p> <p>One core can contain more than one region.</p> <p>A core can be considered a logical representation of an active validator set on the relay chain, where these validators commit to verifying the state changes for a particular task running on that region. With partitioning, having more than one region per core is possible, allowing for different computational schemes. Therefore, running more than one task on a single core is possible.</p> <p>Regions can be managed in the following manner on the Coretime chain:</p> <ul> <li>Assigning region - regions can be assigned to a task on the relay chain, such as a parachain/rollup using the <code>assign</code> dispatchable</li> </ul> <p>Coretime Availability</p> <p>When bulk coretime is obtained, block production is not immediately available. It becomes available to produce blocks for a task in the next Coretime cycle. To view the status of the current or next Coretime cycle, go to the Subscan Coretime Dashboard.</p> <ul> <li> <p>Transferring regions - regions may be transferred on the Coretime chain, upon which the <code>transfer</code> dispatchable in the Broker pallet would assign a new owner to that specific region</p> </li> <li> <p>Partitioning regions - using the <code>partition</code> dispatchable, regions may be partitioned into two non-overlapping subregions within the same core. A partition involves specifying a pivot, wherein the new region will be defined and available for use</p> </li> <li> <p>Interlacing regions - using the <code>interlace</code> dispatchable, interlacing regions allows a core to have alternative-compute strategies. Whereas partitioned regions are mutually exclusive, interlaced regions overlap because multiple tasks may utilize a single core in an alternating manner</p> </li> </ul> <p>For more information regarding these mechanisms, visit the coretime page on the Polkadot Wiki: Introduction to Agile Coretime. </p>"},{"location":"polkadot-protocol/architecture/system-chains/coretime/#on-demand-coretime","title":"On Demand Coretime","text":"<p>At this writing, on-demand coretime is currently deployed on the relay chain and will eventually be deployed to the Coretime chain. On-demand coretime allows parachains (previously known as parathreads) to utilize available cores per block.</p> <p>The Coretime chain also handles coretime sales, details of which can be found on the Polkadot Wiki: Agile Coretime: Coretime Sales.</p>"},{"location":"polkadot-protocol/architecture/system-chains/coretime/#where-to-go-next","title":"Where to Go Next","text":"<ul> <li>Learn about Agile Coretime on the Polkadot Wiki</li> </ul>"},{"location":"polkadot-protocol/architecture/system-chains/overview/","title":"Overview of Polkadot's System Chains","text":""},{"location":"polkadot-protocol/architecture/system-chains/overview/#introduction","title":"Introduction","text":"<p>Polkadot's relay chain is designed to secure parachains and facilitate seamless inter-chain communication. However, resource-intensive\u2014tasks like governance, asset management, and bridging are more efficiently handled by system parachains. These specialized chains offload functionality from the relay chain, leveraging Polkadot's parallel execution model to improve performance and scalability. By distributing key functionalities across system parachains, Polkadot can maximize its relay chain's blockspace for its core purpose of securing and validating parachains.</p> <p>This guide will explore how system parachains operate within Polkadot and Kusama, detailing their critical roles in network governance, asset management, and bridging. You'll learn about the currently deployed system parachains, their unique functions, and how they enhance Polkadot's decentralized ecosystem.</p>"},{"location":"polkadot-protocol/architecture/system-chains/overview/#system-chains","title":"System Chains","text":"<p>System parachains contain core Polkadot protocol features, but in parachains rather than the relay chain. Execution cores for system chains are allocated via network governance rather than purchasing coretime on a marketplace.</p> <p>System parachains defer to on-chain governance to manage their upgrades and other sensitive actions as they do not have native tokens or governance systems separate from DOT or KSM. It is not uncommon to see a system parachain implemented specifically to manage network governance.</p> <p>Note</p> <p>You may see system parachains called common good parachains in articles and discussions. This nomenclature caused confusion as the network evolved, so system parachains is preferred. </p> <p>For more details on this evolution, review this parachains forum discussion.</p>"},{"location":"polkadot-protocol/architecture/system-chains/overview/#existing-system-chains","title":"Existing System Chains","text":"<pre><code>---\ntitle: System Parachains at a Glance\n---\nflowchart TB\n    subgraph POLKADOT[\"Polkadot\"]\n        direction LR\n            PAH[\"Polkadot Asset Hub\"]\n            PCOL[\"Polkadot Collectives\"]\n            PBH[\"Polkadot Bridge Hub\"]\n            PPC[\"Polkadot People Chain\"]\n            PCC[\"Polkadot Coretime Chain\"]\n    end\n\n    subgraph KUSAMA[\"Kusama\"]\n        direction LR\n            KAH[\"Kusama Asset Hub\"]\n            KBH[\"Kusama Bridge Hub\"]\n            KPC[\"Kusama People Chain\"]\n            KCC[\"Kusama Coretime Chain\"]\n            E[\"Encointer\"]\n        end</code></pre> <p>All system parachains are on both Polkadot and Kusama with the following exceptions:</p> <ul> <li>Collectives - only on Polkadot</li> <li>Encointer - only on Kusama</li> </ul>"},{"location":"polkadot-protocol/architecture/system-chains/overview/#asset-hub","title":"Asset Hub","text":"<p>The Asset Hub is an asset portal for the entire network. It helps asset creators, such as reserve-backed stablecoin issuers, track the total issuance of an asset in the network, including amounts transferred to other parachains. It also serves as the hub where asset creators can perform on-chain operations, such as minting and burning, to manage their assets effectively.</p> <p>This asset management logic is encoded directly in the runtime of the chain rather than in smart contracts. The efficiency of executing logic in a parachain allows for fees and deposits that are about 1/10th of what is required on the relay chain. These low fees mean that the Asset Hub is well suited for handling the frequent transactions required when managing balances, transfers, and on-chain assets.</p> <p>The Asset Hub also supports non-fungible assets (NFTs) via the Uniques pallet and NFTs pallet. For more information about NFTs, see the Polkadot Wiki section on NFT Pallets.</p>"},{"location":"polkadot-protocol/architecture/system-chains/overview/#collectives","title":"Collectives","text":"<p>The Polkadot Collectives parachain was added in Referendum 81 and exists on Polkadot but not on Kusama. The Collectives chain hosts on-chain collectives that serve the Polkadot network, including the following:</p> <ul> <li>Polkadot Alliance - provides a set of ethics and standards for the community to follow. Includes an on-chain means to call out bad actors</li> <li>Polkadot Technical Fellowship - a rules-based social organization to support and incentivize highly-skilled developers to contribute to the technical stability, security, and progress of the network</li> </ul> <p>These on-chain collectives will play essential roles in the future of network stewardship and decentralized governance. Networks can use a bridge hub to help them act as collectives and express their legislative voices as single opinions within other networks.</p>"},{"location":"polkadot-protocol/architecture/system-chains/overview/#bridge-hub","title":"Bridge Hub","text":"<p>Before parachains, the only way to design a bridge was to put the logic onto the relay chain. Since both networks now support parachains and the isolation they provide, each network can have a parachain dedicated to bridges. </p> <p>The Bridge Hub system parachain operates on the relay chain, and is responsible for faciliating bridges to the wider Web3 space. It contains the required bridge pallets in its runtime, which enable trustless bridging with other blockchain networks like Polkadot, Kusama, and Ethereum. The Bridge Hub uses the native token of the relay chain.</p> <p>See the Bridge Hub documentation for additional information.</p>"},{"location":"polkadot-protocol/architecture/system-chains/overview/#people-chain","title":"People Chain","text":"<p>The People Chain provides a naming system that allows users to manage and verify their account identity.</p>"},{"location":"polkadot-protocol/architecture/system-chains/overview/#coretime-chain","title":"Coretime Chain","text":"<p>The Coretime system chain lets users buy coretime to access Polkadot's computation. Coretime marketplaces run on top of the Coretime chain. Kusama does not use the Collectives system chain. Instead, Kusama relies on the Encointer system chain, which provides Sybil resistance as a service to the entire Kusama ecosystem.</p> <p>Visit Introduction to Agile Coretime in the Polkadot Wiki for more information.</p>"},{"location":"polkadot-protocol/architecture/system-chains/overview/#encointer","title":"Encointer","text":"<p>Encointer is a blockchain platform for self-sovereign ID and a global universal basic income (UBI). The Encointer protocol uses a novel Proof of Personhood (PoP) system to create unique identities and resist Sybil attacks. PoP is based on the notion that a person can only be in one place at any given time. Encointer offers a framework that allows for any group of real people to create, distribute, and use their own digital community tokens.</p> <p>Participants are requested to attend physical key-signing ceremonies with small groups of random people at randomized locations. These local meetings are part of one global signing ceremony occurring at the same time. Participants use the Encointer wallet app to participate in these ceremonies and manage local community currencies. </p> <p>Referendums marking key Encointer adoption milestones include: </p> <ul> <li>Referendum 158 - Register Encointer As a Common Good Chain - registered Encointer as the second system parachain on Kusama's network</li> <li>Referendum 187 - Encointer Runtime Upgrade to Full Functionality - introduced a runtime upgrade bringing governance and full functionality for communities to use the protocol</li> </ul> <p>Tip</p> <p>To learn more about Encointer, check out the official Encointer book or watch an Encointer ceremony in action.</p>"},{"location":"polkadot-protocol/basics/","title":"Basics","text":"<p>This section provides developers with the foundational knowledge required to build, deploy, and optimize applications and blockchains within the Polkadot ecosystem. You'll gain a deeper understanding of Polkadot's core components, from the intricacies of accounts, balances, and transactions to data encoding and cryptographic methods. Understanding these topics is crucial for building on Polkadot.</p>"},{"location":"polkadot-protocol/basics/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"polkadot-protocol/basics/accounts/","title":"Accounts","text":""},{"location":"polkadot-protocol/basics/accounts/#introduction","title":"Introduction","text":"<p>Accounts are essential for managing identity, transactions, and governance on the network in the Polkadot SDK. Understanding these components is critical for seamless development and operation on the network, whether you're building or interacting with Polkadot-based chains.</p> <p>This page will guide you through the essential aspects of accounts, including their data structure, balance types, reference counters, and address formats. You\u2019ll learn how accounts are managed within the runtime, how balances are categorized, and how addresses are encoded and validated. </p>"},{"location":"polkadot-protocol/basics/accounts/#account-data-structure","title":"Account Data Structure","text":"<p>Accounts are foundational to any blockchain, and the Polkadot SDK provides a flexible management system. This section explains how the Polkadot SDK defines accounts and manages their lifecycle through data structures within the runtime.</p>"},{"location":"polkadot-protocol/basics/accounts/#account","title":"Account","text":"<p>The <code>Account</code> data type is a storage map within the System pallet that links an account ID to its corresponding data. This structure is fundamental for mapping account-related information within the chain.</p> <p>The code snippet below shows how accounts are defined:</p> <pre><code> /// The full account information for a particular account ID\n #[pallet::storage]\n #[pallet::getter(fn account)]\n pub type Account&lt;T: Config&gt; = StorageMap&lt;\n   _,\n   Blake2_128Concat,\n   T::AccountId,\n   AccountInfo&lt;T::Nonce, T::AccountData&gt;,\n   ValueQuery,\n &gt;;\n</code></pre> <p>The preceding code block defines a storage map named <code>Account</code>. The <code>StorageMap</code> is a type of on-chain storage that maps keys to values. In the <code>Account</code> map, the key is an account ID, and the value is the account's information. Here, <code>T</code> represents the generic parameter for the runtime configuration, which is defined by the pallet's configuration trait (<code>Config</code>).</p> <p>The <code>StorageMap</code> consists of the following parameters:</p> <ul> <li><code>_</code> - used in macro expansion and acts as a placeholder for the storage prefix type. Tells the macro to insert the default prefix during expansion</li> <li><code>Blake2_128Concat</code> - the hashing function applied to keys in the storage map</li> <li><code>T::AccountId</code> - represents the key type, which corresponds to the account\u2019s unique ID</li> <li><code>AccountInfo&lt;T::Nonce, T::AccountData&gt;</code> - the value type stored in the map. For each account ID, the map stores an <code>AccountInfo</code> struct containing:<ul> <li><code>T::Nonce</code> - a nonce for the account, which is incremented with each transaction to ensure transaction uniqueness</li> <li><code>T::AccountData</code> - custom account data defined by the runtime configuration, which could include balances, locked funds, or other relevant information</li> </ul> </li> <li><code>ValueQuery</code> - defines how queries to the storage map behave when no value is found; returns a default value instead of <code>None</code></li> </ul> Additional information <p>For a detailed explanation of storage maps, refer to the <code>StorageMap</code> Rust docs.</p>"},{"location":"polkadot-protocol/basics/accounts/#account-info","title":"Account Info","text":"<p>The <code>AccountInfo</code> structure is another key element within the System pallet, providing more granular details about each account's state. This structure tracks vital data, such as the number of transactions and the account\u2019s relationships with other modules.</p> <pre><code>#[derive(Clone, Eq, PartialEq, Default, RuntimeDebug, Encode, Decode)]\npub struct AccountInfo&lt;Nonce, AccountData&gt; {\n  pub nonce: Nonce,\n  pub consumers: RefCount,\n  pub providers: RefCount,\n  pub sufficients: RefCount,\n  pub data: AccountData,\n}\n</code></pre> <p>The <code>AccountInfo</code> structure includes the following components:</p> <ul> <li><code>nonce</code> - tracks the number of transactions initiated by the account, which ensures transaction uniqueness and prevents replay attacks</li> <li><code>consumers</code> - counts how many other modules or pallets rely on this account\u2019s existence. The account cannot be removed from the chain (reaped) until this count reaches zero</li> <li><code>providers</code> - tracks how many modules permit this account\u2019s existence. An account can only be reaped once both <code>providers</code> and <code>sufficients</code> are zero</li> <li><code>sufficients</code> - represents the number of modules that allow the account to exist for internal purposes, independent of any other modules</li> <li><code>AccountData</code> - a flexible data structure that can be customized in the runtime configuration, usually containing balances or other user-specific data</li> </ul> <p>This structure helps manage an account's state and prevents its premature removal while it is still referenced by other on-chain data or modules. The <code>AccountInfo</code> structure can vary as long as it satisfies the trait bounds defined by the <code>AccountData</code> associated type in the <code>frame-system::pallet::Config</code> trait.</p>"},{"location":"polkadot-protocol/basics/accounts/#account-reference-counters","title":"Account Reference Counters","text":"<p>Polkadot SDK uses reference counters to track an account\u2019s dependencies across different runtime modules. These counters ensure that accounts remain active while data is associated with them.</p> <p>The reference counters include:</p> <ul> <li><code>consumers</code> - prevents account removal while other pallets still rely on the account</li> <li><code>providers</code> - ensures an account is active before other pallets store data related to it</li> <li><code>sufficients</code> - indicates the account\u2019s independence, ensuring it can exist even without a native token balance, such as when holding sufficient alternative assets</li> </ul>"},{"location":"polkadot-protocol/basics/accounts/#providers-reference-counters","title":"Providers Reference Counters","text":"<p>The <code>providers</code> counter ensures that an account is ready to be depended upon by other runtime modules. For example, it is incremented when an account has a balance above the existential deposit, which marks the account as active.</p> <p>The system requires this reference counter to be greater than zero for the <code>consumers</code> counter to be incremented, ensuring the account is stable before any dependencies are added.</p>"},{"location":"polkadot-protocol/basics/accounts/#consumers-reference-counters","title":"Consumers Reference Counters","text":"<p>The <code>consumers</code> counter ensures that the account cannot be reaped until all references to it across the runtime have been removed. This check prevents the accidental deletion of accounts that still have active on-chain data.</p> <p>It is the user\u2019s responsibility to clear out any data from other runtime modules if they wish to remove their account and reclaim their existential deposit.</p>"},{"location":"polkadot-protocol/basics/accounts/#sufficients-reference-counter","title":"Sufficients Reference Counter","text":"<p>The <code>sufficients</code> counter tracks accounts that can exist independently without relying on a native account balance. This is useful for accounts holding other types of assets, like tokens, without needing a minimum balance in the native token.</p> <p>For instance, the Assets pallet, may increment this counter for an account holding sufficient tokens.</p>"},{"location":"polkadot-protocol/basics/accounts/#account-deactivation","title":"Account Deactivation","text":"<p>In Polkadot SDK-based chains, an account is deactivated when its reference counters (such as <code>providers</code>, <code>consumers</code>, and <code>sufficient</code>) reach zero. These counters ensure the account remains active as long as other runtime modules or pallets reference it.</p> <p>When all dependencies are cleared and the counters drop to zero, the account becomes deactivated and may be removed from the chain (reaped). This is particularly important in Polkadot SDK-based blockchains, where accounts with balances below the existential deposit threshold are pruned from storage to conserve state resources.</p> <p>Each pallet that references an account has cleanup functions that decrement these counters when the pallet no longer depends on the account. Once these counters reach zero, the account is marked for deactivation.</p>"},{"location":"polkadot-protocol/basics/accounts/#updating-counters","title":"Updating Counters","text":"<p>The Polkadot SDK provides runtime developers with various methods to manage account lifecycle events, such as deactivation or incrementing reference counters. These methods ensure that accounts cannot be reaped while still in use.</p> <p>The following helper functions manage these counters:</p> <ul> <li><code>inc_consumers()</code> - increments the <code>consumer</code> reference counter for an account, signaling that another pallet depends on it</li> <li><code>dec_consumers()</code> - decrements the <code>consumer</code> reference counter, signaling that a pallet no longer relies on the account</li> <li><code>inc_providers()</code> - increments the <code>provider</code> reference counter, ensuring the account remains active</li> <li><code>dec_providers()</code> - decrements the <code>provider</code> reference counter, allowing for account deactivation when no longer in use</li> <li><code>inc_sufficients()</code> - increments the <code>sufficient</code> reference counter for accounts that hold sufficient assets</li> <li><code>dec_sufficients()</code> - decrements the <code>sufficient</code> reference counter</li> </ul> <p>To ensure proper account cleanup and lifecycle management, a corresponding decrement should be made for each increment action.</p> <p>The <code>System</code> pallet offers three query functions to assist developers in tracking account states:</p> <ul> <li><code>can_inc_consumer()</code> - checks if the account can safely increment the consumer reference</li> <li><code>can_dec_provider()</code> - ensures that no consumers exist before allowing the decrement of the provider counter</li> <li><code>is_provider_required()</code> - verifies whether the account still has any active consumer references</li> </ul> <p>This modular and flexible system of reference counters tightly controls the lifecycle of accounts in Polkadot SDK-based blockchains, preventing the accidental removal or retention of unneeded accounts. You can refer to the System pallet Rust docs for more details.</p>"},{"location":"polkadot-protocol/basics/accounts/#account-balance-types","title":"Account Balance Types","text":"<p>In the Polkadot ecosystem, account balances are categorized into different types based on how the funds are utilized and their availability. These balance types determine the actions that can be performed, such as transferring tokens, paying transaction fees, or participating in governance activities. Understanding these balance types helps developers manage user accounts and implement balance-dependent logic.</p> <p>A more efficient distribution of account balance types is in development</p> <p>Soon, pallets in the Polkadot SDK will implement the <code>fungible</code> trait (see the tracking issue for more details). This update will enable more efficient use of account balances, allowing the free balance to be utilized for on-chain activities such as setting proxies and managing identities.</p>"},{"location":"polkadot-protocol/basics/accounts/#balance-types","title":"Balance Types","text":"<p>The five main balance types are:</p> <ul> <li>Free balance - represents the total tokens available to the account for any on-chain activity, including staking, governance, and voting. However, it may not be fully spendable or transferrable if portions of it are locked or reserved</li> <li>Locked balance - portions of the free balance that cannot be spent or transferred because they are tied up in specific activities like staking, vesting, or participating in governance. While the tokens remain part of the free balance, they are non-transferable for the duration of the lock</li> <li>Reserved balance - funds locked by specific system actions, such as setting up an identity, creating proxies, or submitting deposits for governance proposals. These tokens are not part of the free balance and cannot be spent unless they are unreserved</li> <li>Spendable balance - the portion of the free balance that is available for immediate spending or transfers. It is calculated by subtracting the maximum of locked or reserved amounts from the free balance, ensuring that existential deposit limits are met</li> <li>Untouchable balance - funds that cannot be directly spent or transferred but may still be utilized for on-chain activities, such as governance participation or staking. These tokens are typically tied to certain actions or locked for a specific period</li> </ul> <p>The spendable balance is calculated as follows:</p> <pre><code>spendable = free - max(locked - reserved, ED)\n</code></pre> <p>Here, <code>free</code>, <code>locked</code>, and <code>reserved</code> are defined above. The <code>ED</code> represents the existential deposit, the minimum balance required to keep an account active and prevent it from being reaped. You may find you can't see all balance types when looking at your account via a wallet. Wallet providers often display only spendable, locked, and reserved balances.</p>"},{"location":"polkadot-protocol/basics/accounts/#locks","title":"Locks","text":"<p>Locks are applied to an account's free balance, preventing that portion from being spent or transferred. Locks are automatically placed when an account participates in specific on-chain activities, such as staking or governance. Although multiple locks may be applied simultaneously, they do not stack. Instead, the largest lock determines the total amount of locked tokens.</p> <p>Locks follow these basic rules:</p> <ul> <li>If different locks apply to varying amounts, the largest lock amount takes precedence</li> <li>If multiple locks apply to the same amount, the lock with the longest duration governs when the balance can be unlocked</li> </ul>"},{"location":"polkadot-protocol/basics/accounts/#locks-example","title":"Locks Example","text":"<p>Consider an example where an account has 80 DOT locked for both staking and governance purposes like so:</p> <ul> <li>80 DOT is staked with a 28-day lock period</li> <li>24 DOT is locked for governance with a 1x conviction and a 7-day lock period</li> <li>4 DOT is locked for governance with a 6x conviction and a 224-day lock period</li> </ul> <p>In this case, the total locked amount is 80 DOT because only the largest lock (80 DOT from staking) governs the locked balance. These 80 DOT will be released at different times based on the lock durations. In this example, the 24 DOT locked for governance will be released first since the shortest lock period is seven days. The 80 DOT stake with a 28-day lock period is released next. Now, all that remains locked is the 4 DOT for governance. After 224 days, all 80 DOT (minus the existential deposit) will be free and transferrable.</p> <p></p>"},{"location":"polkadot-protocol/basics/accounts/#edge-cases-for-locks","title":"Edge Cases for Locks","text":"<p>In scenarios where multiple convictions and lock periods are active, the lock duration and amount are determined by the longest period and largest amount. For example, if you delegate with different convictions and attempt to undelegate during an active lock period, the lock may be extended for the full amount of tokens. For a detailed discussion on edge case lock behavior, see this Stack Exchange post.</p>"},{"location":"polkadot-protocol/basics/accounts/#balance-types-on-polkadotjs","title":"Balance Types on Polkadot.js","text":"<p>Polkadot.js provides a user-friendly interface for managing and visualizing various account balances on Polkadot and Kusama networks. When interacting with Polkadot.js, you will encounter multiple balance types that are critical for understanding how your funds are distributed and restricted. This section explains how different balances are displayed in the Polkadot.js UI and what each type represents.</p> <p></p> <p>The most common balance types displayed on Polkadot.js are:</p> <ul> <li> <p>Total balance - the total number of tokens available in the account. This includes all tokens, whether they are transferable, locked, reserved, or vested. However, the total balance does not always reflect what can be spent immediately. In this example, the total balance is 0.6274 KSM</p> </li> <li> <p>Transferrable balance - shows how many tokens are immediately available for transfer. It is calculated by subtracting the locked and reserved balances from the total balance. For example, if an account has a total balance of 0.6274 KSM and a transferrable balance of 0.0106 KSM, only the latter amount can be sent or spent freely</p> </li> <li> <p>Vested balance - tokens that allocated to the account but released according to a specific schedule. Vested tokens remain locked and cannot be transferred until fully vested. For example, an account with a vested balance of 0.2500 KSM means that this amount is owned but not yet transferable</p> </li> <li> <p>Locked balance - tokens that are temporarily restricted from being transferred or spent. These locks typically result from participating in staking, governance, or vested transfers. In Polkadot.js, locked balances do not stack\u2014only the largest lock is applied. For instance, if an account has 0.5500 KSM locked for governance and staking, the locked balance would display 0.5500 KSM, not the sum of all locked amounts</p> </li> <li> <p>Reserved balance - refers to tokens locked for specific on-chain actions, such as setting an identity, creating a proxy, or making governance deposits. Reserved tokens are not part of the free balance, but can be freed by performing certain actions. For example, removing an identity would unreserve those funds</p> </li> <li> <p>Bonded balance - the tokens locked for staking purposes. Bonded tokens are not transferrable until they are unbonded after the unbonding period</p> </li> <li> <p>Redeemable balance - the number of tokens that have completed the unbonding period and are ready to be unlocked and transferred again. For example, if an account has a redeemable balance of 0.1000 KSM, those tokens are now available for spending</p> </li> <li> <p>Democracy balance - reflects the number of tokens locked for governance activities, such as voting on referenda. These tokens are locked for the duration of the governance action and are only released after the lock period ends</p> </li> </ul> <p>By understanding these balance types and their implications, developers and users can better manage their funds and engage with on-chain activities more effectively.</p>"},{"location":"polkadot-protocol/basics/accounts/#address-formats","title":"Address Formats","text":"<p>The SS58 address format is a core component of the Polkadot SDK that enables accounts to be uniquely identified across Polkadot-based networks. This format is a modified version of Bitcoin's Base58Check encoding, specifically designed to accommodate the multi-chain nature of the Polkadot ecosystem. SS58 encoding allows each chain to define its own set of addresses while maintaining compatibility and checksum validation for security. </p>"},{"location":"polkadot-protocol/basics/accounts/#basic-format","title":"Basic Format","text":"<p>SS58 addresses consist of three main components:</p> <pre><code>base58encode(concat(&lt;address-type&gt;, &lt;address&gt;, &lt;checksum&gt;))\n</code></pre> <ul> <li>Address type - a byte or set of bytes that define the network (or chain) for which the address is intended. This ensures that addresses are unique across different Polkadot SDK-based chains</li> <li>Address - the public key of the account encoded as bytes</li> <li>Checksum - a hash-based checksum which ensures that addresses are valid and unaltered. The checksum is derived from the concatenated address type and address components, ensuring integrity</li> </ul> <p>The encoding process transforms the concatenated components into a Base58 string, providing a compact and human-readable format that avoids easily confused characters (e.g., zero '0', capital 'O', lowercase 'l'). This encoding function (<code>encode</code>) is implemented exactly as defined in Bitcoin and IPFS specifications, using the same alphabet as both implementations.</p> Additional information <p>Refer to Ss58Codec for more details on the SS58 address format implementation.</p>"},{"location":"polkadot-protocol/basics/accounts/#address-type","title":"Address Type","text":"<p>The address type defines how an address is interpreted and to which network it belongs. Polkadot SDK uses different prefixes to distinguish between various chains and address formats:</p> <ul> <li>Address types <code>0-63</code> - simple addresses, commonly used for network identifiers</li> <li>Address types <code>64-127</code> - full addresses that support a wider range of network identifiers</li> <li>Address types <code>128-255</code> - reserved for future address format extensions</li> </ul> <p>For example, Polkadot\u2019s main network uses an address type of 0, while Kusama uses 2. This ensures that addresses can be used without confusion between networks.</p> <p>The address type is always encoded as part of the SS58 address, making it easy to quickly identify the network. Refer to the SS58 registry for the canonical listing of all address type identifiers and how they map to Polkadot SDK-based networks.</p>"},{"location":"polkadot-protocol/basics/accounts/#address-length","title":"Address Length","text":"<p>SS58 addresses can have different lengths depending on the specific format. Address lengths range from as short as 3 to 35 bytes, depending on the complexity of the address and network requirements. This flexibility allows SS58 addresses to adapt to different chains while providing a secure encoding mechanism.</p> Total Type Raw account Checksum 3 1 1 1 4 1 2 1 5 1 2 2 6 1 4 1 7 1 4 2 8 1 4 3 9 1 4 4 10 1 8 1 11 1 8 2 12 1 8 3 13 1 8 4 14 1 8 5 15 1 8 6 16 1 8 7 17 1 8 8 35 1 32 2 <p>SS58 addresses also support different payload sizes, allowing a flexible range of account identifiers.</p>"},{"location":"polkadot-protocol/basics/accounts/#checksum-types","title":"Checksum Types","text":"<p>A checksum is applied to validate SS58 addresses. Polkadot SDK uses a Blake2b-512 hash function to calculate the checksum, which is appended to the address before encoding. The checksum length can vary depending on the address format (e.g., 1-byte, 2-byte, or longer), providing varying levels of validation strength.</p> <p>The checksum ensures that an address is not modified or corrupted, adding an extra layer of security for account management.</p>"},{"location":"polkadot-protocol/basics/accounts/#validating-addresses","title":"Validating Addresses","text":"<p>SS58 addresses can be validated using the subkey command-line interface or the Polkadot.js API. These tools help ensure an address is correctly formatted and valid for the intended network. The following sections will provide an overview of how validation works with these tools.</p>"},{"location":"polkadot-protocol/basics/accounts/#using-subkey","title":"Using Subkey","text":"<p>Subkey is a CLI tool provided by Polkadot SDK for generating and managing keys. It can inspect and validate SS58 addresses.</p> <p>The <code>inspect</code> command gets a public key and an SS58 address from the provided secret URI. The basic syntax for the <code>subkey inspect</code> command is:</p> <pre><code>subkey inspect [flags] [options] uri\n</code></pre> <p>For the <code>uri</code> command-line argument, you can specify the secret seed phrase, a hex-encoded private key, or an SS58 address. If the input is a valid address, the <code>subkey</code> program displays the corresponding hex-encoded public key, account identifier, and SS58 addresses.</p> <p>For example, to inspect the public keys derived from a secret seed phrase, you can run a command similar to the following:</p> <pre><code>subkey inspect \"caution juice atom organ advance problem want pledge someone senior holiday very\"\n</code></pre> <p>The command displays output similar to the following:</p> <p>subkey inspect \"caution juice atom organ advance problem want pledge someone senior holiday very\" Secret phrase <code>caution juice atom organ advance problem want pledge someone senior holiday very</code> is account:  Secret seed: 0xc8fa03532fb22ee1f7f6908b9c02b4e72483f0dbd66e4cd456b8f34c6230b849  Public key (hex): 0xd6a3105d6768e956e9e5d41050ac29843f98561410d3a47f9dd5b3b227ab8746  Public key (SS58): 5Gv8YYFu8H1btvmrJy9FjjAWfb99wrhV3uhPFoNEr918utyR  Account ID: 0xd6a3105d6768e956e9e5d41050ac29843f98561410d3a47f9dd5b3b227ab8746  SS58 Address: 5Gv8YYFu8H1btvmrJy9FjjAWfb99wrhV3uhPFoNEr918utyR</p> <p>The <code>subkey</code> program assumes an address is based on a public/private key pair. If you inspect an address, the command returns the 32-byte account identifier.</p> <p>However, not all addresses in Polkadot SDK-based networks are based on keys.</p> <p>Depending on the command-line options you specify and the input you provided, the command output might also display the network for which the address has been encoded. For example:</p> <pre><code>subkey inspect \"12bzRJfh7arnnfPPUZHeJUaE62QLEwhK48QnH9LXeK2m1iZU\"\n</code></pre> <p>The command displays output similar to the following:</p> <p>subkey inspect \"12bzRJfh7arnnfPPUZHeJUaE62QLEwhK48QnH9LXeK2m1iZU\" Public Key URI <code>12bzRJfh7arnnfPPUZHeJUaE62QLEwhK48QnH9LXeK2m1iZU</code> is account:  Network ID/Version: polkadot  Public key (hex): 0x46ebddef8cd9bb167dc30878d7113b7e168e6f0646beffd77d69d39bad76b47a  Account ID: 0x46ebddef8cd9bb167dc30878d7113b7e168e6f0646beffd77d69d39bad76b47a  Public key (SS58): 12bzRJfh7arnnfPPUZHeJUaE62QLEwhK48QnH9LXeK2m1iZU  SS58 Address: 12bzRJfh7arnnfPPUZHeJUaE62QLEwhK48QnH9LXeK2m1iZU</p>"},{"location":"polkadot-protocol/basics/accounts/#using-polkadotjs-api","title":"Using Polkadot.js API","text":"<p>To verify an address in JavaScript or TypeScript projects, you can use the functions built into the Polkadot.js API. For example:</p> <pre><code>// Import Polkadot.js API dependencies\nconst { decodeAddress, encodeAddress } = require('@polkadot/keyring');\nconst { hexToU8a, isHex } = require('@polkadot/util');\n\n// Specify an address to test.\nconst address = 'INSERT_ADDRESS_TO_TEST';\n\n// Check address\nconst isValidSubstrateAddress = () =&gt; {\n  try {\n    encodeAddress(isHex(address) ? hexToU8a(address) : decodeAddress(address));\n\n    return true;\n  } catch (error) {\n    return false;\n  }\n};\n\n// Query result\nconst isValid = isValidSubstrateAddress();\nconsole.log(isValid);\n</code></pre> <p>If the function returns <code>true</code>, the specified address is a valid address.</p>"},{"location":"polkadot-protocol/basics/accounts/#other-ss58-implementations","title":"Other SS58 Implementations","text":"<p>Support for encoding and decoding Polkadot SDK SS58 addresses has been implemented in several other languages and libraries.</p> <ul> <li>Crystal - <code>wyhaines/base58.cr</code></li> <li>Go - <code>itering/subscan-plugin</code></li> <li>Python - <code>polkascan/py-scale-codec</code></li> <li>TypeScript - <code>subsquid/squid-sdk</code></li> </ul>"},{"location":"polkadot-protocol/basics/chain-data/","title":"Chain Data","text":""},{"location":"polkadot-protocol/basics/chain-data/#introduction","title":"Introduction","text":"<p>Understanding and leveraging on-chain data is a fundamental aspect of blockchain development. Whether you're building frontend applications or backend systems, accessing and decoding runtime metadata is vital to interacting with the blockchain. This guide introduces you to the tools and processes for generating and retrieving metadata, explains its role in application development, and outlines the additional APIs available for interacting with a Polkadot node. By mastering these components, you can ensure seamless communication between your applications and the blockchain.</p>"},{"location":"polkadot-protocol/basics/chain-data/#application-development","title":"Application Development","text":"<p>You might not be directly involved in building frontend applications as a blockchain developer. However, most applications that run on a blockchain require some form of frontend or user-facing client to enable users or other programs to access and modify the data that the blockchain stores. For example, you might develop a browser-based, mobile, or desktop application that allows users to submit transactions, post articles, view their assets, or track previous activity. The backend for that application is configured in the runtime logic for your blockchain, but the frontend client makes the runtime features accessible to your users.</p> <p>For your custom chain to be useful to others, you'll need to provide a client application that allows users to view, interact with, or update information that the blockchain keeps track of. In this article, you'll learn how to expose information about your runtime so that client applications can use it, see examples of the information exposed, and explore tools and libraries that use it.</p>"},{"location":"polkadot-protocol/basics/chain-data/#understand-metadata","title":"Understand Metadata","text":"<p>Polkadot SDK-based blockchain networks are designed to expose their runtime information, allowing developers to learn granular details regarding pallets, RPC calls, and runtime APIs. The metadata also exposes their related documentation. The chain's metadata is SCALE-encoded, allowing for the development of browser-based, mobile, or desktop applications to support the chain's runtime upgrades seamlessly. It is also possible to develop applications compatible with multiple Polkadot SDK-based chains simultaneously.</p>"},{"location":"polkadot-protocol/basics/chain-data/#expose-runtime-information-as-metadata","title":"Expose Runtime Information as Metadata","text":"<p>To interact with a node or the state of the blockchain, you need to know how to connect to the chain and access the exposed runtime features. This interaction involves a Remote Procedure Call (RPC) through a node endpoint address, commonly through a secure web socket connection.</p> <p>An application developer typically needs to know the contents of the runtime logic, including the following details:</p> <ul> <li>Version of the runtime the application is connecting to</li> <li>Supported APIs </li> <li>Implemented pallets </li> <li>Defined functions and corresponding type signatures</li> <li>Defined custom types </li> <li>Exposed parameters users can set</li> </ul> <p>As the Polkadot SDK is modular and provides a composable framework for building blockchains, there are limitless opportunities to customize the schema of properties. Each runtime can be configured with its properties, including function calls and types, which can be changed over time with runtime upgrades.</p> <p>The Polkadot SDK enables you to generate the runtime metadata schema to capture information unique to a runtime. The metadata for a runtime describes the pallets in use and types defined for a specific runtime version. The metadata includes information about each pallet's storage items, functions, events, errors, and constants. The metadata also provides type definitions for any custom types included in the runtime.</p> <p>Metadata provides a complete inventory of a chain's runtime. It is key to enabling client applications to interact with the node, parse responses, and correctly format message payloads sent back to that chain.</p>"},{"location":"polkadot-protocol/basics/chain-data/#generate-metadata","title":"Generate Metadata","text":"<p>To efficiently use the blockchain's networking resources and minimize the data transmitted over the network, the metadata schema is encoded using the Parity SCALE Codec. This encoding is done automatically through the <code>scale-info</code>crate.</p> <p>At a high level, generating the metadata involves the following steps:</p> <ol> <li>The pallets in the runtime logic expose callable functions, types, parameters, and documentation that need to be encoded in the metadata</li> <li>The <code>scale-info</code> crate collects type information for the pallets in the runtime, builds a registry of the pallets that exist in a particular runtime, and the relevant types for each pallet in the registry. The type information is detailed enough to enable encoding and decoding for every type</li> <li>The <code>frame-metadata</code> crate describes the structure of the runtime based on the registry provided by the <code>scale-info</code> crate</li> <li>Nodes provide the RPC method <code>state_getMetadata</code> to return a complete description of all the types in the current runtime as a hex-encoded vector of SCALE-encoded bytes</li> </ol>"},{"location":"polkadot-protocol/basics/chain-data/#retrieve-runtime-metadata","title":"Retrieve Runtime Metadata","text":"<p>The type information provided by the metadata enables applications to communicate with nodes using different runtime versions and across chains that expose different calls, events, types, and storage items. The metadata also allows libraries to generate a substantial portion of the code needed to communicate with a given node, enabling libraries like <code>subxt</code> to generate frontend interfaces that are specific to a target chain.</p>"},{"location":"polkadot-protocol/basics/chain-data/#use-polkadotjs","title":"Use Polkadot.js","text":"<p>Visit the Polkadot.js Portal and select the Developer dropdown in the top banner. Select RPC Calls to make the call to request metadata. Follow these steps to make the RPC call:</p> <ol> <li>Select state as the endpoint to call</li> <li>Select <code>getMetadata(at)</code> as the method to call</li> <li>Click Submit RPC call to submit the call and return the metadata in JSON format</li> </ol>"},{"location":"polkadot-protocol/basics/chain-data/#use-curl","title":"Use Curl","text":"<p>You can fetch the metadata for the network by calling the node's RPC endpoint. This request returns the metadata in bytes rather than human-readable JSON:</p> <pre><code>curl -H \"Content-Type: application/json\" \\\n-d '{\"id\":1, \"jsonrpc\":\"2.0\", \"method\": \"state_getMetadata\"}' \\\nhttps://rpc.polkadot.io\n</code></pre>"},{"location":"polkadot-protocol/basics/chain-data/#use-subxt","title":"Use Subxt","text":"<p><code>subxt</code> may also be used to fetch the metadata of any data in a human-readable JSON format: </p> <pre><code>subxt metadata  --url wss://rpc.polkadot.io --format json &gt; spec.json\n</code></pre> <p>Another option is to use the <code>subxt</code> explorer web UI.</p>"},{"location":"polkadot-protocol/basics/chain-data/#client-applications-and-metadata","title":"Client Applications and Metadata","text":"<p>The metadata exposes the expected way to decode each type, meaning applications can send, retrieve, and process application information without manual encoding and decoding. Client applications must use the SCALE codec library to encode and decode RPC payloads to use the metadata. Client applications use the metadata to interact with the node, parse responses, and format message payloads sent to the node.</p>"},{"location":"polkadot-protocol/basics/chain-data/#metadata-format","title":"Metadata Format","text":"<p>Although the SCALE-encoded bytes can be decoded using the <code>frame-metadata</code> and <code>parity-scale-codec</code> libraries, there are other tools, such as <code>subxt</code> and the Polkadot-JS API, that can convert the raw data to human-readable JSON format.</p> <p>The types and type definitions included in the metadata returned by the <code>state_getMetadata</code> RPC call depend on the runtime's metadata version.</p> <p>In general, the metadata includes the following information:</p> <ul> <li>A constant identifying the file as containing metadata</li> <li>The version of the metadata format used in the runtime</li> <li>Type definitions for all types used in the runtime and generated by the <code>scale-info</code> crate</li> <li>Pallet information for the pallets included in the runtime in the order that they are defined in the <code>construct_runtime</code> macro</li> </ul> <p>Metadata formats may vary</p> <p>Depending on the frontend library used (such as the Polkadot API), they may format the metadata differently than the raw format shown.</p> <p>The following example illustrates a condensed and annotated section of metadata decoded and converted to JSON:</p> <pre><code>[\n    1635018093,\n    {\n        \"V14\": {\n            \"types\": {\n                \"types\": [{}]\n            },\n            \"pallets\": [{}],\n            \"extrinsic\": {\n                \"ty\": 126,\n                \"version\": 4,\n                \"signed_extensions\": [{}]\n            },\n            \"ty\": 141\n        }\n    }\n]\n</code></pre> <p>The constant <code>1635018093</code> is a magic number that identifies the file as a metadata file. The rest of the metadata is divided into the <code>types</code>, <code>pallets</code>, and <code>extrinsic</code> sections:</p> <ul> <li>The <code>types</code> section contains an index of the types and information about each type's type signature</li> <li>The <code>pallets</code> section contains information about each pallet in the runtime</li> <li>The <code>extrinsic</code> section describes the type identifier and transaction format version that the runtime uses</li> </ul> <p>Different extrinsic versions can have varying formats, especially when considering signed transactions. </p>"},{"location":"polkadot-protocol/basics/chain-data/#pallets","title":"Pallets","text":"<p>The following is a condensed and annotated example of metadata for a single element in the <code>pallets</code> array (the <code>sudo</code> pallet):</p> <pre><code>{\n    \"name\": \"Sudo\",\n    \"storage\": {\n        \"prefix\": \"Sudo\",\n        \"entries\": [\n            {\n                \"name\": \"Key\",\n                \"modifier\": \"Optional\",\n                \"ty\": {\n                    \"Plain\": 0\n                },\n                \"default\": [0],\n                \"docs\": [\"The `AccountId` of the sudo key.\"]\n            }\n        ]\n    },\n    \"calls\": {\n        \"ty\": 117\n    },\n    \"event\": {\n        \"ty\": 42\n    },\n    \"constants\": [],\n    \"error\": {\n        \"ty\": 124\n    },\n    \"index\": 8\n}\n</code></pre> <p>Every element metadata contains the name of the pallet it represents and information about its storage, calls, events, and errors. You can look up details about the definition of the calls, events, and errors by viewing the type index identifier. The type index identifier is the <code>u32</code> integer used to access the type information for that item. For example, the type index identifier for calls in the Sudo pallet is 117. If you view information for that type identifier in the <code>types</code> section of the metadata, it provides information about the available calls, including the documentation for each call.</p> <p>For example, the following is a condensed excerpt of the calls for the Sudo pallet:</p> <pre><code>{\n    \"id\": 117,\n    \"type\": {\n        \"path\": [\"pallet_sudo\", \"pallet\", \"Call\"],\n        \"params\": [\n            {\n                \"name\": \"T\",\n                \"type\": null\n            }\n        ],\n        \"def\": {\n            \"variant\": {\n                \"variants\": [\n                    {\n                        \"name\": \"sudo\",\n                        \"fields\": [\n                            {\n                                \"name\": \"call\",\n                                \"type\": 114,\n                                \"typeName\": \"Box&lt;&lt;T as Config&gt;::RuntimeCall&gt;\"\n                            }\n                        ],\n                        \"index\": 0,\n                        \"docs\": [\n                            \"Authenticates sudo key, dispatches a function call with `Root` origin\"\n                        ]\n                    },\n                    {\n                        \"name\": \"sudo_unchecked_weight\",\n                        \"fields\": [\n                            {\n                                \"name\": \"call\",\n                                \"type\": 114,\n                                \"typeName\": \"Box&lt;&lt;T as Config&gt;::RuntimeCall&gt;\"\n                            },\n                            {\n                                \"name\": \"weight\",\n                                \"type\": 8,\n                                \"typeName\": \"Weight\"\n                            }\n                        ],\n                        \"index\": 1,\n                        \"docs\": [\n                            \"Authenticates sudo key, dispatches a function call with `Root` origin\"\n                        ]\n                    },\n                    {\n                        \"name\": \"set_key\",\n                        \"fields\": [\n                            {\n                                \"name\": \"new\",\n                                \"type\": 103,\n                                \"typeName\": \"AccountIdLookupOf&lt;T&gt;\"\n                            }\n                        ],\n                        \"index\": 2,\n                        \"docs\": [\n                            \"Authenticates current sudo key, sets the given AccountId (`new`) as the new sudo\"\n                        ]\n                    },\n                    {\n                        \"name\": \"sudo_as\",\n                        \"fields\": [\n                            {\n                                \"name\": \"who\",\n                                \"type\": 103,\n                                \"typeName\": \"AccountIdLookupOf&lt;T&gt;\"\n                            },\n                            {\n                                \"name\": \"call\",\n                                \"type\": 114,\n                                \"typeName\": \"Box&lt;&lt;T as Config&gt;::RuntimeCall&gt;\"\n                            }\n                        ],\n                        \"index\": 3,\n                        \"docs\": [\n                            \"Authenticates sudo key, dispatches a function call with `Signed` origin from a given account\"\n                        ]\n                    }\n                ]\n            }\n        }\n    }\n}\n</code></pre> <p>For each field, you can access type information and metadata for the following:</p> <ul> <li>Storage metadata - provides the information required to enable applications to get information for specific storage items</li> <li>Call metadata - includes information about the runtime calls defined by the <code>#[pallet]</code> macro including call names, arguments and documentation</li> <li>Event metadata - provides the metadata generated by the <code>#[pallet::event]</code> macro, including the name, arguments, and documentation for each pallet event</li> <li>Constants metadata - provides metadata generated by the <code>#[pallet::constant]</code> macro, including the name, type, and hex-encoded value of the constant</li> <li>Error metadata - provides metadata generated by the <code>#[pallet::error]</code> macro, including the name and documentation for each pallet error</li> </ul> <p>Note</p> <p>Type identifiers change from time to time, so you should avoid relying on specific type identifiers in your applications.</p>"},{"location":"polkadot-protocol/basics/chain-data/#extrinsic","title":"Extrinsic","text":"<p>The runtime generates extrinsic metadata and provides useful information about transaction format. When decoded, the metadata contains the transaction version and the list of signed extensions.</p> <p>For example:</p> <pre><code>{\n    \"extrinsic\": {\n        \"ty\": 126,\n        \"version\": 4,\n        \"signed_extensions\": [\n            {\n                \"identifier\": \"CheckNonZeroSender\",\n                \"ty\": 132,\n                \"additional_signed\": 41\n            },\n            {\n                \"identifier\": \"CheckSpecVersion\",\n                \"ty\": 133,\n                \"additional_signed\": 4\n            },\n            {\n                \"identifier\": \"CheckTxVersion\",\n                \"ty\": 134,\n                \"additional_signed\": 4\n            },\n            {\n                \"identifier\": \"CheckGenesis\",\n                \"ty\": 135,\n                \"additional_signed\": 11\n            },\n            {\n                \"identifier\": \"CheckMortality\",\n                \"ty\": 136,\n                \"additional_signed\": 11\n            },\n            {\n                \"identifier\": \"CheckNonce\",\n                \"ty\": 138,\n                \"additional_signed\": 41\n            },\n            {\n                \"identifier\": \"CheckWeight\",\n                \"ty\": 139,\n                \"additional_signed\": 41\n            },\n            {\n                \"identifier\": \"ChargeTransactionPayment\",\n                \"ty\": 140,\n                \"additional_signed\": 41\n            }\n        ]\n    },\n    \"ty\": 141\n}\n</code></pre> <p>The type system is composite, meaning each type identifier contains a reference to a specific type or to another type identifier that provides information about the associated primitive types.</p> <p>For example, you can encode the <code>BitVec&lt;Order, Store&gt;</code> type, but to decode it properly, you must know the types used for the <code>Order</code> and <code>Store</code> types. To find type information for <code>Order</code> and <code>Store</code>, you can use the path in the decoded JSON to locate their type identifiers.</p>"},{"location":"polkadot-protocol/basics/chain-data/#included-rpc-apis","title":"Included RPC APIs","text":"<p>A standard node comes with the following APIs to interact with a node:</p> <ul> <li><code>AuthorApiServer</code> - make calls into a full node, including authoring extrinsics and verifying session keys</li> <li><code>ChainApiServer</code> - retrieve block header and finality information</li> <li><code>OffchainApiServer</code>  - make RPC calls for off-chain workers</li> <li><code>StateApiServer</code> - query information about on-chain state such as runtime version, storage items, and proofs</li> <li><code>SystemApiServer</code> - retrieve information about network state, such as connected peers and node roles</li> </ul>"},{"location":"polkadot-protocol/basics/chain-data/#additional-resources","title":"Additional Resources","text":"<p>The following tools can help you locate and decode metadata:</p> <ul> <li>Subxt Explorer</li> <li>Metadata Portal \ud83c\udf17</li> <li>De[code] Sub[strate]</li> </ul>"},{"location":"polkadot-protocol/basics/cryptography/","title":"Cryptography","text":""},{"location":"polkadot-protocol/basics/cryptography/#introduction","title":"Introduction","text":"<p>Cryptography forms the backbone of blockchain technology, providing the mathematical verifiability crucial for consensus systems, data integrity, and user security. While a deep understanding of the underlying mathematical processes isn't necessary for most blockchain developers, grasping the fundamental applications of cryptography is essential. This page comprehensively overviews cryptographic implementations used across Polkadot SDK-based chains and the broader blockchain ecosystem.</p>"},{"location":"polkadot-protocol/basics/cryptography/#hash-functions","title":"Hash Functions","text":"<p>Hash functions are fundamental to blockchain technology, creating a unique digital fingerprint for any piece of data, including simple text, images, or any other form of file. They map input data of any size to a fixed-size output (typically 32 bytes) using complex mathematical operations. Hashing is used to verify data integrity, create digital signatures, and provide a secure way to store passwords. This form of mapping is known as the \"pigeonhole principle,\" it is primarily implemented to efficiently and verifiably identify data from large sets.</p>"},{"location":"polkadot-protocol/basics/cryptography/#key-properties-of-hash-functions","title":"Key Properties of Hash Functions","text":"<ul> <li>Deterministic - the same input always produces the same output</li> <li>Quick computation - it's easy to calculate the hash value for any given input</li> <li>Pre-image resistance - it's infeasible to generate the input data from its hash</li> <li>Small changes in input yield large changes in output - known as the \"avalanche effect\"</li> <li>Collision resistance - the probabilities are extremely low to find two different inputs with the same hash</li> </ul>"},{"location":"polkadot-protocol/basics/cryptography/#blake2","title":"Blake2","text":"<p>The Polkadot SDK utilizes Blake2, a state-of-the-art hashing method that offers:</p> <ul> <li>Equal or greater security compared to SHA-2</li> <li>Significantly faster performance than other algorithms</li> </ul> <p>These properties make Blake2 ideal for blockchain systems, reducing sync times for new nodes and lowering the resources required for validation.</p> <p>Note</p> <p>For detailed technical specifications on Blake2, refer to the official Blake2 paper.</p>"},{"location":"polkadot-protocol/basics/cryptography/#types-of-cryptography","title":"Types of Cryptography","text":"<p>There are two different ways that cryptographic algorithms are implemented: symmetric cryptography and asymmetric cryptography.</p>"},{"location":"polkadot-protocol/basics/cryptography/#symmetric-cryptography","title":"Symmetric Cryptography","text":"<p>Symmetric encryption is a branch of cryptography that isn't based on one-way functions, unlike asymmetric cryptography. It uses the same cryptographic key to encrypt plain text and decrypt the resulting ciphertext.</p> <p>Symmetric cryptography is a type of encryption that has been used throughout history, such as the Enigma Cipher and the Caesar Cipher. It is still widely used today and can be found in Web2 and Web3 applications alike. There is only one single key, and a recipient must also have access to it to access the contained information.</p>"},{"location":"polkadot-protocol/basics/cryptography/#symmetric-advantages","title":"Advantages","text":"<ul> <li>Fast and efficient for large amounts of data</li> <li>Requires less computational power</li> </ul>"},{"location":"polkadot-protocol/basics/cryptography/#symmetric-disadvantages","title":"Disadvantages","text":"<ul> <li>Key distribution can be challenging</li> <li>Scalability issues in systems with many users</li> </ul>"},{"location":"polkadot-protocol/basics/cryptography/#asymmetric-cryptography","title":"Asymmetric Cryptography","text":"<p>Asymmetric encryption is a type of cryptography that uses two different keys, known as a keypair: a public key, used to encrypt plain text, and a private counterpart, used to decrypt the ciphertext.</p> <p>The public key encrypts a fixed-length message that can only be decrypted with the recipient's private key and, sometimes, a set password. The public key can be used to cryptographically verify that the corresponding private key was used to create a piece of data without compromising the private key, such as with digital signatures. This has obvious implications for identity, ownership, and properties and is used in many different protocols across Web2 and Web3.</p>"},{"location":"polkadot-protocol/basics/cryptography/#asymmetric-advantages","title":"Advantages","text":"<ul> <li>Solves the key distribution problem</li> <li>Enables digital signatures and secure key exchange</li> </ul>"},{"location":"polkadot-protocol/basics/cryptography/#asymmetric-disadvantages","title":"Disadvantages","text":"<ul> <li>Slower than symmetric encryption</li> <li>Requires more computational resources</li> </ul>"},{"location":"polkadot-protocol/basics/cryptography/#trade-offs-and-compromises","title":"Trade-offs and Compromises","text":"<p>Symmetric cryptography is faster and requires fewer bits in the key to achieve the same level of security that asymmetric cryptography provides. However, it requires a shared secret before communication can occur, which poses issues to its integrity and a potential compromise point. On the other hand, asymmetric cryptography doesn't require the secret to be shared ahead of time, allowing for far better end-user security.</p> <p>Hybrid symmetric and asymmetric cryptography is often used to overcome the engineering issues of asymmetric cryptography, as it is slower and requires more bits in the key to achieve the same level of security. It encrypts a key and then uses the comparatively lightweight symmetric cipher to do the \"heavy lifting\" with the message.</p>"},{"location":"polkadot-protocol/basics/cryptography/#digital-signatures","title":"Digital Signatures","text":"<p>Digital signatures are a way of verifying the authenticity of a document or message using asymmetric keypairs. They are used to ensure that a sender or signer's document or message hasn't been tampered with in transit, and for recipients to verify that the data is accurate and from the expected sender.</p> <p>Signing digital signatures only requires a low-level understanding of mathematics and cryptography. For a conceptual example -- when signing a check, it is expected that it cannot be cashed multiple times. This isn't a feature of the signature system but rather the check serialization system. The bank will check that the serial number on the check hasn't already been used. Digital signatures essentially combine these two concepts, allowing the signature to provide the serialization via a unique cryptographic fingerprint that cannot be reproduced.</p> <p>Unlike pen-and-paper signatures, knowledge of a digital signature cannot be used to create other signatures. Digital signatures are often used in bureaucratic processes, as they are more secure than simply scanning in a signature and pasting it onto a document.</p> <p>Polkadot SDK provides multiple different cryptographic schemes and is generic so that it can support anything that implements the <code>Pair</code> trait.</p>"},{"location":"polkadot-protocol/basics/cryptography/#example-of-creating-a-digital-signature","title":"Example of Creating a Digital Signature","text":"<p>The process of creating and verifying a digital signature involves several steps:</p> <ol> <li>The sender creates a hash of the message</li> <li>The hash is encrypted using the sender's private key, creating the signature</li> <li>The message and signature are sent to the recipient</li> <li>The recipient decrypts the signature using the sender's public key</li> <li>The recipient hashes the received message and compares it to the decrypted hash</li> </ol> <p>If the hashes match, the signature is valid, confirming the message's integrity and the sender's identity.</p>"},{"location":"polkadot-protocol/basics/cryptography/#elliptic-curve","title":"Elliptic Curve","text":"<p>Blockchain technology requires the ability to have multiple keys creating a signature for block proposal and validation. To this end, Elliptic Curve Digital Signature Algorithm (ECDSA) and Schnorr signatures are two of the most commonly used methods. While ECDSA is a far simpler implementation, Schnorr signatures are more efficient when it comes to multi-signatures.</p> <p>Schnorr signatures bring some noticeable features over the ECDSA/EdDSA schemes:</p> <ul> <li>It is better for hierarchical deterministic key derivations</li> <li>It allows for native multi-signature through signature aggregation</li> <li>It is generally more resistant to misuse</li> </ul> <p>One sacrifice that is made when using Schnorr signatures over ECDSA is that both require 64 bytes, but only ECDSA signatures communicate their public key.</p>"},{"location":"polkadot-protocol/basics/cryptography/#various-implementations","title":"Various Implementations","text":"<ul> <li> <p>ECDSA - Polkadot SDK provides an ECDSA signature scheme using the secp256k1 curve. This is the same cryptographic algorithm used to secure Bitcoin and Ethereum</p> </li> <li> <p>Ed25519 - is an EdDSA signature scheme using Curve25519. It is carefully engineered at several levels of design and implementation to achieve very high speeds without compromising security</p> </li> <li> <p>SR25519 - is based on the same underlying curve as Ed25519. However, it uses Schnorr signatures instead of the EdDSA scheme</p> </li> </ul>"},{"location":"polkadot-protocol/basics/data-encoding/","title":"Data Encoding","text":""},{"location":"polkadot-protocol/basics/data-encoding/#introduction","title":"Introduction","text":"<p>The Polkadot SDK uses a lightweight and efficient encoding/decoding mechanism to optimize data transmission across the network. This mechanism, known as the SCALE codec, is used for serializing and deserializing data.</p> <p>The SCALE codec enables communication between the runtime and the outer node. This mechanism is designed for high-performance, copy-free data encoding and decoding in resource-constrained environments like the Polkadot SDK Wasm runtime.</p> <p>It is not self-describing, meaning the decoding context must fully know the encoded data types. </p> <p>Parity's libraries utilize the <code>parity-scale-codec</code> crate (a Rust implementation of the SCALE codec) to handle encoding and decoding for interactions between RPCs and the runtime.</p> <p>The <code>codec</code> mechanism is ideal for Polkadot SDK-based chains because:</p> <ul> <li>It is lightweight compared to generic serialization frameworks like <code>serde</code>, which add unnecessary bulk to binaries</li> <li>It doesn\u2019t rely on Rust\u2019s <code>libstd</code>, making it compatible with <code>no_std</code> environments like Wasm runtime</li> <li>It integrates seamlessly with Rust, allowing easy derivation of encoding and decoding logic for new types using <code>#[derive(Encode, Decode)]</code></li> </ul> <p>Defining a custom encoding scheme in the Polkadot SDK-based chains, rather than using an existing Rust codec library, is crucial for enabling cross-platform and multi-language support. </p>"},{"location":"polkadot-protocol/basics/data-encoding/#scale-codec","title":"SCALE Codec","text":"<p>The codec is implemented using the following traits:</p> <ul> <li><code>Encode</code></li> <li><code>Decode</code></li> <li><code>CompactAs</code></li> <li><code>HasCompact</code></li> <li><code>EncodeLike</code></li> </ul>"},{"location":"polkadot-protocol/basics/data-encoding/#encode","title":"Encode","text":"<p>The <code>Encode</code> trait handles data encoding into SCALE format and includes the following key functions:</p> <ul> <li><code>size_hint(&amp;self) -&gt; usize</code> - estimates the number of bytes required for encoding to prevent multiple memory allocations. This should be inexpensive and avoid complex operations. Optional if the size isn\u2019t known</li> <li><code>encode_to&lt;T: Output&gt;(&amp;self, dest: &amp;mut T)</code> - encodes the data, appending it to a destination buffer</li> <li><code>encode(&amp;self) -&gt; Vec&lt;u8&gt;</code> - encodes the data and returns it as a byte vector</li> <li><code>using_encoded&lt;R, F: FnOnce(&amp;[u8]) -&gt; R&gt;(&amp;self, f: F) -&gt; R</code> - encodes the data and passes it to a closure, returning the result</li> <li><code>encoded_size(&amp;self) -&gt; usize</code> - calculates the encoded size. Should be used when the encoded data isn\u2019t required</li> </ul> <p>Note</p> <p>For best performance, value types should override <code>using_encoded</code>, and allocating types should override <code>encode_to</code>. It's recommended to implement <code>size_hint</code> for all types where possible.</p>"},{"location":"polkadot-protocol/basics/data-encoding/#decode","title":"Decode","text":"<p>The <code>Decode</code> trait handles decoding SCALE-encoded data back into the appropriate types:</p> <ul> <li><code>fn decode&lt;I: Input&gt;(value: &amp;mut I) -&gt; Result&lt;Self, Error&gt;</code> - decodes data from the SCALE format, returning an error if decoding fails</li> </ul>"},{"location":"polkadot-protocol/basics/data-encoding/#compactas","title":"CompactAs","text":"<p>The <code>CompactAs</code> trait wraps custom types for compact encoding:</p> <ul> <li><code>encode_as(&amp;self) -&gt; &amp;Self::As</code> - encodes the type as a compact type</li> <li><code>decode_from(_: Self::As) -&gt; Result&lt;Self, Error&gt;</code> - decodes from a compact encoded type</li> </ul>"},{"location":"polkadot-protocol/basics/data-encoding/#hascompact","title":"HasCompact","text":"<p>The <code>HasCompact</code> trait indicates a type supports compact encoding.</p>"},{"location":"polkadot-protocol/basics/data-encoding/#encodelike","title":"EncodeLike","text":"<p>The <code>EncodeLike</code> trait is used to ensure multiple types that encode similarly are accepted by the same function. When using <code>derive</code>, it is automatically implemented.</p>"},{"location":"polkadot-protocol/basics/data-encoding/#data-types","title":"Data Types","text":"<p>The table below outlines how the Rust implementation of the Parity SCALE codec encodes different data types.</p> Type Description Example SCALE Decoded Value SCALE Encoded Value Boolean Boolean values are encoded using the least significant bit of a single byte. <code>false</code> / <code>true</code> <code>0x00</code> / <code>0x01</code> Compact/general integers A \"compact\" or general integer encoding is sufficient for encoding large integers (up to 2^536) and is more efficient at encoding most values than the fixed-width version. <code>unsigned integer 0</code> / <code>unsigned integer 1</code> / <code>unsigned integer 42</code> / <code>unsigned integer 69</code> / <code>unsigned integer 65535</code> / <code>BigInt(100000000000000)</code> <code>0x00</code> / <code>0x04</code> / <code>0xa8</code> / <code>0x1501</code> / <code>0xfeff0300</code> / <code>0x0b00407a10f35a</code> Enumerations (tagged-unions) A fixed number of variants Fixed-width integers Basic integers are encoded using a fixed-width little-endian (LE) format. <code>signed 8-bit integer 69</code> / <code>unsigned 16-bit integer 42</code> / <code>unsigned 32-bit integer 16777215</code> <code>0x45</code> / <code>0x2a00</code> / <code>0xffffff00</code> Options One or zero values of a particular type. <code>Some</code> / <code>None</code> <code>0x01</code> followed by the encoded value / <code>0x00</code> Results Results are commonly used enumerations which indicate whether certain operations were successful or unsuccessful. <code>Ok(42)</code> / <code>Err(false)</code> <code>0x002a</code> / <code>0x0100</code> Strings Strings are Vectors of bytes (Vec) containing a valid UTF8 sequence. Structs For structures, the values are named, but that is irrelevant for the encoding (names are ignored - only order matters). <code>SortedVecAsc::from([3, 5, 2, 8])</code> <code>[3, 2, 5, 8]</code> Tuples A fixed-size series of values, each with a possibly different but predetermined and fixed type. This is simply the concatenation of each encoded value. Tuple of compact unsigned integer and boolean: <code>(3, false)</code> <code>0x0c00</code> Vectors (lists, series, sets) A collection of same-typed values is encoded, prefixed with a compact encoding of the number of items, followed by each item's encoding concatenated in turn. Vector of unsigned <code>16</code>-bit integers: <code>[4, 8, 15, 16, 23, 42]</code> <code>0x18040008000f00100017002a00</code>"},{"location":"polkadot-protocol/basics/data-encoding/#encode-and-decode-rust-trait-implementations","title":"Encode and Decode Rust Trait Implementations","text":"<p>Here's how the <code>Encode</code> and <code>Decode</code> traits are implemented:</p> <pre><code>use parity_scale_codec::{Encode, Decode};\n\n[derive(Debug, PartialEq, Encode, Decode)]\nenum EnumType {\n    #[codec(index = 15)]\n    A,\n    B(u32, u64),\n    C {\n        a: u32,\n        b: u64,\n    },\n}\n\nlet a = EnumType::A;\nlet b = EnumType::B(1, 2);\nlet c = EnumType::C { a: 1, b: 2 };\n\na.using_encoded(|ref slice| {\n    assert_eq!(slice, &amp;b\"\\x0f\");\n});\n\nb.using_encoded(|ref slice| {\n    assert_eq!(slice, &amp;b\"\\x01\\x01\\0\\0\\0\\x02\\0\\0\\0\\0\\0\\0\\0\");\n});\n\nc.using_encoded(|ref slice| {\n    assert_eq!(slice, &amp;b\"\\x02\\x01\\0\\0\\0\\x02\\0\\0\\0\\0\\0\\0\\0\");\n});\n\nlet mut da: &amp;[u8] = b\"\\x0f\";\nassert_eq!(EnumType::decode(&amp;mut da).ok(), Some(a));\n\nlet mut db: &amp;[u8] = b\"\\x01\\x01\\0\\0\\0\\x02\\0\\0\\0\\0\\0\\0\\0\";\nassert_eq!(EnumType::decode(&amp;mut db).ok(), Some(b));\n\nlet mut dc: &amp;[u8] = b\"\\x02\\x01\\0\\0\\0\\x02\\0\\0\\0\\0\\0\\0\\0\";\nassert_eq!(EnumType::decode(&amp;mut dc).ok(), Some(c));\n\nlet mut dz: &amp;[u8] = &amp;[0];\nassert_eq!(EnumType::decode(&amp;mut dz).ok(), None);\n</code></pre>"},{"location":"polkadot-protocol/basics/data-encoding/#scale-codec-libraries","title":"SCALE Codec Libraries","text":"<p>Several SCALE codec implementations are available in various languages. Here's a list of them:</p> <ul> <li>AssemblyScript - <code>LimeChain/as-scale-codec</code></li> <li>C - <code>MatthewDarnell/cScale</code></li> <li>C++ - <code>qdrvm/scale-codec-cpp</code></li> <li>JavaScript - <code>polkadot-js/api</code></li> <li>Dart - <code>leonardocustodio/polkadart</code></li> <li>Haskell - <code>airalab/hs-web3</code></li> <li>Golang - <code>itering/scale.go</code></li> <li>Java - <code>splix/polkaj</code></li> <li>Python - <code>polkascan/py-scale-codec</code></li> <li>Ruby - <code>wuminzhe/scale_rb</code></li> <li>TypeScript - <code>parity-scale-codec-ts</code>, <code>scale-ts</code>, <code>soramitsu/scale-codec-js-library</code>, <code>subsquid/scale-codec</code></li> </ul>"},{"location":"polkadot-protocol/basics/interoperability/","title":"Interoperability","text":""},{"location":"polkadot-protocol/basics/interoperability/#introduction","title":"Introduction","text":"<p>Interoperability lies at the heart of the Polkadot ecosystem, enabling communication and collaboration across a diverse range of blockchains. By bridging the gaps between parachains, relay chains, and even external networks, Polkadot unlocks the potential for truly decentralized applications, efficient resource sharing, and scalable solutions.</p> <p>Polkadot\u2019s design ensures that blockchains can transcend their individual limitations by working together as part of a unified system. This cooperative architecture is what sets Polkadot apart in the blockchain landscape.</p>"},{"location":"polkadot-protocol/basics/interoperability/#why-interoperability-matters","title":"Why Interoperability Matters","text":"<p>The blockchain ecosystem is inherently fragmented. Different blockchains excel in specialized domains such as finance, gaming, or supply chain management, but these chains function in isolation without interoperability. This lack of connectivity stifles the broader utility of blockchain technology.</p> <p>Interoperability solves this problem by enabling blockchains to:</p> <ul> <li>Collaborate across networks - chains can interact to share assets, functionality, and data, creating synergies that amplify their individual strengths</li> <li>Achieve greater scalability - specialized chains can offload tasks to others, optimizing performance and resource utilization</li> <li>Expand use-case potential - cross-chain applications can leverage features from multiple blockchains, unlocking novel user experiences and solutions</li> </ul> <p>In the Polkadot ecosystem, interoperability transforms a collection of isolated chains into a cohesive, efficient network, pushing the boundaries of what blockchains can achieve together.</p>"},{"location":"polkadot-protocol/basics/interoperability/#key-mechanisms-for-interoperability","title":"Key Mechanisms for Interoperability","text":"<p>At the core of Polkadot's cross-chain collaboration are foundational technologies designed to break down barriers between networks. These mechanisms empower blockchains to communicate, share resources, and operate as a cohesive ecosystem.</p>"},{"location":"polkadot-protocol/basics/interoperability/#cross-consensus-messaging-xcm-the-backbone-of-communication","title":"Cross-Consensus Messaging (XCM): The Backbone of Communication","text":"<p>Polkadot's Cross-Consensus Messaging (XCM) is the standard framework for interaction between parachains, relay chains, and, eventually, external blockchains. XCM provides a trustless, secure messaging format for exchanging assets, sharing data, and executing cross-chain operations.</p> <p>Through XCM, decentralized applications can:</p> <ul> <li>Transfer tokens and other assets across chains</li> <li>Coordinate complex workflows that span multiple blockchains</li> <li>Enable seamless user experiences where underlying blockchain differences are invisible</li> <li>XCM exemplifies Polkadot\u2019s commitment to creating a robust and interoperable ecosystem</li> </ul> <p>For further information about XCM, check the Introduction to XCM article.</p>"},{"location":"polkadot-protocol/basics/interoperability/#bridges-connecting-external-networks","title":"Bridges: Connecting External Networks","text":"<p>While XCM enables interoperability within the Polkadot ecosystem, bridges extend this functionality to external blockchains such as Ethereum and Bitcoin. By connecting these networks, bridges allow Polkadot-based chains to access external liquidity, additional functionalities, and broader user bases.</p> <p>With bridges, developers and users gain the ability to:</p> <ul> <li>Integrate external assets into Polkadot-based applications</li> <li>Combine the strengths of Polkadot\u2019s scalability with the liquidity of other networks</li> <li>Facilitate accurate multi-chain applications that transcend ecosystem boundaries</li> </ul> <p>For more information about bridges in the Polkadot ecosystem, see the Bridge Hub guide.</p>"},{"location":"polkadot-protocol/basics/interoperability/#the-polkadot-advantage","title":"The Polkadot Advantage","text":"<p>Polkadot was purpose-built for interoperability. Unlike networks that add interoperability as an afterthought, Polkadot integrates it as a fundamental design principle. This approach offers several distinct advantages:</p> <ul> <li>Developer empowerment - polkadot\u2019s interoperability tools allow developers to build applications that leverage multiple chains\u2019 capabilities without added complexity</li> <li>Enhanced ecosystem collaboration - chains in Polkadot can focus on their unique strengths while contributing to the ecosystem\u2019s overall growth</li> <li>Future-proofing blockchain - by enabling seamless communication, Polkadot ensures its ecosystem can adapt to evolving demands and technologies</li> </ul>"},{"location":"polkadot-protocol/basics/interoperability/#looking-ahead","title":"Looking Ahead","text":"<p>Polkadot\u2019s vision of interoperability extends beyond technical functionality, representing a shift towards a more collaborative blockchain landscape. By enabling chains to work together, Polkadot fosters innovation, efficiency, and accessibility, paving the way for a decentralized future where blockchains are not isolated competitors but interconnected collaborators.</p>"},{"location":"polkadot-protocol/basics/networks/","title":"Networks","text":""},{"location":"polkadot-protocol/basics/networks/#introduction","title":"Introduction","text":"<p>The Polkadot ecosystem is built on a robust set of networks designed to enable secure and scalable development. Whether you are testing new features or deploying to live production, Polkadot offers several layers of networks tailored for each stage of the development process. From local environments to experimental networks like Kusama and community-run TestNets such as Paseo, developers can thoroughly test, iterate, and validate their applications. This guide will introduce you to Polkadot's various networks and explain how they fit into the development workflow.</p>"},{"location":"polkadot-protocol/basics/networks/#network-overview","title":"Network Overview","text":"<p>Polkadot's development process is structured to ensure new features and upgrades are rigorously tested before being deployed on live production networks. The progression follows a well-defined path, starting from local environments and advancing through TestNets, ultimately reaching the Polkadot MainNet. The diagram below outlines the typical progression of the Polkadot development cycle:</p> <p><pre><code>\nflowchart LR\n    id1[Local] --&gt; id2[Westend] --&gt; id4[Kusama] --&gt; id5[Polkadot]  \n    id1[Local] --&gt; id3[Paseo] --&gt; id5[Polkadot] </code></pre> This flow ensures developers can thoroughly test and iterate without risking real tokens or affecting production networks. Testing tools like Chopsticks and various TestNets make it easier to experiment safely before releasing to production.</p> <p>A typical journey through the Polkadot core protocol development process might look like this:</p> <ol> <li> <p>Local development node - development starts in a local environment, where developers can create, test, and iterate on upgrades or new features using a local development node. This stage allows rapid experimentation in an isolated setup without any external dependencies</p> </li> <li> <p>Westend - after testing locally, upgrades are deployed to Westend, Polkadot's primary TestNet. Westend simulates real-world conditions without using real tokens, making it the ideal place for rigorous feature testing before moving on to production networks</p> </li> <li> <p>Kusama - once features have passed extensive testing on Westend, they move to Kusama, Polkadot's experimental and fast-moving \"canary\" network. Kusama operates as a high-fidelity testing ground with actual economic incentives, giving developers insights into how their features will perform in a real-world environment</p> </li> <li> <p>Polkadot - after passing tests on Westend and Kusama, features are considered ready for deployment to Polkadot, the live production network</p> </li> </ol> <p>In addition, parachain developers can leverage local TestNets like Zombienet and deploy upgrades on parachain TestNets.</p> <ol> <li>Paseo - For parachain and dApp developers, Paseo serves as a community-run TestNet that mirrors Polkadot's runtime. Like Westend for core protocol development, Paseo provides a testing ground for parachain development without affecting live networks</li> </ol> <p>Note</p> <p>The Rococo TestNet deprecation date was October 14, 2024. Teams should use Westend for Polkadot protocol and feature testing and Paseo for chain development-related testing.</p>"},{"location":"polkadot-protocol/basics/networks/#polkadot-development-networks","title":"Polkadot Development Networks","text":"<p>Development and testing are crucial to building robust dApps and parachains and performing network upgrades within the Polkadot ecosystem. To achieve this, developers can leverage various networks and tools that provide a risk-free environment for experimentation and validation before deploying features to live networks. These networks help avoid the costs and risks associated with real tokens, enabling testing for functionalities like governance, cross-chain messaging, and runtime upgrades.</p>"},{"location":"polkadot-protocol/basics/networks/#kusama-network","title":"Kusama Network","text":"<p>Kusama is the experimental version of Polkadot, designed for developers who want to move quickly and test their applications in a real-world environment with economic incentives. Kusama serves as a production-grade testing ground where developers can deploy features and upgrades with the pressure of game theory and economics in mind. It mirrors Polkadot but operates as a more flexible space for innovation.</p> <p>The native token for Kusama is KSM. For more information about KSM, visit the Native Assets page.</p>"},{"location":"polkadot-protocol/basics/networks/#test-networks","title":"Test Networks","text":"<p>The following test networks provide controlled environments for testing upgrades and new features. TestNet tokens are available from the Polkadot faucet.</p>"},{"location":"polkadot-protocol/basics/networks/#westend","title":"Westend","text":"<p>Westend is Polkadot's primary permanent TestNet. Unlike temporary test networks, Westend is not reset to the genesis block, making it an ongoing environment for testing Polkadot core features. Managed by Parity Technologies, Westend ensures that developers can test features in a real-world simulation without using actual tokens.</p> <p>The native token for Westend is WND. More details about WND can be found on the Native Assets page.</p>"},{"location":"polkadot-protocol/basics/networks/#paseo","title":"Paseo","text":"<p>Paseo is a community-managed TestNet designed for parachain and dApp developers. It mirrors Polkadot's runtime and is maintained by Polkadot community members. Paseo provides a dedicated space for parachain developers to test their applications in a Polkadot-like environment without the risks associated with live networks.</p> <p>The native token for Paseo is PAS. Additional information on PAS is available on the Native Assets page.</p>"},{"location":"polkadot-protocol/basics/networks/#local-test-networks","title":"Local Test Networks","text":"<p>Local test networks are an essential part of the development cycle for blockchain developers using the Polkadot SDK. They allow for fast, iterative testing in controlled, private environments without connecting to public TestNets. Developers can quickly spin up local instances to experiment, debug, and validate their code before deploying to larger TestNets like Westend or Paseo. Two key tools for local network testing are Zombienet and Chopsticks.</p>"},{"location":"polkadot-protocol/basics/networks/#zombienet","title":"Zombienet","text":"<p>Zombienet is a flexible testing framework for Polkadot SDK-based blockchains. It enables developers to create and manage ephemeral, short-lived networks. This feature makes Zombienet particularly useful for quick iterations, as it allows you to run multiple local networks concurrently, mimicking different runtime conditions. Whether you're developing a parachain or testing your custom blockchain logic, Zombienet gives you the tools to automate local testing.</p> <p>Key features of Zombienet include:</p> <ul> <li>Creating dynamic, local networks with different configurations</li> <li>Running parachains and relay chains in a simulated environment</li> <li>Efficient testing of network components like cross-chain messaging and governance</li> </ul> <p>Zombienet is ideal for developers looking to test quickly and thoroughly before moving to more resource-intensive public TestNets.</p>"},{"location":"polkadot-protocol/basics/networks/#chopsticks","title":"Chopsticks","text":"<p>Chopsticks is a tool designed to create forks of Polkadot SDK-based blockchains, allowing developers to interact with network forks as part of their testing process. This capability makes Chopsticks a powerful option for testing upgrades, runtime changes, or cross-chain applications in a forked network environment.</p> <p>Key features of Chopsticks include:</p> <ul> <li>Forking live Polkadot SDK-based blockchains for isolated testing</li> <li>Simulating cross-chain messages in a private, controlled setup</li> <li>Debugging network behavior by interacting with the fork in real-time</li> </ul> <p>Chopsticks provides a controlled environment for developers to safely explore the effects of runtime changes. It ensures that network behavior is tested and verified before upgrades are deployed to live networks.</p>"},{"location":"polkadot-protocol/basics/randomness/","title":"Randomness","text":""},{"location":"polkadot-protocol/basics/randomness/#introduction","title":"Introduction","text":"<p>Randomness is crucial in Proof of Stake (PoS) blockchains to ensure a fair and unpredictable distribution of validator duties. However, computers are inherently deterministic, meaning the same input always produces the same output. What we typically refer to as \"random\" numbers on a computer are actually pseudo-random. These numbers rely on an initial \"seed,\" which can come from external sources like atmospheric noise, heart rates, or even lava lamps. While this may seem random, given the same \"seed,\" the same sequence of numbers will always be generated.</p> <p>In a global blockchain network, relying on real-world entropy for randomness isn\u2019t feasible because these inputs vary by time and location. If nodes use different inputs, blockchains can fork. Hence, real-world randomness isn't suitable for use as a seed in blockchain systems.</p> <p>Currently, two primary methods for generating randomness in blockchains are used: <code>RANDAO</code> and <code>VRF</code> (Verifiable Random Function). Polkadot adopts the <code>VRF</code> approach for its randomness.</p>"},{"location":"polkadot-protocol/basics/randomness/#vrf","title":"VRF","text":"<p>A\u00a0Verifiable Random Function (VRF)\u00a0is a cryptographic function that generates a random number and proof that ensures the submitter produced the number. This proof allows anyone to verify the validity of the random number.</p> <p>Polkadot's VRF is similar to the one used in Ouroboros Praos, which secures randomness for block production in systems like BABE (Polkadot\u2019s block production mechanism). </p> <p>The key difference is that Polkadot's VRF doesn\u2019t rely on a central clock\u2014avoiding the issue of whose clock to trust. Instead, it uses its own past results and slot numbers to simulate time and determine future outcomes.</p>"},{"location":"polkadot-protocol/basics/randomness/#how-vrf-works","title":"How VRF Works","text":"<p>Slots on Polkadot are discrete units of time, each lasting six seconds, and can potentially hold a block. Multiple slots form an epoch, with 2400 slots making up one four-hour epoch.</p> <p>In each slot, validators execute a \"die roll\" using a VRF. The VRF uses three inputs:</p> <ol> <li>A \"secret key\", unique to each validator, is used for the die roll</li> <li>An epoch randomness value, derived from the hash of VRF outputs from blocks two epochs ago (N-2), so past randomness influences the current epoch (N)</li> <li>The current slot number</li> </ol> <p>This process helps maintain fair randomness across the network.</p> <p>Here is a graphical representation:</p> <p></p> <p>The VRF produces two outputs: a result (the random number) and a proof (verifying that the number was generated correctly).</p> <p>The\u00a0result\u00a0is checked by the validator against a protocol threshold. If it's below the threshold, the validator becomes a candidate for block production in that slot. </p> <p>The validator then attempts to create a block, submitting it along with the <code>PROOF</code> and <code>RESULT</code>.</p> <p>So, VRF can be expressed like:</p> <p><code>(RESULT, PROOF) = VRF(SECRET, EPOCH_RANDOMNESS_VALUE, CURRENT_SLOT_NUMBER)</code></p> <p>Put simply, performing a \"VRF roll\" generates a random number along with proof that the number was genuinely produced and not arbitrarily chosen.</p> <p>After executing the VRF, the <code>RESULT</code> is compared to a protocol-defined <code>THRESHOLD</code>. If the <code>RESULT</code> is below the <code>THRESHOLD</code>, the validator becomes a valid candidate to propose a block for that slot. Otherwise, the validator skips the slot.</p> <p>As a result, there may be multiple validators eligible to propose a block for a slot. In this case, the block accepted by other nodes will prevail, provided it is on the chain with the latest finalized block as determined by the GRANDPA finality gadget. It's also possible for no block producers to be available for a slot, in which case the AURA consensus takes over. AURA is a fallback mechanism that randomly selects a validator to produce a block, running in parallel with BABE and only stepping in when no block producers exist for a slot. Otherwise, it remains inactive.</p> <p>Because validators roll independently, no block candidates may appear in some slots if all roll numbers are above the threshold. </p> <p>Note</p> <p>The resolution of this issue and the assurance that Polkadot block times remain near constant-time can be checked on the PoS Consensus page.</p>"},{"location":"polkadot-protocol/basics/randomness/#randao","title":"RANDAO","text":"<p>An alternative on-chain randomness method is Ethereum's\u00a0RANDAO, where validators perform thousands of hashes on a seed and publish the final hash during a round. The collective input from all validators forms the random number, and as long as one honest validator participates, the randomness is secure.</p> <p>To enhance security,\u00a0RANDAO\u00a0can optionally be combined with a\u00a0Verifiable Delay Function (VDF), ensuring that randomness can't be predicted or manipulated during computation.</p> <p>Note</p> <p>More information about RANDAO can be found in the ETH documentation.</p>"},{"location":"polkadot-protocol/basics/randomness/#vdfs","title":"VDFs","text":"<p>Verifiable Delay Functions (VDFs) are time-bound computations that, even on parallel computers, take a set amount of time to complete. </p> <p>They produce a unique result that can be quickly verified publicly. When combined with RANDAO, feeding RANDAO's output into a VDF introduces a delay that nullifies an attacker's chance to influence the randomness.</p> <p>However,\u00a0VDF\u00a0likely requires specialized ASIC devices to run separately from standard nodes.</p> <p>Warning</p> <p>While only one is needed to secure the system, and they will be open-source and inexpensive, running them involves significant costs without direct incentives, adding friction for blockchain users.</p>"},{"location":"polkadot-protocol/basics/randomness/#additional-resources","title":"Additional Resources","text":"<ul> <li>Polkadot's research on blockchain randomness and sortition - contains reasoning for choices made along with proofs</li> <li>Discussion on Randomness used in Polkadot - W3F researchers explore when and under what conditions Polkadot's randomness can be utilized</li> </ul>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/","title":"Blocks, Transactions, and Fees","text":"<p>Dive into the structure, processing, and lifecycle of blocks and transactions in Polkadot, and learn how fees are calculated and applied.</p>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/blocks/","title":"Blocks","text":""},{"location":"polkadot-protocol/basics/blocks-transactions-fees/blocks/#introduction","title":"Introduction","text":"<p>In the Polkadot SDK, blocks are fundamental to the functioning of the blockchain, serving as containers for transactions and changes to the chain's state. Blocks consist of headers and an array of transactions, ensuring the integrity and validity of operations on the network. This guide explores the essential components of a block, the process of block production, and how blocks are validated and imported across the network. By understanding these concepts, developers can better grasp how blockchains maintain security, consistency, and performance within the Polkadot ecosystem.</p>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/blocks/#what-is-a-block","title":"What is a Block?","text":"<p>In the Polkadot SDK, a block is a fundamental unit that encapsulates both the header and an array of transactions. The block header includes critical metadata to ensure the integrity and sequence of the blockchain. Here's a breakdown of its components:</p> <ul> <li>Block height - indicates the number of blocks created in the chain so far</li> <li>Parent hash - the hash of the previous block, providing a link to maintain the blockchain's immutability</li> <li>Transaction root - cryptographic digest summarizing all transactions in the block</li> <li>State root - a cryptographic digest representing the post-execution state</li> <li>Digest - additional information that can be attached to a block, such as consensus-related messages</li> </ul> <p>Each transaction is part of a series that is executed according to the runtime's rules. The transaction root is a cryptographic digest of this series, which prevents alterations and enables succinct verification by light clients. This verification process allows light clients to confirm whether a transaction exists in a block with only the block header, avoiding downloading the entire block.</p>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/blocks/#block-production","title":"Block Production","text":"<p>When an authoring node is authorized to create a new block, it selects transactions from the transaction queue based on priority. This step, known as block production, relies heavily on the executive module to manage the initialization and finalization of blocks. The process is summarized as follows:</p>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/blocks/#initialize-block","title":"Initialize Block","text":"<p>The block initialization process begins with a series of function calls that prepare the block for transaction execution:</p> <ol> <li>Call <code>on_initialize</code> - the executive module calls the\u00a0<code>on_initialize</code>\u00a0hook from the system pallet and other runtime pallets to prepare for the block's transactions</li> <li>Coordinate runtime calls - coordinates function calls in the order defined by the transaction queue</li> <li>Verify information - once <code>on_initialize</code>\u00a0functions are executed, the executive module checks the parent hash in the block header and the trie root to verify information is consistent</li> </ol>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/blocks/#finalize-block","title":"Finalize Block","text":"<p>Once transactions are processed, the block must be finalized before being broadcast to the network. The finalization steps are as follows:</p> <ol> <li>-Call <code>on_finalize</code> - the executive module calls the <code>on_finalize</code> hooks in each pallet to ensure any remaining state updates or checks are completed before the block is sealed and published </li> <li>-Verify information - the block's digest and storage root in the header are checked against the initialized block to ensure consistency</li> <li>-Call <code>on_idle</code> - the\u00a0<code>on_idle</code> hook is triggered to process any remaining tasks using the leftover weight from the block</li> </ol>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/blocks/#block-authoring-and-import","title":"Block Authoring and Import","text":"<p>Once the block is finalized, it is gossiped to other nodes in the network. Nodes follow this procedure:</p> <ol> <li>Receive transactions - the authoring node collects transactions from the network</li> <li>Validate - transactions are checked for validity</li> <li>Queue - valid transactions are placed in the transaction pool for execution</li> <li>Execute - state changes are made as the transactions are executed</li> <li>Publish - the finalized block is broadcast to the network</li> </ol>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/blocks/#block-import-queue","title":"Block Import Queue","text":"<p>After a block is published, other nodes on the network can import it into their chain state. The block import queue is part of the outer node in every Polkadot SDK-based node and ensures incoming blocks are valid before adding them to the node's state.</p> <p>In most cases, you don't need to know details about how transactions are gossiped or how other nodes on the network import blocks. The following traits are relevant, however, if you plan to write any custom consensus logic or want a deeper dive into the block import queue:</p> <ul> <li><code>ImportQueue</code> - the trait that defines the block import queue</li> <li><code>Link</code> - the trait that defines the link between the block import queue and the network</li> <li><code>BasicQueue</code> - a basic implementation of the block import queue</li> <li><code>Verifier</code> - the trait that defines the block verifier</li> <li><code>BlockImport</code> - the trait that defines the block import process</li> </ul> <p>These traits govern how blocks are validated and imported across the network, ensuring consistency and security.</p> Additional information <p>Refer to the <code>Block</code> reference to learn more about the block structure in the Polkadot SDK runtime.</p>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/fees/","title":"Transactions Weights and Fees","text":""},{"location":"polkadot-protocol/basics/blocks-transactions-fees/fees/#introductions","title":"Introductions","text":"<p>When transactions are executed, or data is stored on-chain, the activity changes the chain's state and consumes blockchain resources. Because the resources available to a blockchain are limited, managing how operations on-chain consume them is important. In addition to being limited in practical terms, such as storage capacity, blockchain resources represent a potential attack vector for malicious users. For example, a malicious user might attempt to overload the network with messages to stop the network from producing new blocks. To protect blockchain resources from being drained or overloaded, you need to manage how they are made available and how they are consumed. The resources to be aware of include:</p> <ul> <li>Memory usage</li> <li>Storage input and output</li> <li>Computation</li> <li>Transaction and block size</li> <li>State database size</li> </ul> <p>The Polkadot SDK provides block authors with several ways to manage access to resources and to prevent individual components of the chain from consuming too much of any single resource. Two of the most important mechanisms available to block authors are\u00a0weights\u00a0and\u00a0transaction fees.</p> <p>Weights\u00a0manage the time it takes to validate a block and characterize the time it takes to execute the calls in the block's body. By controlling the execution time a block can consume, weights set limits on storage input, output, and computation.</p> <p>Some of the weight allowed for a block is consumed as part of the block's initialization and finalization. The weight might also be used to execute mandatory inherent extrinsic calls. To help ensure blocks don\u2019t consume too much execution time and prevent malicious users from overloading the system with unnecessary calls, weights are combined with\u00a0transaction fees.</p> <p>Transaction fees provide an economic incentive to limit execution time, computation, and the number of calls required to perform operations. Transaction fees are also used to make the blockchain economically sustainable because they are typically applied to transactions initiated by users and deducted before a transaction request is executed.</p>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/fees/#how-fees-are-calculated","title":"How Fees are Calculated","text":"<p>The final fee for a transaction is calculated using the following parameters:</p> <ul> <li><code>base fee</code> - this is the minimum amount a user pays for a transaction. It is declared a\u00a0base weight\u00a0in the runtime and converted to a fee using the\u00a0<code>WeightToFee</code>\u00a0conversion</li> <li><code>weight fee</code> - a fee proportional to the execution time (input and output and computation) that a transaction consumes</li> <li><code>length fee</code> - a fee proportional to the encoded length of the transaction</li> <li><code>tip</code> - an optional tip to increase the transaction\u2019s priority, giving it a higher chance to be included in the transaction queue</li> </ul> <p>The base fee and proportional weight and length fees constitute the\u00a0inclusion fee. The inclusion fee is the minimum fee that must be available for a transaction to be included in a block.</p> <pre><code>inclusion fee = base fee + weight fee + length fee\n</code></pre> <p>Transaction fees are withdrawn before the transaction is executed. After the transaction is executed, the weight can be adjusted to reflect the resources used. If a transaction uses fewer resources than expected, the transaction fee is corrected, and the adjusted transaction fee is deposited.</p>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/fees/#using-the-transaction-payment-pallet","title":"Using the Transaction Payment Pallet","text":"<p>The\u00a0Transaction Payment pallet\u00a0provides the basic logic for calculating the inclusion fee. You can also use the Transaction Payment pallet to:</p> <ul> <li>Convert a weight value into a deductible fee based on a currency type using\u00a0<code>Config::WeightToFee</code></li> <li>Update the fee for the next block by defining a multiplier based on the chain\u2019s final state at the end of the previous block using\u00a0<code>Config::FeeMultiplierUpdate</code></li> <li>Manage the withdrawal, refund, and deposit of transaction fees using\u00a0<code>Config::OnChargeTransaction</code></li> </ul> <p>You can learn more about these configuration traits in the\u00a0Transaction Payment\u00a0documentation.</p>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/fees/#understanding-the-inclusion-fee","title":"Understanding the Inclusion Fee","text":"<p>The formula for calculating the inclusion fee is as follows:</p> <pre><code>inclusion_fee = base_fee + length_fee + [targeted_fee_adjustment * weight_fee]\n</code></pre> <p>And then, for calculating the final fee:</p> <pre><code>final_fee = inclusion_fee + tip\n</code></pre> <p>In the first formula, the\u00a0<code>targeted_fee_adjustment</code>\u00a0is a multiplier that can tune the final fee based on the network\u2019s congestion.</p> <ul> <li>The\u00a0<code>base_fee</code>\u00a0derived from the base weight covers inclusion overhead like signature verification</li> <li>The\u00a0<code>length_fee</code>\u00a0is a per-byte fee that is multiplied by the length of the encoded extrinsic</li> <li>The\u00a0<code>weight_fee</code>\u00a0fee is calculated using two parameters:</li> <li>The\u00a0<code>ExtrinsicBaseWeight</code>\u00a0that is declared in the runtime and applies to all extrinsics</li> <li>The\u00a0<code>#[pallet::weight]</code>\u00a0annotation that accounts for an extrinsic's complexity</li> </ul> <p>To convert the weight to <code>Currency</code>, the runtime must define a <code>WeightToFee</code> struct that implements a conversion function, <code>Convert&lt;Weight,Balance&gt;</code>.</p> <p>Note that the extrinsic sender is charged the inclusion fee before the extrinsic is invoked. The fee is deducted from the sender's balance even if the transaction fails upon execution.</p>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/fees/#accounts-with-an-insufficient-balance","title":"Accounts with an Insufficient Balance","text":"<p>If an account does not have a sufficient balance to pay the inclusion fee and remain alive\u2014that is, enough to pay the inclusion fee and maintain the minimum\u00a0existential deposit\u2014then you should ensure the transaction is canceled so that no fee is deducted and the transaction does not begin execution.</p> <p>The Polkadot SDK doesn't enforce this rollback behavior. However, this scenario would be rare because the transaction queue and block-making logic perform checks to prevent it before adding an extrinsic to a block.</p>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/fees/#fee-multipliers","title":"Fee Multipliers","text":"<p>The inclusion fee formula always results in the same fee for the same input. However, weight can be dynamic and\u2014based on how\u00a0<code>WeightToFee</code>\u00a0is defined\u2014the final fee can include some degree of variability. The Transaction Payment pallet provides the\u00a0<code>FeeMultiplierUpdate</code>\u00a0configurable parameter to account for this variability.</p> <p>The Polkadot network inspires the default update function and implements a targeted adjustment in which a target saturation level of block weight is defined. If the previous block is more saturated, the fees increase slightly. Similarly, if the last block has fewer transactions than the target, fees are decreased by a small amount. For more information about fee multiplier adjustments, see the\u00a0Web3 Research Page.</p>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/fees/#transactions-with-special-requirements","title":"Transactions with Special Requirements","text":"<p>Inclusion fees must be computable before execution and can only represent fixed logic. Some transactions warrant limiting resources with other strategies. For example:</p> <ul> <li>Bonds are a type of fee that might be returned or slashed after some on-chain event. For example, you might want to require users to place a bond to participate in a vote. The bond might then be returned at the end of the referendum or slashed if the voter attempted malicious behavior</li> <li>Deposits are fees that might be returned later. For example, you might require users to pay a deposit to execute an operation that uses storage. The user\u2019s deposit could be returned if a subsequent operation frees up storage</li> <li>Burn operations are used to pay for a transaction based on its internal logic. For example, a transaction might burn funds from the sender if the transaction creates new storage items to pay for the increased state size</li> <li>Limits enable you to enforce constant or configurable limits on specific operations. For example, the default Staking pallet only allows nominators to nominate 16 validators to limit the complexity of the validator election process</li> </ul> <p>It is important to note that if you query the chain for a transaction fee, it only returns the inclusion fee.</p>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/fees/#default-weight-annotations","title":"Default Weight Annotations","text":"<p>All dispatchable functions in the Polkadot SDK must specify a weight. The way of doing that is using the annotation-based system that lets you combine fixed values for database read/write weight and/or fixed values based on benchmarks. The most basic example would look like this:</p> <pre><code>#[pallet::weight(100_000)]\nfn my_dispatchable() {\n    // ...\n}\n</code></pre> <p>Note that the\u00a0<code>ExtrinsicBaseWeight</code>\u00a0is automatically added to the declared weight to account for the costs of simply including an empty extrinsic into a block.</p>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/fees/#weights-and-database-readwrite-operations","title":"Weights and Database Read/Write Operations","text":"<p>To make weight annotations independent of the deployed database backend, they are defined as a constant and then used in the annotations when expressing database accesses performed by the dispatchable:</p> <pre><code>#[pallet::weight(T::DbWeight::get().reads_writes(1, 2) + 20_000)]\nfn my_dispatchable() {\n    // ...\n}\n</code></pre> <p>This dispatchable allows one database to read and two to write, in addition to other things that add the additional 20,000. Database access is generally every time a value declared inside the\u00a0<code>#[pallet::storage]</code>\u00a0block is accessed. However, unique accesses are counted because after a value is accessed, it is cached, and reaccessing it does not result in a database operation. That is:</p> <ul> <li>Multiple reads of the exact value count as one read</li> <li>Multiple writes of the exact value count as one write</li> <li>Multiple reads of the same value, followed by a write to that value, count as one read and one write</li> <li>A write followed by a read-only counts as one write</li> </ul>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/fees/#dispatch-classes","title":"Dispatch Classes","text":"<p>Dispatches are broken into three classes:</p> <ul> <li>Normal</li> <li>Operational</li> <li>Mandatory</li> </ul> <p>If a dispatch is not defined as\u00a0<code>Operational</code>\u00a0or\u00a0<code>Mandatory</code>\u00a0in the weight annotation, the dispatch is identified as\u00a0<code>Normal</code>\u00a0by default. You can specify that the dispatchable uses another class like this:</p> <pre><code>#[pallet::dispatch((DispatchClass::Operational))]\nfn my_dispatchable() {\n    // ...\n}\n</code></pre> <p>This tuple notation also allows you to specify a final argument determining whether the user is charged based on the annotated weight. If you don't specify otherwise,\u00a0<code>Pays::Yes</code>\u00a0is assumed:</p> <pre><code>#[pallet::dispatch(DispatchClass::Normal, Pays::No)]\nfn my_dispatchable() {\n    // ...\n}\n</code></pre>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/fees/#normal-dispatches","title":"Normal Dispatches","text":"<p>Dispatches in this class represent normal user-triggered transactions. These types of dispatches only consume a portion of a block's total weight limit. For information about the maximum portion of a block that can be consumed for normal dispatches, see\u00a0<code>AvailableBlockRatio</code>. Normal dispatches are sent to the\u00a0transaction pool.</p>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/fees/#operational-dispatches","title":"Operational Dispatches","text":"<p>Unlike normal dispatches, which represent\u00a0the usage\u00a0of network capabilities, operational dispatches are those that\u00a0provide\u00a0network capabilities. Operational dispatches can consume the entire weight limit of a block. They are not bound by the\u00a0<code>AvailableBlockRatio</code>. Dispatches in this class are given maximum priority and are exempt from paying the\u00a0<code>length_fee</code>.</p>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/fees/#mandatory-dispatches","title":"Mandatory Dispatches","text":"<p>Mandatory dispatches are included in a block even if they cause the block to surpass its weight limit. You can only use the mandatory dispatch class for\u00a0inherent transactions\u00a0that the block author submits. This dispatch class is intended to represent functions in the block validation process. Because these dispatches are always included in a block regardless of the function weight, the validation process must prevent malicious nodes from abusing the function to craft valid but impossibly heavy blocks. You can typically accomplish this by ensuring that:</p> <ul> <li>The operation performed is always light</li> <li>The operation can only be included in a block once</li> </ul> <p>To make it more difficult for malicious nodes to abuse mandatory dispatches, they cannot be included in blocks that return errors. This dispatch class serves the assumption that it is better to allow an overweight block to be created than not to allow any block to be created at all.</p>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/fees/#dynamic-weights","title":"Dynamic Weights","text":"<p>In addition to purely fixed weights and constants, the weight calculation can consider the input arguments of a dispatchable. The weight should be trivially computable from the input arguments with some basic arithmetic:</p> <pre><code>use frame_support:: {\n    dispatch:: {\n        DispatchClass::Normal,\n        Pays::Yes,\n    },\n   weights::Weight,\n};\n\n#[pallet::weight(FunctionOf(\n  |args: (&amp;Vec&lt;User&gt;,)| args.0.len().saturating_mul(10_000),\n  )\n]\nfn handle_users(origin, calls: Vec&lt;User&gt;) {\n    // Do something per user\n}\n</code></pre>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/fees/#post-dispatch-weight-correction","title":"Post Dispatch Weight Correction","text":"<p>Depending on the execution logic, a dispatchable function might consume less weight than was prescribed pre-dispatch. To correct weight, the function declares a different return type and returns its actual weight:</p> <pre><code>#[pallet::weight(10_000 + 500_000_000)]\nfn expensive_or_cheap(input: u64) -&gt; DispatchResultWithPostInfo {\n    let was_heavy = do_calculation(input);\n\n    if (was_heavy) {\n        // None means \"no correction\" from the weight annotation.\n        Ok(None.into())\n    } else {\n        // Return the actual weight consumed.\n        Ok(Some(10_000).into())\n    }\n}\n</code></pre>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/fees/#custom-fees","title":"Custom Fees","text":"<p>You can also define custom fee systems through custom weight functions or inclusion fee functions.</p>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/fees/#custom-weights","title":"Custom Weights","text":"<p>Instead of using the default weight annotations, you can create a custom weight calculation type using the\u00a0weights\u00a0module. The custom weight calculation type must implement the following traits:</p> <ul> <li><code>WeighData&lt;T&gt;</code>\u00a0to determine the weight of the dispatch</li> <li><code>ClassifyDispatch&lt;T&gt;</code>\u00a0to determine the class of the dispatch</li> <li><code>PaysFee&lt;T&gt;</code>\u00a0to determine whether the sender of the dispatch pays fees</li> </ul> <p>The Polkadot SDK then bundles the output information of the three traits into the\u00a0<code>DispatchInfo</code> struct and provides it by implementing the\u00a0<code>GetDispatchInfo</code>\u00a0for all\u00a0<code>Call</code>\u00a0variants and opaque extrinsic types. This is used internally by the System and Executive modules.</p> <p><code>ClassifyDispatch</code>,\u00a0<code>WeighData</code>, and\u00a0<code>PaysFee</code>\u00a0are generic over\u00a0T, which gets resolved into the tuple of all dispatch arguments except for the origin. The following example illustrates a\u00a0struct\u00a0that calculates the weight as\u00a0<code>m * len(args)</code>,\u00a0where\u00a0<code>m</code>\u00a0is a given multiplier and\u00a0args\u00a0is the concatenated tuple of all dispatch arguments. In this example, the dispatch class is\u00a0<code>Operational</code>\u00a0if the transaction has more than 100 bytes of length in arguments and will pay fees if the encoded length exceeds 10 bytes.</p> <pre><code>struct LenWeight(u32);\nimpl&lt;T&gt; WeighData&lt;T&gt; for LenWeight {\n    fn weigh_data(&amp;self, target: T) -&gt; Weight {\n        let multiplier = self.0;\n        let encoded_len = target.encode().len() as u32;\n        multiplier * encoded_len\n    }\n}\n\nimpl&lt;T&gt; ClassifyDispatch&lt;T&gt; for LenWeight {\n    fn classify_dispatch(&amp;self, target: T) -&gt; DispatchClass {\n        let encoded_len = target.encode().len() as u32;\n        if encoded_len &gt; 100 {\n            DispatchClass::Operational\n        } else {\n            DispatchClass::Normal\n        }\n    }\n}\n\nimpl&lt;T&gt; PaysFee&lt;T&gt; {\n    fn pays_fee(&amp;self, target: T) -&gt; Pays {\n        let encoded_len = target.encode().len() as u32;\n        if encoded_len &gt; 10 {\n            Pays::Yes\n        } else {\n            Pays::No\n        }\n    }\n}\n</code></pre> <p>A weight calculator function can also be coerced to the final type of the argument instead of defining it as a vague type that can be encoded. The code would roughly look like this:</p> <pre><code>struct CustomWeight;\nimpl WeighData&lt;(&amp;u32, &amp;u64)&gt; for CustomWeight {\n    fn weigh_data(&amp;self, target: (&amp;u32, &amp;u64)) -&gt; Weight {\n        ...\n    }\n}\n\n// given a dispatch:\n#[pallet::call]\nimpl&lt;T: Config&lt;I&gt;, I: 'static&gt; Pallet&lt;T, I&gt; {\n    #[pallet::weight(CustomWeight)]\n    fn foo(a: u32, b: u64) { ... }\n}\n</code></pre> <p>In this example, the <code>CustomWeight</code> can only be used in conjunction with a dispatch with a particular signature <code>(u32, u64)</code>, as opposed to <code>LenWeight</code>, which can be used with anything because there aren't any assumptions about <code>&lt;T&gt;</code>.</p>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/fees/#custom-inclusion-fee","title":"Custom Inclusion Fee","text":"<p>The following example illustrates how to customize your inclusion fee. You must configure the appropriate associated types in the respective module.</p> <pre><code>// Assume this is the balance type\ntype Balance = u64;\n\n// Assume we want all the weights to have a `100 + 2 * w` conversion to fees\nstruct CustomWeightToFee;\nimpl WeightToFee&lt;Weight, Balance&gt; for CustomWeightToFee {\n    fn convert(w: Weight) -&gt; Balance {\n        let a = Balance::from(100);\n        let b = Balance::from(2);\n        let w = Balance::from(w);\n        a + b * w\n    }\n}\n\nparameter_types! {\n    pub const ExtrinsicBaseWeight: Weight = 10_000_000;\n}\n\nimpl frame_system::Config for Runtime {\n    type ExtrinsicBaseWeight = ExtrinsicBaseWeight;\n}\n\nparameter_types! {\n    pub const TransactionByteFee: Balance = 10;\n}\n\nimpl transaction_payment::Config {\n    type TransactionByteFee = TransactionByteFee;\n    type WeightToFee = CustomWeightToFee;\n    type FeeMultiplierUpdate = TargetedFeeAdjustment&lt;TargetBlockFullness&gt;;\n}\n\nstruct TargetedFeeAdjustment&lt;T&gt;(sp_std::marker::PhantomData&lt;T&gt;);\nimpl&lt;T: Get&lt;Perquintill&gt;&gt; WeightToFee&lt;Fixed128, Fixed128&gt; for TargetedFeeAdjustment&lt;T&gt; {\n    fn convert(multiplier: Fixed128) -&gt; Fixed128 {\n        // Don't change anything. Put any fee update info here.\n        multiplier\n    }\n}\n</code></pre>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/fees/#further-resources","title":"Further Resources","text":"<p>You now know the weight system, how it affects transaction fee computation, and how to specify weights for your dispatchable calls. The next step is determining the correct weight for your dispatchable operations. You can use Substrate\u00a0benchmarking functions\u00a0and\u00a0frame-benchmarking\u00a0calls to test your functions with different parameters and empirically determine the proper weight in their worst-case scenarios.</p> <ul> <li>Benchmark</li> <li><code>SignedExtension</code></li> <li>Custom weights for the Example pallet</li> <li>Web3 Foundation Research</li> </ul>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/transactions/","title":"Transactions","text":""},{"location":"polkadot-protocol/basics/blocks-transactions-fees/transactions/#introduction","title":"Introduction","text":"<p>Transactions are essential components of blockchain networks, enabling state changes and the execution of key operations. In the Polkadot SDK, transactions, often called extrinsics, come in multiple forms, including signed, unsigned, and inherent transactions.</p> <p>This guide walks you through the different transaction types and how they're formatted, validated, and processed within the Polkadot ecosystem. You'll also learn how to customize transaction formats and construct transactions for FRAME-based runtimes, ensuring a complete understanding of how transactions are built and executed in Polkadot SDK-based chains.</p>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/transactions/#what-is-a-transaction","title":"What Is a Transaction?","text":"<p>In the Polkadot SDK, transactions represent operations that modify the chain's state, bundled into blocks for execution. The term extrinsic is often used to refer to any data that originates outside the runtime and is included in the chain. While other blockchain systems typically refer to these operations as \"transactions,\" the Polkadot SDK adopts the broader term \"extrinsic\" to capture the wide variety of data types that can be added to a block.</p> <p>There are three primary types of transactions (extrinsics) in the Polkadot SDK:</p> <ul> <li>Signed transactions - signed by the submitting account, often carrying transaction fees</li> <li>Unsigned transactions - submitted without a signature, often requiring custom validation logic</li> <li>Inherent transactions - typically inserted directly into blocks by block authoring nodes, without gossiping between peers</li> </ul> <p>Each type serves a distinct purpose, and understanding when and how to use each is key to efficiently working with the Polkadot SDK.</p>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/transactions/#signed-transactions","title":"Signed Transactions","text":"<p>Signed transactions require an account's signature and typically involve submitting a request to execute a runtime call. The signature serves as a form of cryptographic proof that the sender has authorized the action, using their private key. These transactions often involve a transaction fee to cover the cost of execution and incentivize block producers.</p> <p>Signed transactions are the most common type of transaction and are integral to user-driven actions, such as token transfers. For instance, when you transfer tokens from one account to another, the sending account must sign the transaction to authorize the operation.</p> <p>For example, the <code>pallet_balances::Call::transfer_allow_death</code> extrinsic in the Balances pallet allows you to transfer tokens. Since your account initiates this transaction, your account key is used to sign it. You'll also be responsible for paying the associated transaction fee, with the option to include an additional tip to incentivize faster inclusion in the block.</p>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/transactions/#unsigned-transactions","title":"Unsigned Transactions","text":"<p>Unsigned transactions do not require a signature or account-specific data from the sender. Unlike signed transactions, they do not come with any form of economic deterrent, such as fees, which makes them susceptible to spam or replay attacks. Custom validation logic must be implemented to mitigate these risks and ensure these transactions are secure.</p> <p>Unsigned transactions typically involve scenarios where including a fee or signature is unnecessary or counterproductive. However, due to the absence of fees, they require careful validation to protect the network. For example, <code>pallet_im_online::Call::heartbeat</code> extrinsic allows validators to send a heartbeat signal, indicating they are active. Since only validators can make this call, the logic embedded in the transaction ensures that the sender is a validator, making the need for a signature or fee redundant.</p> <p>Unsigned transactions are more resource-intensive than signed ones because custom validation is required, but they play a crucial role in certain operational scenarios, especially when regular user accounts aren't involved.</p>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/transactions/#inherent-transactions","title":"Inherent Transactions","text":"<p>Inherent transactions are a specialized type of unsigned transaction that is used primarily for block authoring. Unlike signed or other unsigned transactions, inherent transactions are added directly by block producers and are not broadcasted to the network or stored in the transaction queue. They don't require signatures or the usual validation steps and are generally used to insert system-critical data directly into blocks.</p> <p>A key example of an inherent transaction is inserting a timestamp into each block. The <code>pallet_timestamp::Call::now</code> extrinsic allows block authors to include the current time in the block they are producing. Since the block producer adds this information, there is no need for transaction validation, like signature verification. The validation in this case is done indirectly by the validators, who check whether the timestamp is within an acceptable range before finalizing the block.</p> <p>Another example is the <code>paras_inherent::Call::enter</code> extrinsic, which enables parachain collator nodes to send validation data to the relay chain. This inherent transaction ensures that the necessary parachain data is included in each block without the overhead of gossiped transactions.</p> <p>Inherent transactions serve a critical role in block authoring by allowing important operational data to be added directly to the chain without needing the validation processes required for standard transactions.</p>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/transactions/#transaction-formats","title":"Transaction Formats","text":"<p>Understanding the structure of signed and unsigned transactions is crucial for developers building on Polkadot SDK-based chains. Whether you're optimizing transaction processing, customizing formats, or interacting with the transaction pool, knowing the format of extrinsics, Polkadot's term for transactions, is essential.</p>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/transactions/#types-of-transaction-formats","title":"Types of Transaction Formats","text":"<p>In Polkadot SDK-based chains, extrinsics can fall into three main categories:</p> <ul> <li>Unchecked extrinsics - typically used for signed transactions that require validation. They contain a signature and additional data, such as a nonce and information for fee calculation. Unchecked extrinsics are named as such because they require validation checks before being accepted into the transaction pool</li> <li>Checked extrinsics - typically used for inherent extrinsics (unsigned transactions); these don't require signature verification. Instead, they carry information such as where the extrinsic originates and any additional data required for the block authoring process</li> <li>Opaque extrinsics - used when the format of an extrinsic is not yet fully committed or finalized. They are still decodable, but their structure can be flexible depending on the context</li> </ul>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/transactions/#signed-transaction-data-structure","title":"Signed Transaction Data Structure","text":"<p>A signed transaction typically includes the following components:</p> <ul> <li>Signature - verifies the authenticity of the transaction sender</li> <li>Call - the actual function or method call the transaction is requesting (for example, transferring funds)</li> <li>Nonce - tracks the number of prior transactions sent from the account, helping to prevent replay attacks</li> <li>Tip - an optional incentive to prioritize the transaction in block inclusion</li> <li>Additional data - includes details such as spec version, block hash, and genesis hash to ensure the transaction is valid within the correct runtime and chain context</li> </ul> <p>Here's a simplified breakdown of how signed transactions are typically constructed in a Polkadot SDK runtime:</p> <pre><code>&lt;signing account ID&gt; + &lt;signature&gt; + &lt;additional data&gt;\n</code></pre> <p>Each part of the signed transaction has a purpose, ensuring the transaction's authenticity and context within the blockchain.</p>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/transactions/#signed-extensions","title":"Signed Extensions","text":"<p>Polkadot SDK also provides the concept of signed extensions, which allow developers to extend extrinsics with additional data or validation logic before they are included in a block. The <code>SignedExtension</code> set helps enforce custom rules or protections, such as ensuring the transaction's validity or calculating priority.</p> <p>The transaction queue regularly calls signed extensions to verify a transaction's validity before placing it in the ready queue. This safeguard ensures transactions won't fail in a block. Signed extensions are commonly used to enforce validation logic and protect the transaction pool from spam and replay attacks.</p> <p>In FRAME, a signed extension can hold any of the following types by default:</p> <ul> <li><code>AccountId</code> - to encode the sender's identity</li> <li><code>Call</code> - to encode the pallet call to be dispatched. This data is used to calculate transaction fees</li> <li><code>AdditionalSigned</code> - to handle any additional data to go into the signed payload allowing you to attach any custom logic prior to dispatching a transaction</li> <li><code>Pre</code> - to encode the information that can be passed from before a call is dispatched to after it gets dispatched</li> </ul> <p>Signed extensions can enforce checks like:</p> <ul> <li><code>CheckSpecVersion</code> - ensures the transaction is compatible with the runtime's current version</li> <li><code>CheckWeight</code> - calculates the weight (or computational cost) of the transaction, ensuring the block doesn't exceed the maximum allowed weight</li> </ul> <p>These extensions are critical in the transaction lifecycle, ensuring that only valid and prioritized transactions are processed.</p>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/transactions/#transaction-construction","title":"Transaction Construction","text":"<p>Building transactions in the Polkadot SDK involves constructing a payload that can be verified, signed, and submitted for inclusion in a block. Each runtime in the Polkadot SDK has its own rules for validating and executing transactions, but there are common patterns for constructing a signed transaction.</p>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/transactions/#construct-a-signed-transaction","title":"Construct a Signed Transaction","text":"<p>A signed transaction in the Polkadot SDK includes various pieces of data to ensure security, prevent replay attacks, and prioritize processing. Here's an overview of how to construct one:</p> <ol> <li>Construct the unsigned payload - gather the necessary information for the call, including:<ul> <li>Pallet index - identifies the pallet where the runtime function resides</li> <li>Function index - specifies the particular function to call in the pallet</li> <li>Parameters - any additional arguments required by the function call</li> </ul> </li> <li>Create a signing payload - once the unsigned payload is ready, additional data must be included:<ul> <li>Transaction nonce - unique identifier to prevent replay attacks</li> <li>Era information - defines how long the transaction is valid before it's dropped from the pool</li> <li>Block hash - ensures the transaction doesn't execute on the wrong chain or fork</li> </ul> </li> <li>Sign the payload - using the sender's private key, sign the payload to ensure that the transaction can only be executed by the account holder</li> <li>Serialize the signed payload - once signed, the transaction must be serialized into a binary format, ensuring the data is compact and easy to transmit over the network</li> <li>Submit the serialized transaction - finally, submit the serialized transaction to the network, where it will enter the transaction pool and wait for processing by an authoring node</li> </ol> <p>The following is an example of how a signed transaction might look:</p> <pre><code>node_runtime::UncheckedExtrinsic::new_signed(\n    function.clone(),                                      // some call\n    sp_runtime::AccountId32::from(sender.public()).into(), // some sending account\n    node_runtime::Signature::Sr25519(signature.clone()),   // the account's signature\n    extra.clone(),                                         // the signed extensions\n)\n</code></pre>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/transactions/#transaction-encoding","title":"Transaction Encoding","text":"<p>Before a transaction is sent to the network, it is serialized and encoded using a structured encoding process that ensures consistency and prevents tampering:</p> <ul> <li><code>[1]</code> - compact encoded length in bytes of the entire transaction</li> <li><code>[2]</code> - a\u00a0u8\u00a0containing 1 byte to indicate whether the transaction is signed or unsigned (1 bit) and the encoded transaction version ID (7 bits)</li> <li><code>[3]</code> - if signed, this field contains an account ID, an SR25519 signature, and some extra data</li> <li><code>[4]</code> - encoded call data, including pallet and function indices and any required arguments</li> </ul> <p>This encoded format ensures consistency and efficiency in processing transactions across the network. By adhering to this format, applications can construct valid transactions and pass them to the network for execution.</p> Additional Information <p>Learn how compact encoding works using\u00a0SCALE.</p>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/transactions/#customize-transaction-construction","title":"Customize Transaction Construction","text":"<p>Although the basic steps for constructing transactions are consistent across Polkadot SDK-based chains, developers can customize transaction formats and validation rules. For example:</p> <ul> <li>Custom pallets - you can define new pallets with custom function calls, each with its own parameters and validation logic</li> <li>Signed extensions - developers can implement custom extensions that modify how transactions are prioritized, validated, or included in blocks</li> </ul> <p>By leveraging Polkadot SDK's modular design, developers can create highly specialized transaction logic tailored to their chain's needs.</p>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/transactions/#lifecycle-of-a-transaction","title":"Lifecycle of a Transaction","text":"<p>In the Polkadot SDK, transactions are often referred to as extrinsics because the data in transactions originates outside of the runtime. These transactions contain data that initiates changes to the chain state. The most common type of extrinsic is a signed transaction, which is cryptographically verified and typically incurs a fee. This section focuses on how signed transactions are processed, validated, and ultimately included in a block.</p>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/transactions/#define-transaction-properties","title":"Define Transaction Properties","text":"<p>The Polkadot SDK runtime defines key transaction properties, such as:</p> <ul> <li>Transaction validity - ensures the transaction meets all runtime requirements</li> <li>Signed or unsigned - identifies whether a transaction needs to be signed by an account</li> <li>State changes - determines how the transaction modifies the state of the chain</li> </ul> <p>Pallets, which compose the runtime's logic, define the specific transactions that your chain supports. When a user submits a transaction, such as a token transfer, it becomes a signed transaction, verified by the user's account signature. If the account has enough funds to cover fees, the transaction is executed, and the chain's state is updated accordingly.</p>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/transactions/#process-on-a-block-authoring-node","title":"Process on a Block Authoring Node","text":"<p>In Polkadot SDK-based networks, some nodes are authorized to author blocks. These nodes validate and process transactions. When a transaction is sent to a node that can produce blocks, it undergoes a lifecycle that involves several stages, including validation and execution. Non-authoring nodes gossip the transaction across the network until an authoring node receives it. The following diagram illustrates the lifecycle of a transaction that's submitted to a network and processed by an authoring node.</p> <p></p>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/transactions/#validate-and-queue","title":"Validate and Queue","text":"<p>Once a transaction reaches an authoring node, it undergoes an initial validation process to ensure it meets specific conditions defined in the runtime. This validation includes checks for:</p> <ul> <li>Correct nonce - ensures the transaction is sequentially valid for the account</li> <li>Sufficient funds - confirms the account can cover any associated transaction fees</li> <li>Signature validity - verifies that the sender's signature matches the transaction data</li> </ul> <p>After these checks, valid transactions are placed in the transaction pool, where they are queued for inclusion in a block. The transaction pool regularly re-validates queued transactions to ensure they remain valid before being processed. To reach consensus, two-thirds of the nodes must agree on the order of the transactions executed and the resulting state change. Transactions are validated and queued on the local node in a transaction pool to prepare for consensus.</p>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/transactions/#transaction-pool","title":"Transaction Pool","text":"<p>The transaction pool is responsible for managing valid transactions. It ensures that only transactions that pass initial validity checks are queued. Transactions that fail validation, expire, or become invalid for other reasons are removed from the pool.</p> <p>The transaction pool organizes transactions into two queues:</p> <ul> <li>Ready queue - transactions that are valid and ready to be included in a block</li> <li>Future queue - transactions that are not yet valid but could be in the future, such as transactions with a nonce too high for the current state</li> </ul> <p>Details on how the transaction pool validates transactions, including fee and signature handling, can be found in the <code>validate_transaction</code> method.</p>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/transactions/#invalid-transactions","title":"Invalid Transactions","text":"<p>If a transaction is invalid, for example, due to an invalid signature or insufficient funds, it is rejected and won't be added to the block. Invalid transactions might be rejected for reasons such as:</p> <ul> <li>The transaction has already been included in a block</li> <li>The transaction's signature does not match the sender</li> <li>The transaction is too large to fit in the current block</li> </ul>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/transactions/#transaction-ordering-and-priority","title":"Transaction Ordering and Priority","text":"<p>When a node is selected as the next block author, it prioritizes transactions based on weight, length, and tip amount. The goal is to fill the block with high-priority transactions without exceeding its maximum size or computational limits. Transactions are ordered as follows:</p> <ul> <li>Inherents first - inherent transactions, such as block timestamp updates, are always placed first</li> <li>Nonce-based ordering - transactions from the same account are ordered by their nonce</li> <li>Fee-based ordering - among transactions with the same nonce or priority level, those with higher fees are prioritized</li> </ul>"},{"location":"polkadot-protocol/basics/blocks-transactions-fees/transactions/#transaction-execution","title":"Transaction Execution","text":"<p>Once a block author selects transactions from the pool, the transactions are executed in priority order. As each transaction is processed, the state changes are written directly to the chain's storage. It's important to note that these changes are not cached, meaning a failed transaction won't revert earlier state changes, which could leave the block in an inconsistent state.</p> <p>Events are also written to storage. Runtime logic should not emit an event before performing the associated actions. If the associated transaction fails after the event was emitted, the event will not revert.</p> Additional Information <p>Watch Seminar: Lifecycle of a transaction for a video overview of the lifecycle of transactions and the types of transactions that exist.</p>"},{"location":"polkadot-protocol/onchain-governance/","title":"On-Chain Governance","text":"<p>Explore Polkadot's decentralized on-chain governance system, OpenGov, including how it works, the proposal process, and key info for developers.</p>"},{"location":"polkadot-protocol/onchain-governance/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"polkadot-protocol/onchain-governance/#start-building-governance-solutions","title":"Start Building Governance SolutionsExplore the Preimage PalletExplore the Referenda PalletExplore the Conviction Voting Pallet","text":"<p>To develop solutions related to Polkadot's governance system, it\u2019s essential to understand three key pallets:</p> <ul> <li>Preimage - stores and manages the content or the detailed information of a referendum proposal before it is voted on</li> <li>Referenda - manages the lifecycle of a referendum, including proposal submission, voting, and execution. Once a referendum is proposed and voted on, it can be enacted if it passes the required threshold</li> <li>Conviction Voting - manages the voting power based on the \"conviction\" or commitment of voters, providing a more flexible and nuanced voting mechanism</li> </ul> <p>These pallets work together to enable decentralized decision-making within the Polkadot network.</p> <p>Review Polkadot SDK's documentation on the Preimage pallet to learn more.</p> <p>Review Polkadot SDK's documentation on the Referenda pallet to learn more.</p> <p>Review Polkadot SDK's documentation on the Conviction Voting pallet to learn more.</p>"},{"location":"polkadot-protocol/onchain-governance/origins-tracks/","title":"Origins and Tracks","text":""},{"location":"polkadot-protocol/onchain-governance/origins-tracks/#introduction","title":"Introduction","text":"<p>Polkadot's OpenGov system empowers decentralized decision-making and active community participation by tailoring the governance process to the impact of proposed changes. Through a system of origins and tracks, OpenGov ensures that every referendum receives the appropriate scrutiny, balancing security, inclusivity, and efficiency.</p> <p>This guide will help you understand the role of origins in classifying proposals by privilege and priority. You will learn how tracks guide proposals through tailored stages like voting, confirmation, and enactment and how to select the correct origin for your referendum to align with community expectations and network governance.</p> <p>Origins and tracks are vital in streamlining the governance workflow and maintaining Polkadot's resilience and adaptability.</p>"},{"location":"polkadot-protocol/onchain-governance/origins-tracks/#origins","title":"Origins","text":"<p>Origins are the foundation of Polkadot's OpenGov governance system. They categorize proposals by privilege and define their decision-making rules. Each origin corresponds to a specific level of importance and risk, guiding how referendums progress through the governance process.</p> <ul> <li>High-privilege origins like Root Origin govern critical network changes, such as core software upgrades</li> <li>Lower-privilege origins like Small Spender handle minor requests, such as community project funding under 10,000 DOT</li> </ul> <p>Proposers select an origin based on the nature of their referendum. Origins determine parameters like approval thresholds, required deposits, and timeframes for voting and confirmation. Each origin is paired with a track, which acts as a roadmap for the proposal's lifecycle, including preparation, voting, and enactment.</p> <p>!!!note 'OpenGov Origins'      Explore the Polkadot OpenGov Origins page for a detailed list of origins and their associated parameters.</p>"},{"location":"polkadot-protocol/onchain-governance/origins-tracks/#tracks","title":"Tracks","text":"<p>Tracks define a referendum's journey from submission to enactment, tailoring governance parameters to the impact of proposed changes. Each track operates independently and includes several key stages:</p> <ul> <li>Preparation - time for community discussion before voting begins</li> <li>Voting - period for token holders to cast their votes</li> <li>Decision - finalization of results and determination of the proposal's outcome</li> <li>Confirmation - period to verify sustained community support before enactment</li> <li>Enactment - final waiting period before the proposal takes effect</li> </ul> <p>Tracks customize these stages with parameters like decision deposit requirements, voting durations, and approval thresholds, ensuring proposals from each origin receive the required scrutiny and process. For example, a runtime upgrade in the Root Origin track will have longer timeframes and stricter thresholds than a treasury request in the Small Spender track.</p>"},{"location":"polkadot-protocol/onchain-governance/origins-tracks/#additional-resources","title":"Additional Resources","text":"<ul> <li> <p>Visit Origins and Tracks Info for a list of origins and tracks for Polkadot and Kusama including associated parameters</p> </li> <li> <p>See Approval and Support for a deeper dive into the approval and support system</p> </li> </ul>"},{"location":"polkadot-protocol/onchain-governance/overview/","title":"On-Chain Governance","text":""},{"location":"polkadot-protocol/onchain-governance/overview/#introduction","title":"Introduction","text":"<p>Polkadot\u2019s governance system exemplifies decentralized decision-making, empowering its community of stakeholders to shape the network\u2019s future through active participation. The latest evolution, OpenGov, builds on Polkadot\u2019s foundation by providing a more inclusive and efficient governance model.</p> <p>This guide will explain the principles and structure of OpenGov and walk you through its key components, such as Origins, Tracks, and Delegation. You will learn about improvements over earlier governance systems, including streamlined voting processes and enhanced stakeholder participation.</p> <p>With OpenGov, Polkadot achieves a flexible, scalable, and democratic governance framework that allows multiple proposals to proceed simultaneously, ensuring the network evolves in alignment with its community's needs.</p>"},{"location":"polkadot-protocol/onchain-governance/overview/#governance-evolution","title":"Governance Evolution","text":"<p>Polkadot\u2019s governance journey began with Governance V1, a system that proved effective in managing treasury funds and protocol upgrades. However, it faced limitations, such as:</p> <ul> <li>Slow voting cycles, causing delays in decision-making</li> <li>Inflexibility in handling multiple referendums, restricting scalability</li> </ul> <p>To address these challenges, Polkadot introduced OpenGov, a governance model designed for greater inclusivity, efficiency, and scalability. OpenGov replaces the centralized structures of Governance V1, such as the Council and Technical Committee, with a fully decentralized and dynamic framework.</p> <p>For a full comparison of the historic and current governance models, visit the Gov1 vs. Polkadot OpenGov section of the Polkadot Wiki.</p>"},{"location":"polkadot-protocol/onchain-governance/overview/#opengov-key-features","title":"OpenGov Key Features","text":"<p>OpenGov transforms Polkadot\u2019s governance into a decentralized, stakeholder-driven model, eliminating centralized decision-making bodies like the Council. Key enhancements include:</p> <ul> <li>Decentralization - shifts all decision-making power to the public, ensuring a more democratic process</li> <li>Enhanced delegation - allows users to delegate their votes to trusted experts across specific governance tracks</li> <li>Simultaneous referendums - multiple proposals can progress at once, enabling faster decision-making</li> <li>Polkadot Technical Fellowship - a broad, community-driven group replacing the centralized Technical Committee</li> </ul> <p>This new system ensures Polkadot governance remains agile and inclusive, even as the ecosystem grows.</p>"},{"location":"polkadot-protocol/onchain-governance/overview/#origins-and-tracks","title":"Origins and Tracks","text":"<p>In OpenGov, origins and tracks are central to managing proposals and votes.</p> <ul> <li>Origin - determines the authority level of a proposal (e.g., Treasury, Root) which decides the track of all referendums from that origin</li> <li>Track - define the procedural flow of a proposal, such as voting duration, approval thresholds, and enactment timelines</li> </ul> <p>Developers must be aware that referendums from different origins and tracks will take varying amounts of time to reach approval and enactment. The Polkadot Technical Fellowship has the option to shorten this timeline by whitelisting a proposal and allowing it to be enacted through the Whitelist Caller origin.</p> <p>Visit Origins and Tracks Info for details on current origins and tracks, associated terminology, and parameters.</p>"},{"location":"polkadot-protocol/onchain-governance/overview/#referendums","title":"Referendums","text":"<p>In OpenGov, anyone can submit a referendum, fostering an open and participatory system. The timeline for a referendum depends on the privilege level of the origin with more significant changes offering more time for community voting and participation before enactment. </p> <p>The timeline for an individual referendum includes four distinct periods:</p> <ul> <li>Lead-in - a minimum amount of time to allow for community participation, available room in the origin, and payment of the decision deposit. Voting is open during this period</li> <li>Decision - voting continues</li> <li>Confirmation - referendum must meet approval and support criteria during entire period to avoid rejection</li> <li>Enactment - changes approved by the referendum are executed</li> </ul>"},{"location":"polkadot-protocol/onchain-governance/overview/#vote-on-referendums","title":"Vote on Referendums","text":"<p>Voters can vote with their tokens on each referendum. Polkadot uses a voluntary token locking mechanism, called conviction voting, as a way for voters to increase their voting power. A token holder signals they have a stronger preference for approving a proposal based upon their willingness to lock up tokens. Longer voluntary token locks are seen as a signal of continual approval and translate to increased voting weight.</p> <p>See Voting on a Referendum for a deeper look at conviction voting and related token locks.</p>"},{"location":"polkadot-protocol/onchain-governance/overview/#delegate-voting-power","title":"Delegate Voting Power","text":"<p>The OpenGov system also supports multi-role delegations, allowing token holders to assign their voting power on different tracks to entities with expertise in those areas. </p> <p>For example, if a token holder lacks the technical knowledge to evaluate proposals on the Root track, they can delegate their voting power for that track to an expert they trust to vote in the best interest of the network. This ensures informed decision-making across tracks while maintaining flexibility for token holders.</p> <p>Visit Multirole Delegation for more details on delegating voting power.</p>"},{"location":"polkadot-protocol/onchain-governance/overview/#cancel-a-referendum","title":"Cancel a Referendum","text":"<p>Polkadot OpenGov has two origins for rejecting ongoing referendums: </p> <ul> <li>Referendum Canceller - cancels an active referendum when non-malicious errors occur and refunds the deposits to the originators</li> <li>Referendum Killer - used for urgent, malicious cases this origin instantly terminates an active referendum and slashes deposits</li> </ul> <p>See Cancelling, Killing, and Blacklisting for additional information on rejecting referendums.</p>"},{"location":"polkadot-protocol/onchain-governance/overview/#additional-resources","title":"Additional Resources","text":"<ul> <li>Democracy pallet - handles administration of general stakeholder voting</li> <li>Gov2: Polkadot\u2019s Next Generation of Decentralised Governance - Medium article by Gavin Wood</li> <li>Polkadot Direction -  Matrix Element client</li> <li>Polkassembly - OpenGov dashboard and UI</li> <li>Polkadot.js Apps Governance - overview of active referendums</li> </ul>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Explore step-by-step tutorials for building in Polkadot, from parachain deployment and testing to cross-chain asset creation and XCM channel management.</p>"},{"location":"tutorials/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"tutorials/interoperability/","title":"Interoperability Tutorials","text":"<p>Explore tutorials on interoperability for Polkadot SDK-based blockchains, covering cross-chain communication and integration techniques.</p>"},{"location":"tutorials/interoperability/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"tutorials/interoperability/xcm-channels/","title":"Tutorials for Managing XCM Channels","text":"<p>Learn how to establish unidirectional and bidirectional HRMP channels between parachains and system parachains using XCM messages to enable interoperability.</p>"},{"location":"tutorials/interoperability/xcm-channels/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"tutorials/interoperability/xcm-channels/para-to-para/","title":"Opening HRMP Channels Between Parachains","text":""},{"location":"tutorials/interoperability/xcm-channels/para-to-para/#introduction","title":"Introduction","text":"<p>For establishing communication channels between parachains on the Polkadot network using the Horizontal Relay-routed Message Passing (HRMP) protocol, the following steps are required:</p> <ol> <li>Channel request - the parachain that wants to open an HRMP channel must make a request to the parachain it wishes to have an open channel with</li> <li>Channel acceptance - the other parachain must then accept this request to complete the channel establishment</li> </ol> <p>This process results in a unidirectional HRMP channel, where messages can flow in only one direction between the two parachains.</p> <p>An additional HRMP channel must be established in the opposite direction to enable bidirectional communication. This requires repeating the request and acceptance process but with the parachains reversing their roles.</p> <p>Once both unidirectional channels are established, the parachains can send messages back and forth freely through the bidirectional HRMP communication channel.</p>"},{"location":"tutorials/interoperability/xcm-channels/para-to-para/#prerequisites","title":"Prerequisites","text":"<p>Before proceeding, ensure you meet the following requirements:</p> <ul> <li>Blockchain network with a relay chain and at least two connected parachains</li> <li>Wallet with sufficient funds to execute transactions on the participant chains</li> </ul>"},{"location":"tutorials/interoperability/xcm-channels/para-to-para/#procedure-for-initiating-hrmp-channel-setup","title":"Procedure for Initiating HRMP Channel Setup","text":"<p>This example will demonstrate how to open a channel between parachain 2500 and parachain 2600, using Rococo Local as the relay chain.</p>"},{"location":"tutorials/interoperability/xcm-channels/para-to-para/#fund-sender-sovereign-account","title":"Fund Sender Sovereign Account","text":"<p>The sovereign account for parachain 2500 on the relay chain must be funded so it can take care of any XCM transact fees.</p> <p>Use Polkadot.js Apps UI to connect to the relay chain and transfer funds from your account to the parachain 2500 sovereign account. </p> Calculating Parachain Sovereign Account <p>To generate the sovereign account address for a parachain, you'll need to follow these steps:</p> <ol> <li> <p>Determine if the parachain is an \"up/down\" chain (parent or child) or a \"sibling\" chain:</p> <ul> <li> <p>Up/down chains use the prefix <code>0x70617261</code> (which decodes to <code>b\"para\"</code>)</p> </li> <li> <p>Sibling chains use the prefix <code>0x7369626c</code> (which decodes to <code>b\"sibl\"</code>)</p> </li> </ul> </li> <li> <p>Calculate the u32 scale encoded value of the parachain ID:</p> <ul> <li>Parachain 2500 would be encoded as <code>c4090000</code></li> </ul> </li> <li> <p>Combine the prefix and parachain ID encoding to form the full sovereign account address:</p> <p>The sovereign account of parachain 2500 in relay chain will be <code>0x70617261c4090000000000000000000000000000000000000000000000000000</code> and the SS58 format of this address is <code>5Ec4AhPSY2GEE4VoHUVheqv5wwq2C1HMKa7c9fVJ1WKivX1Y</code></p> </li> </ol> <p>To perform this conversion, you can also use the \"Para ID\" to Address section in Substrate Utilities.</p>"},{"location":"tutorials/interoperability/xcm-channels/para-to-para/#create-channel-opening-extrinsic","title":"Create Channel Opening Extrinsic","text":"<ol> <li> <p>In Polkadot.js Apps, connect to the relay chain, navigate to the Developer dropdown and select the Extrinsics option</p> <p></p> </li> <li> <p>Construct an <code>hrmpInitOpenChannel</code> extrinsic call</p> <ol> <li>Select the <code>hrmp</code> pallet</li> <li>Choose the <code>hrmpInitOpenChannel</code> extrinsic</li> <li>Fill in the parameters<ul> <li><code>recipient</code> - parachain ID of the target chain (in this case, 2600)</li> <li><code>proposedMaxCapacity</code> - max number of messages that can be pending in the channel at once</li> <li><code>proposedMaxMessageSize</code> - max message size that could be put into the channel</li> </ul> </li> <li>Copy the encoded call data  The encoded call data for opening a channel with parachain 2600 is <code>0x3c00280a00000800000000001000</code>.</li> </ol> </li> </ol>"},{"location":"tutorials/interoperability/xcm-channels/para-to-para/#crafting-and-submitting-the-xcm-message-from-the-sender","title":"Crafting and Submitting the XCM Message from the Sender","text":"<p>To initiate the HRMP channel opening process, you need to create an XCM message that includes the encoded <code>hrmpInitOpenChannel</code> call data from the previous step. This message will be sent from your parachain to the relay chain.</p> <p>This example uses the <code>sudo</code> pallet to dispatch the extrinsic. Verify the XCM configuration of the parachain you're working with and ensure you're using an origin with the necessary privileges to execute the <code>polkadotXcm.send</code> extrinsic.</p> <p>The XCM message should contain the following instructions:</p> <ul> <li><code>WithdrawAsset</code> - withdraws assets from the origin's ownership and places them in the Holding Register</li> <li><code>BuyExecution</code> - pays for the execution of the current message using the assets in the Holding Register</li> <li><code>Transact</code> - execute the encoded transaction call</li> <li><code>RefundSurplus</code> - increases the Refunded Weight Register to the value of the Surplus Weight Register, attempting to reclaim any excess fees paid via BuyExecution</li> <li><code>DepositAsset</code> - subtracts assets from the Holding Register and deposits equivalent on-chain assets under the specified beneficiary's ownership</li> </ul> <p>Note</p> <p>For more detailed information about XCM's functionality, complexities, and instruction set, refer to the xcm-format documentation.</p> <p>In essence, this process withdraws funds from the parachain's sovereign account to the XCVM Holding Register, then uses these funds to purchase execution time for the XCM <code>Transact</code> instruction, executes <code>Transact</code>, refunds any unused execution time and deposits any remaining funds into a specified account.</p> <p>To send the XCM message to the relay chain, connect to parachain 2500 in Polkadot.js Apps. Fill in the required parameters as shown in the image below, ensuring that you:</p> <ol> <li>Replace the <code>call</code> field with your encoded <code>hrmpInitOpenChannel</code> call data from the previous step</li> <li>Use the correct beneficiary information</li> <li>Click the Submit Transaction button to dispatch the XCM message to the relay chain</li> </ol> <p></p> <p>Note</p> <p>The exact process and parameters for submitting this XCM message may vary depending on your specific parachain and relay chain configurations. Always refer to the most current documentation for your particular network setup.</p> <p>After submitting the XCM message to initiate the HRMP channel opening, you should verify that the request was successful. Follow these steps to check the status of your channel request:</p> <ol> <li> <p>Using Polkadot.js Apps, connect to the relay chain and navigate to the Developer dropdown, then select the Chain state option</p> <p></p> </li> <li> <p>Query the HRMP open channel requests</p> <ol> <li>Select <code>hrmp</code></li> <li>Choose the <code>hrmpOpenChannelRequests</code> call</li> <li>Click the + button to execute the query</li> <li>Check the status of all pending channel requests</li> </ol> <p></p> </li> </ol> <p>If your channel request was successful, you should see an entry for your parachain ID in the list of open channel requests. This confirms that your request has been properly registered on the relay chain and is awaiting acceptance by the target parachain.</p>"},{"location":"tutorials/interoperability/xcm-channels/para-to-para/#procedure-for-accepting-hrmp-channel","title":"Procedure for Accepting HRMP Channel","text":"<p>For the channel to be fully established, the target parachain must accept the channel request by submitting an XCM message to the relay chain.</p>"},{"location":"tutorials/interoperability/xcm-channels/para-to-para/#fund-receiver-sovereign-account","title":"Fund Receiver Sovereign Account","text":"<p>Before proceeding, ensure that the sovereign account of parachain 2600 on the relay chain is funded. This account will be responsible for covering any XCM transact fees. To fund the account, follow the same process described in the previous section, Fund Sovereign Account.</p>"},{"location":"tutorials/interoperability/xcm-channels/para-to-para/#create-channel-accepting-extrinsic","title":"Create Channel Accepting Extrinsic","text":"<ol> <li> <p>In Polkadot.js Apps, connect to the relay chain, navigate to the Developer dropdown and select the Extrinsics option</p> <p></p> </li> <li> <p>Construct an <code>hrmpAcceptOpenChannel</code> extrinsic call</p> <ol> <li>Select the <code>hrmp</code> pallet</li> <li>Choose the <code>hrmpAcceptOpenChannel</code> extrinsic</li> <li>Fill in the parameters:<ul> <li><code>sender</code> - parachain ID of the requesting chain (in this case, 2500)</li> </ul> </li> <li>Copy the encoded call data  The encoded call data for accepting a channel with parachain 2500 should be <code>0x3c01c4090000</code></li> </ol> </li> </ol>"},{"location":"tutorials/interoperability/xcm-channels/para-to-para/#crafting-and-submitting-the-xcm-message-from-the-receiver","title":"Crafting and Submitting the XCM Message from the Receiver","text":"<p>To accept the HRMP channel opening, you need to create and submit an XCM message that includes the encoded <code>hrmpAcceptOpenChannel</code> call data from the previous step. This process is similar to the one described in the previous section, Crafting and Submitting the XCM Message, with a few key differences:</p> <ul> <li>Use the encoded call data for <code>hrmpAcceptOpenChannel</code> obtained in Step 2 of this section</li> <li>In the last XCM instruction (DepositAsset), set the beneficiary to parachain 2600's sovereign account to receive any surplus funds</li> </ul> <p>To send the XCM message to the relay chain, connect to parachain 2600 in Polkadot.js Apps. Fill in the required parameters as shown in the image below, ensuring that you:</p> <ol> <li>Replace the <code>call</code> field with your encoded <code>hrmpAcceptOpenChannel</code> call data from the previous step</li> <li>Use the correct beneficiary information</li> <li>Click the Submit Transaction button to dispatch the XCM message to the relay chain</li> </ol> <p></p> <p>After submitting the XCM message to accept the HRMP channel opening, verify that the channel has been set up correctly.</p> <ol> <li> <p>Using Polkadot.js Apps, connect to the relay chain and navigate to the Developer dropdown, then select the Chain state option</p> <p></p> </li> <li> <p>Query the HRMP channels</p> <ol> <li>Select <code>hrmp</code></li> <li>Choose the <code>hrmpChannels</code> call</li> <li>Click the + button to execute the query</li> <li>Check the status of the opened channel</li> </ol> <p></p> </li> </ol> <p>If the channel has been successfully established, you should see the channel details in the query results.</p> <p>By following these steps, you will have successfully accepted the HRMP channel request and established a unidirectional channel between the two parachains. </p> <p>Note</p> <p>Remember that for full bidirectional communication, you'll need to repeat this process in the opposite direction, with parachain 2600 initiating a channel request to parachain 2500.</p>"},{"location":"tutorials/interoperability/xcm-channels/para-to-system/","title":"Opening HRMP Channels with System Parachains","text":""},{"location":"tutorials/interoperability/xcm-channels/para-to-system/#introduction","title":"Introduction","text":"<p>While establishing Horizontal Relay-routed Message Passing (HRMP) channels between regular parachains involves a two-step request and acceptance procedure, opening channels with system parachains follows a more straightforward approach.</p> <p>System parachains are specialized chains that provide core functionality to the Polkadot network. Examples include Asset Hub for cross-chain asset transfers and Bridge Hub for connecting to external networks. Given their critical role, establishing communication channels with these system parachains has been optimized for efficiency and ease of use.</p> <p>Any parachain can establish a bidirectional channel with a system chain through a single operation, requiring just one XCM message from the parachain to the relay chain.</p>"},{"location":"tutorials/interoperability/xcm-channels/para-to-system/#prerequisites","title":"Prerequisites","text":"<p>To successfully complete this process, you'll need to have the following in place:</p> <ul> <li>Access to a blockchain network consisting of:<ul> <li>A relay chain</li> <li>A parachain</li> <li>An Asset Hub system chain</li> </ul> </li> <li>A wallet containing enough funds to cover transaction fees on each of the participating chains</li> </ul>"},{"location":"tutorials/interoperability/xcm-channels/para-to-system/#procedure-for-establishing-hrmp-channel","title":"Procedure for Establishing HRMP Channel","text":"<p>This guide demonstrates opening an HRMP channel between parachain 2500 and system chain Asset Hub (parachain 1000) on the Rococo Local relay chain.</p>"},{"location":"tutorials/interoperability/xcm-channels/para-to-system/#fund-parachain-sovereign-account","title":"Fund Parachain Sovereign Account","text":"<p>The sovereign account for parachain 2500 on the relay chain must be funded so it can take care of any XCM transact fees.</p> <p>Use Polkadot.js Apps UI to connect to the relay chain and transfer funds from your account to the parachain 2500 sovereign account.</p> <p></p> Calculating Parachain Sovereign Account <p>To generate the sovereign account address for a parachain, you'll need to follow these steps:</p> <ol> <li> <p>Determine if the parachain is an \"up/down\" chain (parent or child) or a \"sibling\" chain:</p> <ul> <li> <p>Up/down chains use the prefix <code>0x70617261</code> (which decodes to <code>b\"para\"</code>)</p> </li> <li> <p>Sibling chains use the prefix <code>0x7369626c</code> (which decodes to <code>b\"sibl\"</code>)</p> </li> </ul> </li> <li> <p>Calculate the u32 scale encoded value of the parachain ID:</p> <ul> <li>Parachain 2500 would be encoded as <code>c4090000</code></li> </ul> </li> <li> <p>Combine the prefix and parachain ID encoding to form the full sovereign account address:</p> <p>The sovereign account of parachain 2500 in relay chain will be <code>0x70617261c4090000000000000000000000000000000000000000000000000000</code> and the SS58 format of this address is <code>5Ec4AhPSY2GEE4VoHUVheqv5wwq2C1HMKa7c9fVJ1WKivX1Y</code></p> </li> </ol> <p>To perform this conversion, you can also use the \"Para ID\" to Address section in Substrate Utilities.</p>"},{"location":"tutorials/interoperability/xcm-channels/para-to-system/#create-establish-channel-with-system-extrinsic","title":"Create Establish Channel with System Extrinsic","text":"<ol> <li> <p>In Polkadot.js Apps, connect to the relay chain, navigate to the Developer dropdown and select the Extrinsics option</p> <p></p> </li> <li> <p>Construct an <code>establish_channel_with_system</code> extrinsic call</p> <ol> <li>Select the <code>hrmp</code> pallet</li> <li>Choose the <code>establish_channel_with_system</code> extrinsic</li> <li>Fill in the parameters:<ul> <li><code>target_system_chain</code> - parachain ID of the target system chain (in this case, 1000)</li> </ul> </li> <li>Copy the encoded call data  The encoded call data for establishing a channel with system parachain 1000 should be <code>0x3c0ae8030000</code></li> </ol> </li> </ol>"},{"location":"tutorials/interoperability/xcm-channels/para-to-system/#crafting-and-submitting-the-xcm-message","title":"Crafting and Submitting the XCM Message","text":"<p>Connect to parachain 2500 using Polkadot.js Apps to send the XCM message to the relay chain. Input the necessary parameters as illustrated in the image below. Make sure to:</p> <ol> <li>Insert your previously encoded <code>establish_channel_with_system</code> call data into the <code>call</code> field</li> <li>Provide beneficiary details</li> <li>Dispatch the XCM message to the relay chain by clicking the Submit Transaction button </li> </ol> <p>Note</p> <p>The exact process and parameters for submitting this XCM message may vary depending on your specific parachain and relay chain configurations. Always refer to the most current documentation for your particular network setup.</p> <p>After successfully submitting the XCM message to the relay chain, two HRMP channels should be created, establishing bidirectional communication between parachain 2500 and system chain 1000. To verify this, follow these steps:</p> <ol> <li> <p>Using Polkadot.js Apps, connect to the relay chain and navigate to the Developer dropdown, then select Chain state </p> </li> <li> <p>Query the HRMP channels</p> <ol> <li>Select <code>hrmp</code> from the options</li> <li>Choose the <code>hrmpChannels</code> call</li> <li>Click the + button to execute the query </li> </ol> </li> <li> <p>Examine the query results. You should see output similar to the following:     <pre><code>[\n    [\n        [\n            {\n                \"sender\": 1000,\n                \"recipient\": 2500\n            }\n        ],\n        {\n            \"maxCapacity\": 8,\n            \"maxTotalSize\": 8192,\n            \"maxMessageSize\": 1048576,\n            \"msgCount\": 0,\n            \"totalSize\": 0,\n            \"mqcHead\": null,\n            \"senderDeposit\": 0,\n            \"recipientDeposit\": 0\n        }\n    ],\n    [\n        [\n            {\n                \"sender\": 2500,\n                \"recipient\": 1000\n            }\n        ],\n        {\n            \"maxCapacity\": 8,\n            \"maxTotalSize\": 8192,\n            \"maxMessageSize\": 1048576,\n            \"msgCount\": 0,\n            \"totalSize\": 0,\n            \"mqcHead\": null,\n            \"senderDeposit\": 0,\n            \"recipientDeposit\": 0\n        }\n    ]\n]\n</code></pre></p> </li> </ol> <p>The output confirms the successful establishment of two HRMP channels:</p> <ul> <li>From chain 1000 (system chain) to chain 2500 (parachain)</li> <li>From chain 2500 (parachain) to chain 1000 (system chain)</li> </ul> <p>This bidirectional channel enables direct communication between the system chain and the parachain, allowing for cross-chain message passing.</p>"},{"location":"tutorials/polkadot-sdk/","title":"Polakdot SDK Tutorials","text":"<p>Explore detailed, step-by-step tutorials designed to help you gain hands-on experience building custom solutions with the Polkadot SDK.</p>"},{"location":"tutorials/polkadot-sdk/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"tutorials/polkadot-sdk/parachains/","title":"Parachains Tutorials","text":"<p>Explore tutorials on building parachains with the Polkadot SDK, covering key steps in developing and deploying tailored blockchain solutions.</p>"},{"location":"tutorials/polkadot-sdk/parachains/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"tutorials/polkadot-sdk/parachains/connect-to-relay-chain/","title":"Build a Parachain","text":"<p>Tutorials for building a parachain on Polkadot. These tutorials are designed to help you get started with building a parachain on Polkadot.</p>"},{"location":"tutorials/polkadot-sdk/parachains/connect-to-relay-chain/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"tutorials/polkadot-sdk/parachains/connect-to-relay-chain/acquire-a-testnet-slot/","title":"Acquire a TestNet Slot","text":""},{"location":"tutorials/polkadot-sdk/parachains/connect-to-relay-chain/acquire-a-testnet-slot/#introduction","title":"Introduction","text":"<p>This tutorial demonstrates deploying a parachain on a public test network like the Paseo network. Public TestNets have a higher bar to entry than a private network but represent an essential step in preparing a parachain project to move into a production network.</p>"},{"location":"tutorials/polkadot-sdk/parachains/connect-to-relay-chain/acquire-a-testnet-slot/#prerequisites","title":"Prerequisites","text":"<p>Before you start, you need to have the following prerequisites:</p> <ul> <li>You know how to generate and modify chain specification files as described in the Generate Chain Specs section</li> <li>You know how to generate and store keys as described in the Spin Your Nodes tutorial</li> <li>You have completed the Prepare a Local Relay Chain and the Prepare a Local Parachain tutorials on your local computer</li> </ul>"},{"location":"tutorials/polkadot-sdk/parachains/connect-to-relay-chain/acquire-a-testnet-slot/#get-started-with-an-account-and-tokens","title":"Get Started with an Account and Tokens","text":"<p>To perform any action on Paseo, you need PAS tokens, which can be requested from the Polkadot Faucet. Also, to store the tokens, you must have access to a Substrate-compatible digital currency wallet. Development keys and accounts should never hold assets of actual value and should not be used for production. Many options are available for holding digital currency\u2014including hardware wallets and browser-based applications\u2014and some are more reputable than others. You should do your own research before selecting one.</p> <p>However, you can use the Polkadot.js Apps interface to get you started for testing purposes.</p> <p>To prepare an account, follow these steps:</p> <ol> <li> <p>Open the Polkadot.js Apps interface and connect to the Paseo network</p> <p></p> </li> <li> <p>Navigate to the Accounts section</p> <ol> <li>Click on the Accounts tab in the top menu</li> <li>Select the Accounts option from the dropdown menu</li> </ol> <p></p> </li> <li> <p>Copy the address of the account you want to use for the parachain deployment</p> <p></p> </li> <li> <p>Visit the Polkadot Faucet and paste the copied address in the input field. Ensure that the network is set to Paseo and click on the Get some PASs button</p> <p></p> <p>After a few seconds, you will receive 100 PAS tokens in your account.</p> </li> </ol>"},{"location":"tutorials/polkadot-sdk/parachains/connect-to-relay-chain/acquire-a-testnet-slot/#reserve-a-parachain-identifier","title":"Reserve a Parachain Identifier","text":"<p>You must reserve a parachain identifier before registering a parathread on Paseo. The steps are similar to the ones you followed in Prepare a Local Parachain to reserve an identifier on the local relay chain. However, for the public TestNet, you'll be assigned the next available identifier.</p> <p>To reserve a parachain identifier, follow these steps:</p> <ol> <li> <p>Navigate to the Parachains section</p> <ol> <li>Click on the Network tab in the top menu</li> <li>Select the Parachains option from the dropdown menu</li> </ol> <p></p> </li> <li> <p>Register a parathread</p> <ol> <li>Select the Parathreads tab</li> <li>Click on the + ParaId button</li> </ol> <p></p> </li> <li> <p>Review the transaction and click on the + Submit button</p> <p></p> <p>For this case, the next available parachain identifier is <code>4508</code>.</p> </li> <li> <p>After submitting the transaction, you can navigate to the Explorer tab and check the list of recent events for successful <code>registrar.Reserved</code></p> <p></p> </li> </ol>"},{"location":"tutorials/polkadot-sdk/parachains/connect-to-relay-chain/acquire-a-testnet-slot/#modify-the-chain-specification-file","title":"Modify the Chain Specification File","text":"<p>The files required to register a parachain must specify the correct relay chain to connect to and the parachain identifier you have been assigned. To make these changes, you must build and modify the chain specification file for your parachain. In this tutorial, the relay chain is <code>paseo</code>, and the parachain identifier is <code>4508</code>.</p> <p>To modify the chain specification:</p> <ol> <li> <p>Generate the plain text chain specification for the parachain template node by running the following command:</p> <pre><code>./target/release/parachain-template-node build-spec \\\n  --disable-default-bootnode &gt; plain-parachain-chainspec.json\n</code></pre> </li> <li> <p>Open the plain text chain specification for the parachain template node in a text editor</p> </li> <li> <p>Set <code>relay_chain</code> to <code>paseo</code> and <code>para_id</code> to the identifier you've been assigned. For example, if your reserved identifier is 4508, set the <code>para_id</code> field to <code>4508</code>:</p> <pre><code>\"...\": \"...\",\n\"relay_chain\": \"paseo\",\n\"para_id\": 4508,\n        \"...\": {}\n    }\n}\n</code></pre> </li> <li> <p>Set the <code>parachainId</code> to the parachain identifier that you previously reserved:</p> <pre><code>{\n    \"...\": \"...\",\n\"genesis\": {\n    \"runtime\": {\n        \"...\": {},\n        \"parachainInfo\": {\n            \"parachainId\": 4508\n        },\n        },\n        \"...\": {}\n    }\n}\n</code></pre> </li> <li> <p>Add the public key for your account to the session keys section. Each configured session key will require a running collator:</p> <pre><code>{\n    \"...\": \"...\",\n\"genesis\": {\n    \"runtime\": {\n        \"...\": {},\n            \"session\": {\n                \"keys\": [\n                    [\n                        \"5HErbKmL5JmUKDVsH1aGyXTGZb4i9iaNsFhSgkNDr8qp2Dvj\",\n                        \"5HErbKmL5JmUKDVsH1aGyXTGZb4i9iaNsFhSgkNDr8qp2Dvj\",\n                        {\n                            \"aura\": \"5HErbKmL5JmUKDVsH1aGyXTGZb4i9iaNsFhSgkNDr8qp2Dvj\"\n                        }\n                    ]\n                ]\n            }\n        },\n        \"...\": {}\n    }\n}\n</code></pre> </li> <li> <p>Save your changes and close the plain text chain specification file</p> </li> <li> <p>Generate a raw chain specification file from the modified chain specification file:</p> <pre><code>./target/release/parachain-template-node build-spec \\\n  --chain plain-parachain-chainspec.json \\\n  --disable-default-bootnode \\\n  --raw &gt; raw-parachain-chainspec.json\n</code></pre> <p>After running the command, you will see the following output:</p> <p> ./target/release/parachain-template-node build-spec --chain plain-parachain-chainspec.json --disable-default-bootnode --raw &gt; raw-parachain-chainspec.json 2024-09-11 09:48:15 Building chain spec 2024-09-11 09:48:15 assembling new collators for new session 0 at #0 2024-09-11 09:48:15 assembling new collators for new session 1 at #0 </p> </li> </ol>"},{"location":"tutorials/polkadot-sdk/parachains/connect-to-relay-chain/acquire-a-testnet-slot/#export-required-files","title":"Export Required Files","text":"<p>To prepare the parachain collator to be registered on Paseo, follow these steps:</p> <ol> <li> <p>Export the Wasm runtime for the parachain by running a command similar to the following:</p> <pre><code>./target/release/parachain-template-node export-genesis-wasm \\\n  --chain raw-parachain-chainspec.json para-4508-wasm\n</code></pre> </li> <li> <p>Export the genesis state for the parachain by running a command similar to the following:</p> <pre><code>./target/release/parachain-template-node export-genesis-state \\\n  --chain raw-parachain-chainspec.json para-4508-state\n</code></pre> </li> </ol>"},{"location":"tutorials/polkadot-sdk/parachains/connect-to-relay-chain/acquire-a-testnet-slot/#start-the-collator-node","title":"Start the Collator Node","text":"<p>You must have the ports for the collator publicly accessible and discoverable to enable parachain nodes to peer with Paseo validator nodes to produce blocks. You can specify the ports with the <code>--port</code> command-line option. For example, you can start the collator with a command similar to the following:</p> <pre><code>./target/release/parachain-template-node --collator \\\n  --chain raw-parachain-chainspec.json \\\n  --base-path /tmp/parachain/pubs-demo \\\n  --port 50333 \\\n  --rpc-port 8855 \\\n  -- \\\n  --execution wasm \\\n  --chain paseo \\\n  --port 50343 \\\n  --rpc-port 9988\n</code></pre> <p>In this example, the first <code>--port</code> setting specifies the port for the collator node and the second <code>--port</code> specifies the embedded relay chain node port. The first <code>--rpc-port</code> setting specifies the port you can connect to the collator. The second <code>--rpc-port</code> specifies the port for connecting to the embedded relay chain.</p>"},{"location":"tutorials/polkadot-sdk/parachains/connect-to-relay-chain/acquire-a-testnet-slot/#obtain-coretime","title":"Obtain Coretime","text":"<p>With your parachain collator operational, the next step is acquiring coretime. This is essential for ensuring your parachain's security through the relay chain. Agile Coretime enhances Polkadot's resource management, offering developers greater economic adaptability. Once you have configured your parachain, you can follow two paths:</p> <ul> <li>Bulk coretime is purchased via the Broker pallet on the respective coretime system parachain. You can purchase bulk coretime on the coretime chain and assign the purchased core to the registered <code>ParaID</code></li> <li>On-demand coretime is ordered via the <code>OnDemandAssignment</code> pallet, which is located on the respective relay chain</li> </ul> <p>For more information on coretime, refer to the Coretime documentation.</p>"},{"location":"tutorials/polkadot-sdk/parachains/connect-to-relay-chain/prepare-parachain/","title":"Prepare a Parachain","text":""},{"location":"tutorials/polkadot-sdk/parachains/connect-to-relay-chain/prepare-parachain/#introduction","title":"Introduction","text":"<p>This tutorial illustrates reserving a parachain identifier with a local relay chain and connecting a local parachain to that relay chain. By completing this tutorial, you will accomplish the following objectives:</p> <ul> <li>Compile a local parachain node</li> <li>Reserve a unique identifier with the local relay chain for the parachain to use</li> <li>Configure a chain specification for the parachain</li> <li>Export the runtime and genesis state for the parachain</li> <li>Start the local parachain and see that it connects to the local relay chain</li> </ul>"},{"location":"tutorials/polkadot-sdk/parachains/connect-to-relay-chain/prepare-parachain/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure that you have the following prerequisites:</p> <ul> <li>Configured a local relay chain with two validators as described in the Prepare a Relay Chain tutorial</li> <li>You are aware that parachain versions and dependencies are tightly coupled with the version of the relay chain they connect to and know the software version you used to configure the relay chain</li> </ul>"},{"location":"tutorials/polkadot-sdk/parachains/connect-to-relay-chain/prepare-parachain/#build-the-parachain-template","title":"Build the Parachain Template","text":"<p>This tutorial uses the Polkadot SDK Parachain Template to illustrate launching a parachain that connects to a local relay chain. The parachain template is similar to the Solochain Template used in development. You can also use the parachain template as the starting point for developing a custom parachain project.</p> <p>To build the parachain template, follow these steps:</p> <ol> <li> <p>Clone the branch of the <code>polkadot-sdk-parachain-template</code> repository</p> <pre><code>git clone https://github.com/paritytech/polkadot-sdk-parachain-template.git\n</code></pre> <p>Note</p> <p>Ensure that you clone the correct branch of the repository that matches the version of the relay chain you are connecting to.</p> </li> <li> <p>Change the directory to the cloned repository</p> <pre><code>cd polkadot-sdk-solochain-template\n</code></pre> </li> <li> <p>Build the parachain template collator</p> <pre><code>cargo build --release\n</code></pre> <p>Note</p> <p>Depending on your system\u2019s performance, compiling the node can take a few minutes.</p> </li> </ol>"},{"location":"tutorials/polkadot-sdk/parachains/connect-to-relay-chain/prepare-parachain/#reserve-a-parachain-identifier","title":"Reserve a Parachain Identifier","text":"<p>Every parachain must reserve a unique <code>ParaID</code> identifier to connect to its specific relay chain. Each relay chain manages its own set of unique identifiers for the parachains that connect to it. The identifier is called a <code>ParaID</code> because the same identifier can be used to identify a slot occupied by a parachain or a parathread.</p> <p>Note that you must have an account with sufficient funds to reserve a slot on a relay chain. You can determine the number of tokens a specific relay chain requires by checking the <code>ParaDeposit</code> configuration in the <code>paras_registrar</code> pallet for that relay chain. The following example shows a <code>ParaDeposit</code> requirement of 40 native tokens:</p> <pre><code>parameter_types! {\n    pub const ParaDeposit: Balance = 40 * UNITS;\n}\n\nimpl paras_registrar::Config for Runtime {\n    type RuntimeOrigin = RuntimeOrigin;\n    type RuntimeEvent = RuntimeEvent;\n    type Currency = Balances;\n    type OnSwap = (Crowdloan, Slots);\n    type ParaDeposit = ParaDeposit;\n    type DataDepositPerByte = DataDepositPerByte;\n    type WeightInfo = weights::runtime_common_paras_registrar::WeightInfo&lt;Runtime&gt;;\n}\n</code></pre> <p>Each relay chain allows its identifiers by incrementing the identifier starting at <code>2000</code> for all chains that aren't system parachains. System parachains use a different method to allocate slot identifiers.</p> <p>To reserve a parachain identifier, follow these steps:</p> <ol> <li> <p>Ensure your local relay chain validators are running. For further information, refer to the Prepare a Relay Chain tutorial</p> </li> <li> <p>Connect to a local relay chain node using the Polkadot.js Apps interface. If you have followed the Prepare a Relay Chain tutorial, you can access the Polkadot.js Apps interface at <code>ws://localhost:9944</code></p> <p></p> </li> <li> <p>Navigate to the Parachains section</p> <ol> <li>Click on the Network tab</li> <li>Select Parachains from the dropdown menu</li> </ol> <p></p> </li> <li> <p>Register a parathread</p> <ol> <li>Select the Parathreads tab</li> <li>Click on the + ParaId button</li> </ol> <p></p> </li> <li> <p>Fill in the required fields and click on the + Submit button</p> <p></p> <p>Note</p> <p>The account used to reserve the identifier will be the account charged for the transaction and the origin account for the parathread associated with the identifier.</p> </li> <li> <p>After submitting the transaction, you can navigate to the Explorer tab and check the list of recent events for successful <code>registrar.Reserved</code></p> <p></p> </li> </ol> <p>You are now ready to prepare the chain specification and generate the files required for your parachain to connect to the relay chain using the reserved identifier (<code>paraId 2000</code>).</p>"},{"location":"tutorials/polkadot-sdk/parachains/connect-to-relay-chain/prepare-parachain/#modify-the-default-chain-specification","title":"Modify the Default Chain Specification","text":"<p>To register your parachain with the local relay chain, you must modify the default chain specification to use your reserved parachain identifier.</p> <p>To modify the default chain specification, follow these steps:</p> <ol> <li> <p>Generate the plain text chain specification for the parachain template node by running the following command</p> <pre><code>./target/release/parachain-template-node build-spec \\\n  --disable-default-bootnode &gt; plain-parachain-chainspec.json\n</code></pre> </li> <li> <p>Open the plain text chain specification for the parachain template node in a text editor</p> </li> <li> <p>Set the <code>para_id</code> to the parachain identifier that you previously reserved. For example, if your reserved identifier is <code>2000</code>, set the <code>para_id</code> field to <code>2000</code>:</p> <pre><code>\"...\": \"...\",\n\"relay_chain\": \"rococo-local\",\n\"para_id\": 2000,\n\"genesis\": {\n        \"...\": {}\n    }\n}\n</code></pre> </li> <li> <p>Set the <code>parachainId</code> to the parachain identifier that you previously reserved. For example, if your reserved identifier is <code>2000</code>, set the <code>parachainId</code> field to <code>2000</code></p> <pre><code>\"...\": \"...\",\n    \"genesis\": {\n        \"runtime\": {\n            \"...\": {},\n            \"parachainInfo\": {\n                \"parachainId\": 2000\n            }\n        },\n        \"...\": {}\n    }\n}\n</code></pre> </li> <li> <p>If you complete this tutorial simultaneously as anyone on the same local network, an additional step is needed to prevent accidentally peering with their nodes. Find the following line and add characters to make your <code>protocolId</code> unique</p> <pre><code>\"...\": \"...\",\n\"protocolId\": \"template-local\",\n\"genesis\": {\n        \"...\": {}\n    }\n}\n</code></pre> </li> <li> <p>Save your changes and close the plain text chain specification file</p> </li> <li> <p>Generate a raw chain specification file from the modified chain specification file by running the following command</p> <pre><code>./target/release/parachain-template-node build-spec \\\n  --chain plain-parachain-chainspec.json \\\n  --disable-default-bootnode \\\n  --raw &gt; raw-parachain-chainspec.json\n</code></pre> <p>After running the command, you will see the following output:</p> <p> ./target/release/parachain-template-node build-spec \\ --chain plain-parachain-chainspec.json \\ --disable-default-bootnode \\ --raw &gt; raw-parachain-chainspec.json 2024-09-10 14:34:58 Building chain spec 2024-09-10 14:34:59 assembling new collators for new session 0 at #0 2024-09-10 14:34:59 assembling new collators for new session 1 at #0 </p> </li> </ol>"},{"location":"tutorials/polkadot-sdk/parachains/connect-to-relay-chain/prepare-parachain/#prepare-the-parachain-collator","title":"Prepare the Parachain Collator","text":"<p>With the local relay chain running and the raw chain specification for the parachain template updated, you can start the parachain collator node and export information about its runtime and genesis state.</p> <p>To prepare the parachain collator to be registered:</p> <ol> <li> <p>Export the Wasm runtime for the parachain</p> <p>The relay chain needs the parachain-specific runtime validation logic to validate parachain blocks. You can export the Wasm runtime for a parachain collator node by running a command similar to the following:</p> <pre><code>./target/release/parachain-template-node export-genesis-wasm \\\n  --chain raw-parachain-chainspec.json para-2000-wasm\n</code></pre> </li> <li> <p>Generate a parachain genesis state</p> <p>To register a parachain, the relay chain needs to know the genesis state of the parachain. You can export the entire genesis state\u2014hex-encoded\u2014to a file by running a command similar to the following:</p> <pre><code>./target/release/parachain-template-node export-genesis-state \\\n  --chain raw-parachain-chainspec.json para-2000-genesis-state\n</code></pre> <p>After running the command, you will see the following output:</p> <p> ./target/release/parachain-template-node export-genesis-state \\ --chain raw-parachain-chainspec.json para-2000-genesis-state 2024-09-10 14:41:13 \ud83d\udd28 Initializing Genesis block/state (state: 0xb089\u20261830, header-hash: 0x6b0b\u2026bd69) </p> <p>Note</p> <p>You should note that the runtime and state you export must be for the genesis block. You can't connect a parachain with any previous state to a relay chain. All parachains must start from block 0 on the relay chain. See Convert a Solo Chain for details on how the parachain template was created and how to convert the chain logic\u2014not its history or state migrations\u2014to a parachain.</p> </li> <li> <p>Start a collator node with a command similar to the following</p> <pre><code>./target/release/parachain-template-node \\\n  --charlie \\\n  --collator \\\n  --force-authoring \\\n  --chain raw-parachain-chainspec.json \\\n  --base-path /tmp/charlie-parachain/ \\\n  --unsafe-force-node-key-generation \\\n  --port 40333 \\\n  --rpc-port 8844 \\\n  -- \\\n  --chain INSERT_RELAY_CHAIN_PATH/local-raw-spec.json \\\n  --port 30333 \\\n  --rpc-port 9946\n</code></pre> <p>Note</p> <p>Ensure that you replace <code>INSERT_RELAY_CHAIN_PATH</code> with the path to the raw chain specification for the local relay chain.</p> <p>After running the command, you will see the following output:</p> <p> ./target/release/parachain-template-node \\ --charlie \\ --collator \\ --force-authoring \\ --chain raw-parachain-chainspec.json \\ --base-path /tmp/charlie-parachain/ \\ --unsafe-force-node-key-generation \\ --port 40333 \\ --rpc-port 8844 \\ -- \\ --chain INSERT_RELAY_CHAIN_PATH/local-raw-spec.json \\ --port 30333 \\ --rpc-port 9946 2024-09-10 16:26:30 [Parachain] PoV size { header: 0.21875kb, extrinsics: 3.6103515625kb, storage_proof: 3.150390625kb } 2024-09-10 16:26:30 [Parachain] Compressed PoV size: 6.150390625kb 2024-09-10 16:26:33 [Relaychain] \ud83d\udca4 Idle (2 peers), best: #1729 (0x3aa4\u2026cb6b), finalized #1726 (0xff7a\u20264352), \u2b07 9.1kiB/s \u2b06 3.8kiB/s </p> </li> </ol>"},{"location":"tutorials/polkadot-sdk/parachains/connect-to-relay-chain/prepare-parachain/#register-with-the-local-relay-chain","title":"Register With the Local Relay Chain","text":"<p>With the local relay chain and collator node running, you can register the parachain on the local relay chain. In a live public network, registration typically involves a parachain auction. You can use a Sudo transaction and the Polkadot.js Apps interface for this tutorial and local testing. A Sudo transaction lets you bypass the steps required to acquire a parachain or parathread slot. This transaction should be executed in the relay chain.</p> <p>To register the parachain, follow these steps:</p> <ol> <li>Validate that your local relay chain validators are running</li> <li> <p>Navigate to the Sudo tab in the Polkadot.js Apps interface</p> <ol> <li>Click on the Developer tab</li> <li>Select Sudo from the dropdown menu</li> </ol> <p></p> </li> <li> <p>Submit a transaction with Sudo privileges</p> <ol> <li>Select the <code>paraSudoWrapper</code> pallet</li> <li>Click on the <code>sudoScheduleParaInitialize</code> extrinsic from the list of available extrinsics</li> </ol> <p></p> </li> <li> <p>Fill in the required fields</p> <ol> <li><code>id</code> - type the parachain identifier you reserved</li> <li><code>genesisHead</code> - click the file upload button and select the <code>para-2000-genesis-state</code> file you exported</li> <li><code>validationCode</code> - click the file upload button and select the <code>para-2000-wasm</code> file you exported</li> <li> <p><code>paraKind</code> - select Yes if you are registering a parachain or No if you are registering a parathread</p> </li> <li> <p>Click on the Submit Transaction button</p> </li> </ol> <p></p> </li> <li> <p>After submitting the transaction, you can navigate to the Explorer tab and check the list of recent events for successful <code>paras.PvfCheckAccepted</code></p> <p></p> <p>After the parachain is initialized, you can see it in Parachains section of the Polkadot.js Apps interface</p> </li> <li> <p>Click Network and select Parachains and wait for a new epoch to start</p> <p></p> </li> </ol> <p>The relay chain tracks the latest block\u2014the head\u2014of each parachain. When a relay chain block is finalized, the parachain blocks that have completed the validation process are also finalized. This is how Polkadot achieves pooled, shared security for its parachains.</p> <p>After the parachain connects to the relay chain in the next epoch and finalizes its first block you can see information about it in the Polkadot/Substrate Portal.</p> <p>The terminal where the parachain is running also displays details similar to the following:</p> ... [Relaychain] \ud83d\udca4 Idle (2 peers), best: #90 (0x5f73\u20261ccf), finalized #87 (0xeb50\u202668ea), \u2b07 1.4kiB/s \u2b06 1.1kiB/s [Parachain] \ud83d\udca4 Idle (0 peers), best: #0 (0x3626\u2026fef3), finalized #0 (0x3626\u2026fef3), \u2b07 1.2kiB/s \u2b06 0.7kiB/s [Relaychain] \ud83d\udca4 Idle (2 peers), best: #90 (0x5f73\u20261ccf), finalized #88 (0xd43c\u2026c3e6), \u2b07 0.7kiB/s \u2b06 0.5kiB/s [Parachain] \ud83d\udca4 Idle (0 peers), best: #0 (0x3626\u2026fef3), finalized #0 (0x3626\u2026fef3), \u2b07 1.0kiB/s \u2b06 0.6kiB/s [Relaychain] \ud83d\udc76 New epoch 9 launching at block 0x1c93\u20264aa9 (block slot 281848325 &gt;= start slot 281848325) [Relaychain] \ud83d\udc76 Next epoch starts at slot 281848335 [Relaychain] \u2728 Imported #91 (0x1c93\u20264aa9) [Parachain] Starting collation. relay_parent=0x1c936289cfe15fabaa369f7ae5d73050581cb12b75209c11976afcf07f6a4aa9 at=0x36261113c31019d4b2a1e27d062e186f46da0e8f6786177dc7b35959688ffef3 [Relaychain] \ud83d\udca4 Idle (2 peers), best: #91 (0x1c93\u20264aa9), finalized #88 (0xd43c\u2026c3e6), \u2b07 1.2kiB/s \u2b06 0.7kiB/s [Parachain] \ud83d\udca4 Idle (0 peers), best: #0 (0x3626\u2026fef3), finalized #0 (0x3626\u2026fef3), \u2b07 0.2kiB/s \u2b06 37 B/s"},{"location":"tutorials/polkadot-sdk/parachains/connect-to-relay-chain/prepare-parachain/#resetting-the-blockchain-state","title":"Resetting the Blockchain State","text":"<p>The parachain collator you connected to the relay chain in this tutorial contains all of the blockchain data for the parachain. There's only one node in this parachain network, so any transactions you submit are only stored on this node. Relay chains don't store any parachain state. The relay chain only stores header information for the parachains that connect to it.</p> <p>For testing purposes, you might want to purge the blockchain state to start over periodically. However, you should remember that if you purge the chain state or manually delete the database, you won\u2019t be able to recover the data or restore the chain state. If you want to preserve data, you should ensure you have a copy before you purge the parachain state.</p> <p>If you want to start over with a clean environment for testing, you should completely remove the chain state for the local relay chain nodes and the parachain.</p> <p>To reset the blockchain state, follow these steps:</p> <ol> <li> <p>In the terminal where the parachain template node is running, press <code>Control-C</code></p> </li> <li> <p>Purge the parachain collator state by running the following command</p> <pre><code>./target/release/parachain-template-node purge-chain \\\n  --chain raw-parachain-chainspec.json\n</code></pre> </li> <li> <p>In the terminal where either the <code>alice</code> validator node or the <code>bob</code> validator node is running, press <code>Control-C</code></p> </li> <li> <p>Purge the local relay chain state by running the following command</p> <pre><code>./target/release/polkadot purge-chain \\\n  --chain local-raw-spec.json\n</code></pre> </li> </ol> <p>After purging the chain state, you can restart the local relay chain and parachain collator nodes to begin with a clean environment.</p> <p>Note</p> <p>Note that to reset the network state and allow all the nodes to sync after the reset, each of them needs to purge their databases. Otherwise, the nodes won't be able to sync with each other effectively.</p> <p>Now that you have successfully connected a parachain to a relay chain, you can explore more advanced features and functionalities of parachains, such as:</p> <ul> <li>Opening HRMP Channels</li> <li>Transfer Assets Between Parachains</li> </ul>"},{"location":"tutorials/polkadot-sdk/parachains/connect-to-relay-chain/prepare-relay-chain/","title":"Prepare a Relay Chain","text":""},{"location":"tutorials/polkadot-sdk/parachains/connect-to-relay-chain/prepare-relay-chain/#introduction","title":"Introduction","text":"<p>This tutorial illustrates how to configure and spin up a local relay chain. The local relay chain is needed to set up a local testing environment to which a test parachain node can connect. Setting up a local relay chain is a crucial step in parachain development. It allows developers to test their parachains in a controlled environment, simulating the interaction between a parachain and the relay chain without needing a live network. This local setup facilitates faster development cycles and easier debugging.</p> <p>The scope of this tutorial includes:</p> <ul> <li>Installing necessary components for a local relay chain</li> <li>Configuring the relay chain settings</li> <li>Starting and running the local relay chain</li> <li>Verifying the relay chain is operational</li> </ul>"},{"location":"tutorials/polkadot-sdk/parachains/connect-to-relay-chain/prepare-relay-chain/#prerequisites","title":"Prerequisites","text":"<p>Before diving into this tutorial, it's recommended that you have a basic understanding of how adding trusted nodes works in Polkadot. For further information about this process, refer to the Spin Your Nodes tutorial.</p> <p>To complete this tutorial, ensure that you have:</p> <ul> <li>Installed Rust and the Rust toolchain. Refer to the Installation guide for step-by-step instructions on setting up your development environment</li> <li>Completed Launch a Local Solochain tutorial and know how to compile and run a Polkadot SDK-based node</li> </ul>"},{"location":"tutorials/polkadot-sdk/parachains/connect-to-relay-chain/prepare-relay-chain/#build-a-local-relay-chain","title":"Build a Local Relay Chain","text":"<p>To build a local relay chain, follow these steps:</p> <ol> <li> <p>Clone the most recent release branch of the Polkadot SDK repository to prepare a stable working environment:</p> <pre><code>git clone --depth 1 --branch polkadot-stable2407-2 \\\nhttps://github.com/paritytech/polkadot-sdk.git\n</code></pre> <p>Note</p> <p>The branch <code>polkadot-stable2407-2</code> is used in this tutorial since it is the branch that contains the latest stable release of the Polkadot SDK. You can find the latest release of the Polkadot SDK on the Release tab on the Polkadot GitHub repository.</p> <p>Note</p> <p>Note that the <code>--depth 1</code> flag is used to clone only the latest commit of the branch, which speeds up the cloning process.</p> </li> <li> <p>Change the directory to the Polkadot SDK repository:</p> <pre><code>cd polkadot-sdk\n</code></pre> </li> <li> <p>Build the relay chain node:</p> <pre><code>cargo build --release\n</code></pre> <p>Note</p> <p>Depending on your machine's specifications, the build process may take some time.</p> </li> <li> <p>Verify that the node is built correctly:</p> <pre><code>./target/release/polkadot --version\n</code></pre> </li> </ol> <p>If command-line help is displayed, the node is ready to configure.</p>"},{"location":"tutorials/polkadot-sdk/parachains/connect-to-relay-chain/prepare-relay-chain/#relay-chain-configuration","title":"Relay Chain Configuration","text":"<p>Every Substrate-based chain requires a chain specification. The relay chain's chain specification provides the same configuration settings as the chain specification for other networks. Many of the chain specification file settings are critical for network operations. For example, the chain specification identifies peers participating in the network, keys for validators, bootnode addresses, and other information.</p>"},{"location":"tutorials/polkadot-sdk/parachains/connect-to-relay-chain/prepare-relay-chain/#sample-chain-configuration","title":"Sample Chain Configuration","text":"<p>The local relay chain uses a sample chain specification file with two validator relay chain nodes\u2014Alice and Bob\u2014as authorities for this tutorial. Because a relay chain must have at least one more validator node running than the total number of connected parachain collators, you can only use the chain specification from this tutorial for a local relay chain network with a single parachain.</p> <p>If you wanted to connect two parachains with a single collator each, you must run three or more relay chain validator nodes. You must modify the chain specification and hard-code additional validators to set up a local test network for two or more parachains.</p>"},{"location":"tutorials/polkadot-sdk/parachains/connect-to-relay-chain/prepare-relay-chain/#plain-and-raw-chain-specification","title":"Plain and Raw Chain Specification","text":"<p>The chain specification file is available in two formats: a JSON file in plain text and a JSON file in SCALE-encoded raw format.</p> <p>You can read and edit the plain text version of the chain specification file. However, the chain specification file must be converted to the SCALE-encoded raw format before you can use it to start a node. For information about converting a chain specification to the raw format, see Customize a Chain Specification.</p> <p>The sample chain specification is only valid for a single parachain with two validator nodes. If you add other validators, add additional parachains to your relay chain, or want to use custom account keys instead of the predefined account, you'll need to create a custom chain specification file.</p> <p>Suppose you are completing this tutorial simultaneously as anyone on the same local network. In that case, you must download and modify the plain sample relay chain spec to prevent accidentally peering with their nodes. Find the following line in the plain chain spec and add characters to make the <code>protocolId</code> field unique:</p> <pre><code>\"protocolId\": \"dot\",\n</code></pre>"},{"location":"tutorials/polkadot-sdk/parachains/connect-to-relay-chain/prepare-relay-chain/#start-the-relay-chain-node","title":"Start the Relay Chain Node","text":"<p>Before starting block production for a parachain, you need to start a relay chain for them to connect.</p> <p>To start the validator nodes, follow these steps:</p> <ol> <li> <p>Generate the chain specification file in the plain text format and use it to create the raw chain specification file. Save the raw chain specification file in a local working directory</p> <ol> <li> <p>Generate the plain text chain specification file:</p> <pre><code>./target/release/polkadot build-spec \\\n  --chain rococo-local-testnet &gt; /tmp/plain-local-chainspec.json\n</code></pre> <p>Note</p> <p>Note that the network values are set to the default when generating the chain specification file with the <code>build-spec</code>. You can customize the network values by editing the chain specification file for production networks.</p> </li> <li> <p>Convert the plain text chain specification file to the raw format:</p> <pre><code>./target/release/polkadot build-spec \\\n  --chain plain-local-chainspec.json \\\n  --raw &gt; /tmp/raw-local-chainspec.json\n</code></pre> </li> </ol> </li> <li> <p>Start the first validator using the <code>alice</code> account by running the following command:</p> <pre><code>./target/release/polkadot \\\n  --alice \\\n  --validator \\\n  --base-path /tmp/alice \\\n  --chain /tmp/raw-local-chainspec.json \\\n  --port 30333 \\\n  --rpc-port 9944 \\\n  --insecure-validator-i-know-what-i-do \\\n  --force-authoring\n</code></pre> <p>This command uses <code>/tmp/raw-local-chainspec.json</code> as the location of the sample chain specification file. Ensure the <code>--chain</code> command line specifies the path to your generated raw chain specification. This command also uses the default values for the port (<code>port</code>) and WebSocket port (<code>ws-port</code>). The values are explicitly included here as a reminder to always check these settings. After the node starts, no other nodes on the same local machine can use these ports.</p> </li> <li> <p>Review log messages as the node starts and take note of the <code>Local node identity</code> value. This value is the node's peer ID, which you need to connect the parachain to the relay chain:</p> <p> 2024-09-09 13:49:58 Parity Polkadot 2024-09-09 13:49:58 \u270c\ufe0f version 1.15.2-d6f482d5593 2024-09-09 13:49:58 \u2764\ufe0f by Parity Technologies &lt;admin@parity.io&gt;, 2017-2024 2024-09-09 13:49:58 \ud83d\udccb Chain specification: Rococo Local Testnet 2024-09-09 13:49:58 \ud83c\udff7 Node name: Alice 2024-09-09 13:49:58 \ud83d\udc64 Role: AUTHORITY 2024-09-09 13:49:58 \ud83d\udcbe Database: RocksDb at /tmp/relay/alice/chains/rococo_local_testnet/db/full 2024-09-09 13:49:59 \ud83c\udff7 Local node identity is: 12D3KooWG393uX82rR3QgDkZpb7U8StzuRx9BQUXCvWsP1ctgygp 2024-09-09 13:49:59 Running libp2p network backend ... </p> <p>Note</p> <p>You need to specify this identifier to enable other nodes to connect. In this case, the <code>Local node identity</code> is <code>12D3KooWG393uX82rR3QgDkZpb7U8StzuRx9BQUXCvWsP1ctgygp</code>.</p> </li> <li> <p>Open a new terminal and start the second validator using the <code>bob</code> account. The command is similar to the command used to start the first node, with a few crucial differences:</p> <pre><code>./target/release/polkadot \\\n  --bob \\\n  --validator \\\n  --base-path /tmp/bob \\\n  --chain /tmp/raw-local-chainspec.json \\\n  --port 30334 \\\n  --rpc-port 9945\n</code></pre> <p>Notice that this command uses a different base path (<code>/tmp/relay/bob</code>), validator key (<code>--bob</code>), and ports (<code>30334</code> and <code>9945</code>).</p> <p>Because both validators are running on a single local computer, it isn't necessary to specify the <code>--bootnodes</code> command-line option and the first node's IP address and peer identifier. The <code>--bootnodes</code> option is required to connect nodes outside the local network or not identified in the chain specification file.</p> <p>If you don't see the relay chain producing blocks, try disabling your firewall or adding the bootnodes command-line option with the address of Alice's node to start the node. Adding the bootnodes option looks like this (with the node identity of Alice's node):</p> <pre><code>--bootnodes \\\n  /ip4/127.0.0.1/tcp/30333/p2p/12D3KooWG393uX82rR3QgDkZpb7U8StzuRx9BQUXCvWsP1ctgygp\n</code></pre> </li> <li> <p>Verify that the relay chain nodes are running by checking the logs for each node. The logs should show that the nodes are connected and producing blocks. For example, Bob's logs will be displayed as follows:</p> <p> ... 2024-09-10 13:29:38 \ud83c\udfc6 Imported #55 (0xad6a\u2026567c \u2192 0xecae\u2026ad12) 2024-09-10 13:29:38 \ud83d\udca4 Idle (1 peers), best: #55 (0xecae\u2026ad12), finalized #0 (0x1cac\u2026618d), \u2b07 2.0kiB/s \u2b06 1.6kiB/s ... </p> </li> </ol> <p>Once the relay chain nodes are running, you can proceed to the next tutorial to set up a test parachain node and connect it to the relay chain.</p>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/","title":"Build a Solochain","text":"<p>Learn to build and manage Polkadot SDK-based local solochains. Covers setup, networking, authorization, monitoring, and upgrades.</p>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/connect-multiple-nodes/","title":"Connect Predefined Default Nodes","text":""},{"location":"tutorials/polkadot-sdk/parachains/local-chain/connect-multiple-nodes/#introduction","title":"Introduction","text":"<p>This tutorial introduces you to the process of initiating a private blockchain network with a set of default authorized validators (Alice and Bob). If you prefer, you can also launch a private blockchain with your own validator accounts.</p> <p>The Polkadot SDK Solochain Template implements an authority consensus model to regulate block production. In this model, the creation of blocks is restricted to a predefined list of authorized accounts, known as \"authorities,\" who operate in a round-robin fashion. </p> <p>To demonstrate this concept, you'll simulate a network environment using two nodes running on a single computer, each configured with different accounts and keys. Throughout this tutorial, you'll gain practical insight into the functionality of the authority consensus model by observing how these two predefined accounts, serving as authorities, enable the nodes to produce blocks.</p> <p>By completing this tutorial, you will accomplish the following objectives:</p> <ul> <li>Start a blockchain node using a predefined account</li> <li>Learn the key command-line options used to start a node</li> <li>Determine if a node is running and producing blocks</li> <li>Connect a second node to a running network</li> <li>Verify peer computers produce and finalize blocks</li> </ul>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/connect-multiple-nodes/#prerequisites","title":"Prerequisites","text":"<p>Before proceeding, ensure you have the following prerequisites in place:</p> <ul> <li>Installed and configured Rust on your system. Refer to the Installation guide for detailed instructions on installing Rust and setting up your development environment</li> <li>Completed the Launch a Local Solochain guide and have the Polkadot SDK Solochain Template installed on your local machine</li> </ul>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/connect-multiple-nodes/#start-the-first-blockchain-node","title":"Start the First Blockchain Node","text":"<p>This tutorial demonstrates the fundamentals of a private network using a predefined chain specification called local and two preconfigured user accounts. You'll simulate a private network by running two nodes on a single local computer, using accounts named Alice and Bob.</p> <p>Follow these steps to start your first blockchain node:</p> <ol> <li> <p>Navigate to the root directory where you compiled the Polkadot SDK Solochain Template</p> </li> <li> <p>Clear any existing chain data by executing the following:     <pre><code>./target/release/solochain-template-node purge-chain --base-path /tmp/alice --chain local\n</code></pre></p> <p>When prompted to confirm, type <code>y</code> and press <code>Enter</code>. This step ensures a clean start for your new network</p> </li> <li> <p>Launch the first blockchain node using the Alice account:     <pre><code>./target/release/solochain-template-node \\\n--base-path /tmp/alice \\\n--chain local \\\n--alice \\\n--port 30333 \\\n--rpc-port 9945 \\\n--node-key 0000000000000000000000000000000000000000000000000000000000000001 \\\n--validator\n</code></pre></p> </li> </ol>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/connect-multiple-nodes/#review-the-command-line-options","title":"Review the Command-Line Options","text":"<p>Before proceeding, examine the key command-line options used to start the node:</p> <ul> <li><code>--base-path</code> - specifies the directory for storing all chain-related data</li> <li><code>--chain</code> - defines the chain specification to use</li> <li><code>--alice</code> - adds the predefined keys for the Alice account to the node's keystore. This account is used for block production and finalization</li> <li><code>--port</code> - sets the listening port for peer-to-peer (p2p) traffic. Different ports are necessary when running multiple nodes on the same machine</li> <li><code>--rpc-port</code> - specifies the port for incoming JSON-RPC traffic via WebSocket and HTTP</li> <li><code>--node-key</code> - defines the Ed25519 secret key for libp2p networking</li> <li><code>--validator</code> - enables this node to participate in block production and finalization for the network</li> </ul> <p>For a comprehensive overview of all available command-line options for the node template, you can access the built-in help documentation. Execute the following command in your terminal:</p> <pre><code>./target/release/solochain-template-node --help\n</code></pre>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/connect-multiple-nodes/#review-the-node-messages","title":"Review the Node Messages","text":"<p>Upon successful node startup, the terminal displays messages detailing network operations and information relevant to the running node. This output includes details about the chain specification, system data, network status, and other crucial parameters. You should see output similar to this:</p> ./target/release/solochain-template-node \\ --base-path /tmp/alice \\ --chain local \\ --alice \\ --port 30333 \\ --rpc-port 9945 \\ --node-key 0000000000000000000000000000000000000000000000000000000000000001 \\ --validator  2024-09-10 08:35:43 Substrate Node 2024-09-10 08:35:43 \u270c\ufe0f version 0.1.0-8599efc46ae 2024-09-10 08:35:43 \u2764\ufe0f by Parity Technologies &lt;admin@parity.io&gt;, 2017-2024 2024-09-10 08:35:43 \ud83d\udccb Chain specification: Local Testnet 2024-09-10 08:35:43 \ud83c\udff7 Node name: Alice 2024-09-10 08:35:43 \ud83d\udc64 Role: AUTHORITY 2024-09-10 08:35:43 \ud83d\udcbe Database: RocksDb at /tmp/alice/chains/local_testnet/db/full 2024-09-10 08:35:43 \ud83d\udd28 Initializing Genesis block/state (state: 0x074c\u202627bd, header-hash: 0x850f\u2026951f) 2024-09-10 08:35:43 \ud83d\udc74 Loading GRANDPA authority set from genesis on what appears to be first startup. 2024-09-10 08:35:43 Using default protocol ID \"sup\" because none is configured in the chain specs 2024-09-10 08:35:43 \ud83c\udff7 Local node identity is: 12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp 2024-09-10 08:35:43 Running libp2p network backend 2024-09-10 08:35:43 \ud83d\udcbb Operating system: macos 2024-09-10 08:35:43 \ud83d\udcbb CPU architecture: aarch64 2024-09-10 08:35:43 \ud83d\udce6 Highest known block at #0 2024-09-10 08:35:43 \u303d\ufe0f Prometheus exporter started at 127.0.0.1:9615 2024-09-10 08:35:43 Running JSON-RPC server: addr=127.0.0.1:9945, allowed origins=[\"http://localhost:*\", \"http://127.0.0.1:*\", \"https://localhost:*\", \"https://127.0.0.1:*\", \"https://polkadot.js.org\"] 2024-09-10 08:35:48 \ud83d\udca4 Idle (0 peers), best: #0 (0x850f\u2026951f), finalized #0 (0x850f\u2026951f), \u2b07 0 \u2b06 0 <p>Pay particular attention to the following key messages:</p> <ul> <li> <p>Genesis block initialization:</p> <pre><code>2024-09-10 08:35:43 \ud83d\udd28 Initializing Genesis block/state (state: 0x074c\u202627bd, header-hash: 0x850f\u2026951f)\n</code></pre> <p>This message identifies the initial state or genesis block used by the node. When starting subsequent nodes, ensure these values match.</p> </li> <li> <p>Node identity:</p> <pre><code>2024-09-10 08:35:43 \ud83c\udff7  Local node identity is: 12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp\n</code></pre> <p>This string uniquely identifies the node. It's determined by the <code>--node-key</code> used to start the node with the Alice account. Use this identifier when connecting additional nodes to the network.</p> </li> <li> <p>Network status:</p> <pre><code>2024-09-10 08:35:48 \ud83d\udca4 Idle (0 peers), best: #0 (0x850f\u2026951f), finalized #0 (0x850f\u2026951f), \u2b07 0 \u2b06 0\n</code></pre> <p>This message indicates that:</p> <ul> <li>No other nodes are currently in the network</li> <li>No blocks are being produced</li> <li>Block production will commence once another node joins the network</li> </ul> </li> </ul>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/connect-multiple-nodes/#add-a-second-node-to-the-network","title":"Add a Second Node to the Network","text":"<p>After successfully running the first node with the Alice account keys, you can expand the network by adding a second node using the Bob account. This process involves connecting to the existing network using the running node as a reference point. The commands are similar to those used for the first node, with some key differences to ensure proper network integration.</p> <p>To add a node to the running blockchain:</p> <ol> <li> <p>Open a new terminal shell on your computer</p> </li> <li> <p>Navigate to the root directory where you compiled the Polkadot SDK Solochain Template</p> </li> <li> <p>Clear any existing chain data for the new node:</p> <pre><code>./target/release/solochain-template-node purge-chain --base-path /tmp/bob --chain local -y\n</code></pre> <p>Note</p> <p>The <code>-y</code> flag automatically confirms the operation without prompting.</p> </li> <li> <p>Start the second local blockchain node using the Bob account:     <pre><code>./target/release/solochain-template-node \\\n--base-path /tmp/bob \\\n--chain local \\\n--bob \\\n--port 30334 \\\n--rpc-port 9946 \\\n--node-key 0000000000000000000000000000000000000000000000000000000000000002 \\\n--validator \\\n--bootnodes /ip4/127.0.0.1/tcp/30333/p2p/12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp\n</code></pre></p> <p>Key differences in this command:</p> <ul> <li> <p>Unique paths and ports - to avoid conflicts on the same machine, different values are used for:</p> <ul> <li><code>--base-path</code> - set to <code>/tmp/bob</code></li> <li><code>--port</code> - set to <code>30334</code></li> <li><code>--rpc-port</code> - set to <code>9946</code></li> </ul> </li> <li> <p>Bootnode specification - the <code>--bootnodes</code> option is crucial for network discovery:</p> <ul> <li>Format - <code>/ip4/127.0.0.1/tcp/30333/p2p/12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp</code></li> <li>Components:<ul> <li><code>ip4</code> - indicates IPv4 format</li> <li><code>127.0.0.1</code> - IP address of the running node (localhost in this case)</li> <li><code>tcp</code> - specifies TCP for peer-to-peer communication</li> <li><code>30333</code> - port number for peer-to-peer TCP traffic</li> <li><code>12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp</code> - unique identifier of the Alice node</li> </ul> </li> </ul> </li> </ul> </li> </ol>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/connect-multiple-nodes/#verify-blocks-are-produced-and-finalized","title":"Verify Blocks are Produced and Finalized","text":"<p>After starting the second node, both nodes should connect as peers and commence block production.</p> <p>Follow these steps to verify that blocks are being produced and finalized:</p> <ol> <li> <p>Observe the output in the terminal of the first node (Alice):</p> <p> ... 2024-09-10 09:04:57 discovered: 12D3KooWHdiAxVd8uMQR1hGWXccidmfCwLqcMpGwR6QcTP6QRMuD /ip4/192.168.1.4/tcp/30334 2024-09-10 09:04:58 \ud83d\udca4 Idle (0 peers), best: #0 (0x850f\u2026951f), finalized #0 (0x850f\u2026951f), \u2b07 0.3kiB/s \u2b06 0.3kiB/s 2024-09-10 09:05:00 \ud83d\ude4c Starting consensus session on top of parent 0x850ffab4827cb0297316cbf01fc7c2afb954c5124f366f25ea88bfd19ede951f (#0) 2024-09-10 09:05:00 \ud83c\udf81 Prepared block for proposing at 1 (2 ms) [hash: 0xe21a305e6647b0b0c6c73ba31a49ae422809611387fadb7785f68d0a1db0b52d; parent_hash: 0x850f\u2026951f; extrinsics (1): [0x0c18\u202608d8] 2024-09-10 09:05:00 \ud83d\udd16 Pre-sealed block for proposal at 1. Hash now 0x75bbb026db82a4d6ff88b96f952a29e15dac2b7df24d4cb95510945e2bede82d, previously 0xe21a305e6647b0b0c6c73ba31a49ae422809611387fadb7785f68d0a1db0b52d. 2024-09-10 09:05:00 \ud83c\udfc6 Imported #1 (0x850f\u2026951f \u2192 0x75bb\u2026e82d) 2024-09-10 09:05:03 \ud83d\udca4 Idle (1 peers), best: #1 (0x75bb\u2026e82d), finalized #0 (0x850f\u2026951f), \u2b07 0.7kiB/s \u2b06 0.8kiB/s 2024-09-10 09:05:06 \ud83c\udfc6 Imported #2 (0x75bb\u2026e82d \u2192 0x774d\u2026a176) 2024-09-10 09:05:08 \ud83d\udca4 Idle (1 peers), best: #2 (0x774d\u2026a176), finalized #0 (0x850f\u2026951f), \u2b07 0.6kiB/s \u2b06 0.5kiB/s 2024-09-10 09:05:12 \ud83d\ude4c Starting consensus session on top of parent 0x774dec6bff7a27c38e21106a5a7428ae5d50b991f39cda7c0aa3c0c9322da176 (#2) 2024-09-10 09:05:12 \ud83c\udf81 Prepared block for proposing at 3 (0 ms) [hash: 0x10bb4589a7a13bac657219a9ff06dcef8d55e46a4275aa287a966b5648a6d486; parent_hash: 0x774d\u2026a176; extrinsics (1): [0xdcd4\u2026b5ec] 2024-09-10 09:05:12 \ud83d\udd16 Pre-sealed block for proposal at 3. Hash now 0x01e080f4b8421c95d0033aac7310b36972fdeef7c6025f8a153c436c1bb214ee, previously 0x10bb4589a7a13bac657219a9ff06dcef8d55e46a4275aa287a966b5648a6d486. 2024-09-10 09:05:12 \ud83c\udfc6 Imported #3 (0x774d\u2026a176 \u2192 0x01e0\u202614ee) 2024-09-10 09:05:13 \ud83d\udca4 Idle (1 peers), best: #3 (0x01e0\u202614ee), finalized #0 (0x850f\u2026951f), \u2b07 0.6kiB/s \u2b06 0.6kiB/s 2024-09-10 09:05:18 \ud83c\udfc6 Imported #4 (0x01e0\u202614ee \u2192 0xe176\u20260430) 2024-09-10 09:05:18 \ud83d\udca4 Idle (1 peers), best: #4 (0xe176\u20260430), finalized #1 (0x75bb\u2026e82d), \u2b07 0.6kiB/s \u2b06 0.6kiB/s </p> <p>Key information in this output:</p> <ul> <li>Second node discovery - <code>discovered: 12D3KooWHdiAxVd8uMQR1hGWXccidmfCwLqcMpGwR6QcTP6QRMuD</code></li> <li>Peer count - <code>1 peers</code></li> <li>Block production - <code>best: #4 (0xe176\u20260430)</code></li> <li>Block finalization - <code>finalized #1 (0x75bb\u2026e82d)</code></li> </ul> </li> <li> <p>Check the terminal of the second node (Bob) for similar output</p> </li> <li> <p>Shut down one node using <code>Control-C</code> in its terminal. Observe the remaining node's output:</p> <p> 2024-09-10 09:10:03 \ud83d\udca4 Idle (1 peers), best: #51 (0x0dd6\u2026e763), finalized #49 (0xb70a\u20261fc0), \u2b07 0.7kiB/s \u2b06 0.6kiB/s 2024-09-10 09:10:08 \ud83d\udca4 Idle (0 peers), best: #52 (0x2c40\u2026a50e), finalized #49 (0xb70a\u20261fc0), \u2b07 0.3kiB/s \u2b06 0.3kiB/s </p> <p>Note that the peer count drops to zero, and block production stops.</p> </li> <li> <p>Shut down the second node using <code>Control-C</code> in its terminal</p> </li> <li> <p>Clean up chain state from the simulated network by using the <code>purge-chain</code> subcommand:</p> <ul> <li>For Alice's node:     <pre><code>./target/release/solochain-template-node purge-chain \\\n--base-path /tmp/alice \\\n--chain local \\\n-y\n</code></pre></li> <li>For Bob's node:     <pre><code>./target/release/solochain-template-node purge-chain \\\n--base-path /tmp/bob \\\n--chain local \\\n-y\n</code></pre></li> </ul> </li> </ol>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/launch-a-local-solochain/","title":"Launch a Local Solochain","text":""},{"location":"tutorials/polkadot-sdk/parachains/local-chain/launch-a-local-solochain/#introduction","title":"Introduction","text":"<p>Polkadot SDK offers a versatile and extensible blockchain development framework, enabling you to create custom blockchains tailored to your specific application or business requirements. </p> <p>This tutorial guides you through compiling and launching a standalone blockchain node using the Polkadot SDK Solochain Template. You'll create a fully functional chain that operates independently, without connections to a relay chain or parachain.</p> <p>The node template provides a pre-configured, functional single-node blockchain you can run in your local development environment. It includes several key components, such as user accounts and account balances.</p> <p>These predefined elements allow you to experiment with common blockchain operations without requiring initial template modifications. In this tutorial, you will:</p> <ul> <li>Build and start a local blockchain node using the node template</li> <li>Explore how to use a front-end interface to:<ul> <li>View information about blockchain activity</li> <li>Submit a transaction</li> </ul> </li> </ul> <p>By the end of this tutorial, you'll have a working local solochain and understand how to interact with it, setting the foundation for further customization and development.</p>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/launch-a-local-solochain/#prerequisites","title":"Prerequisites","text":"<p>To get started with the node template, you'll need to have the following set up on your development machine first:</p> <ul> <li>Rust installation - the node template is written in Rust, so you'll need to have it installed and configured on your system. Refer to the Installation guide for step-by-step instructions on setting up your development environment</li> </ul>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/launch-a-local-solochain/#compile-a-node","title":"Compile a Node","text":"<p>The Polkadot SDK Solochain Template provides a ready-to-use development environment for building using the Polkadot SDK. Follow these steps to compile the node:</p> <ol> <li> <p>Clone the node template repository:     <pre><code>git clone -b v0.0.2 https://github.com/paritytech/polkadot-sdk-solochain-template\n</code></pre></p> <p>Note</p> <p>This tutorial uses version <code>v0.0.2</code> of the Polkadot SDK Solochain Template. Make sure you're using the correct version to match these instructions.</p> </li> <li> <p>Navigate to the root of the node template directory:     <pre><code>cd polkadot-sdk-solochain-template\n</code></pre></p> </li> <li> <p>Compile the node template:     <pre><code>cargo build --release\n</code></pre></p> <p>Note</p> <p>Initial compilation may take several minutes, depending on your machine specifications. Always use the <code>--release</code> flag to build optimized, production-ready artifacts.</p> </li> <li> <p>Upon successful compilation, you should see output similar to:      cargo build --release Compiling solochain-template-node Finished <code>release</code> profile [optimized] target(s) in 27.12s </p> </li> </ol>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/launch-a-local-solochain/#start-the-local-node","title":"Start the Local Node","text":"<p>After successfully compiling your node, you can run it and produce blocks. This process will start your local blockchain and allow you to interact. Follow these steps to launch your node in development mode:</p> <ol> <li> <p>In the terminal where you compiled your node, start it in development mode:     <pre><code>./target/release/solochain-template-node --dev\n</code></pre>     The <code>--dev</code> option does the following:</p> <ul> <li>Specifies that the node runs using the predefined development chain specification</li> <li>Deletes all active data (keys, blockchain database, networking information) when stopped</li> <li>Ensures a clean working state each time you restart the node</li> </ul> </li> <li> <p>Verify that your node is running by reviewing the terminal output. You should see something similar to:      ./target/release/solochain-template-node --dev 2024-09-09 08:32:42 Substrate Node 2024-09-09 08:32:42 \u270c\ufe0f version 0.1.0-8599efc46ae 2024-09-09 08:32:42 \u2764\ufe0f by Parity Technologies &lt;admin@parity.io&gt;, 2017-2024 2024-09-09 08:32:42 \ud83d\udccb Chain specification: Development 2024-09-09 08:32:42 \ud83c\udff7 Node name: light-boundary-7850 2024-09-09 08:32:42 \ud83d\udc64 Role: AUTHORITY 2024-09-09 08:32:42 \ud83d\udcbe Database: RocksDb at /var/folders/x0/xl_kjddj3ql3bx7752yr09hc0000gn/T/substrate0QH9va/chains/dev/db/full 2024-09-09 08:32:42 \ud83d\udd28 Initializing Genesis block/state (state: 0xc2a0\u202616ba, header-hash: 0x0eef\u2026935d) 2024-09-09 08:32:42 \ud83d\udc74 Loading GRANDPA authority set from genesis on what appears to be first startup. 2024-09-09 08:32:42 Using default protocol ID \"sup\" because none is configured in the chain specs 2024-09-09 08:32:42 \ud83c\udff7 Local node identity is: 12D3KooWPhdUzf66di1SuuRFgjkFs6X8jm3Uj2ss5ri31WuVAbgt 2024-09-09 08:32:42 Running libp2p network backend 2024-09-09 08:32:42 \ud83d\udcbb Operating system: macos 2024-09-09 08:32:42 \ud83d\udcbb CPU architecture: aarch64 2024-09-09 08:32:42 \ud83d\udce6 Highest known block at #0 2024-09-09 08:32:42 \u303d\ufe0f Prometheus exporter started at 127.0.0.1:9615 2024-09-09 08:32:42 Running JSON-RPC server: addr=127.0.0.1:9944, allowed origins=[\"*\"] 2024-09-09 08:32:47 \ud83d\udca4 Idle (0 peers), best: #0 (0x0eef\u2026935d), finalized #0 (0x0eef\u2026935d), \u2b07 0 \u2b06 0 2024-09-09 08:32:48 \ud83d\ude4c Starting consensus session on top of parent 0x0eef4a08ef90cc04d01864514dc5cb2bd822314309b770b49b0177f920ed935d (#0) 2024-09-09 08:32:48 \ud83c\udf81 Prepared block for proposing at 1 (1 ms) [hash: 0xc14630b76907550bef9037dcbfafa2b25c8dc763495f30d9e36ad4b93b673b36; parent_hash: 0x0eef\u2026935d; extrinsics (1): [0xbcd8\u20265132] 2024-09-09 08:32:48 \ud83d\udd16 Pre-sealed block for proposal at 1. Hash now 0xcb3d2f28bc73807dac5cf19fcfb2ac6d7e922756da9d41ca0c9dadbd0e45265b, previously 0xc14630b76907550bef9037dcbfafa2b25c8dc763495f30d9e36ad4b93b673b36. 2024-09-09 08:32:48 \ud83c\udfc6 Imported #1 (0x0eef\u2026935d \u2192 0xcb3d\u2026265b) ... </p> </li> <li> <p>Confirm that your blockchain is producing new blocks by checking if the number after <code>finalized</code> is increasing      ... 2024-09-09 08:32:47 \ud83d\udca4 Idle (0 peers), best: #0 (0x0eef\u2026935d), finalized #0 (0x0eef\u2026935d), \u2b07 0 \u2b06 0 ... 2024-09-09 08:32:52 \ud83d\udca4 Idle (0 peers), best: #1 (0xcb3d\u2026265b), finalized #0 (0x0eef\u2026935d), \u2b07 0 \u2b06 0 ... 2024-09-09 08:32:57 \ud83d\udca4 Idle (0 peers), best: #2 (0x16d7\u2026083f), finalized #0 (0x0eef\u2026935d), \u2b07 0 \u2b06 0 ... 2024-09-09 08:33:02 \ud83d\udca4 Idle (0 peers), best: #3 (0xe6a4\u20262cc4), finalized #1 (0xcb3d\u2026265b), \u2b07 0 \u2b06 0 ... </p> <p>Note</p> <p>The details of the log output will be explored in a later tutorial. For now, knowing that your node is running and producing blocks is sufficient.</p> </li> </ol>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/launch-a-local-solochain/#interact-with-the-node","title":"Interact with the Node","text":"<p>When running the template node, it's accessible by default at:</p> <p><pre><code>ws://localhost:9944\n</code></pre> To interact with your node using the Polkadot.js Apps interface, follow these steps:</p> <ol> <li> <p>Open Polkadot.js Apps in your web browser and click the network icon in the top left corner</p> <p></p> </li> <li> <p>Connect to your local node:</p> <ol> <li>Scroll to the bottom and select Development</li> <li>Choose Custom</li> <li>Enter <code>ws://localhost:9944</code> in the input field</li> <li>Click the Switch button</li> </ol> <p></p> </li> <li> <p>Verify connection:</p> <ul> <li>Once connected, you should see solochain-template-runtime in the top left corner</li> <li>The interface will display information about your local blockchain</li> </ul> <p></p> </li> </ol> <p>You are now connected to your local node and can now interact with it through the Polkadot.js Apps interface. This tool enables you to explore blocks, execute transactions, and interact with your blockchain's features. For in-depth guidance on using the interface effectively, refer to the Polkadot.js Guides available on the Polkadot Wiki.</p>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/launch-a-local-solochain/#stop-the-node","title":"Stop the Node","text":"<p>When you're done exploring your local node, you can stop it to remove any state changes you've made. Since you started the node with the <code>--dev</code> option, stopping the node will purge all persistent block data, allowing you to start fresh the next time.</p> <p>To stop the local node:</p> <ol> <li>Return to the terminal window where the node output is displayed</li> <li>Press <code>Control-C</code> to stop the running process</li> <li>Verify that your terminal returns to the prompt in the <code>polkadot-sdk-solochain-template</code> directory</li> </ol>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/spin-your-nodes/","title":"Spin Your Own Nodes","text":""},{"location":"tutorials/polkadot-sdk/parachains/local-chain/spin-your-nodes/#introduction","title":"Introduction","text":"<p>This tutorial guides you through launching a private blockchain network with a small, trusted set of validators. In decentralized networks, consensus ensures that nodes agree on the state of the data at any given time. The Polkadot SDK Solochain Template uses Aura (Authority Round), a proof of authority consensus mechanism where a fixed set of trusted validators produces blocks in a round-robin fashion. This approach offers an easy way to launch a standalone blockchain with a predefined list of validators.</p> <p>You'll learn how to generate keys, create a custom chain specification, and start a two-node blockchain network using the Aura consensus mechanism.</p>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/spin-your-nodes/#prerequisites","title":"Prerequisites","text":"<p>Before starting this tutorial, ensure you have:</p> <ul> <li>Installed and configured Rust on your system. For detailed instructions on installing Rust and setting up your development environment, refer to the Installation guide</li> <li>Completed the Launch a Local Solochain tutorial and have the Polkadot SDK Solochain Template installed on your local machine</li> <li>Experience using predefined accounts to start nodes on a single computer, as described in the Connect Multiple Nodes guide</li> </ul>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/spin-your-nodes/#generate-an-account-and-keys","title":"Generate an Account and Keys","text":"<p>Unlike in the Connect Multiple Nodes tutorial, where you used predefined accounts and keys to start peer nodes, this tutorial requires you to generate unique secret keys for your validator nodes. It's crucial to understand that each participant is responsible for generating and managing their own unique set of keys in a real blockchain network.</p> <p>This process of generating your own keys serves several important purposes:</p> <ul> <li>It enhances the security of your network by ensuring that each node has its own unique cryptographic identity</li> <li>It simulates a more realistic blockchain environment where participants don't share key information</li> <li>It helps you understand the process of key generation, which is a fundamental skill in blockchain operations</li> </ul> <p>There are a couple of Polkadot Wiki articles that may help you better understand the different signing algorithms used in this tutorial. See the Keypairs and Signing section to learn about the sr25519 and ed25519 signing algorithms. Refer to the Keys section to learn more about the different types of keys used in the ecosystem.</p>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/spin-your-nodes/#key-generation-options","title":"Key Generation Options","text":"<p>There are several ways you can generate keys. The available methods are:</p> <ul> <li><code>solochain-template-node key</code> subcommand - the most straightforward method for developers working directly with the node is to use the integrated key generation feature. Using the <code>key</code> subcommand, you can generate keys directly from your node's command line interface. This method ensures compatibility with your chain and is convenient for quick setup and testing</li> <li>subkey - it is a powerful standalone utility specifically designed for Polkadot SDK-based chains. It offers advanced options for key generation, including support for different key types such as <code>ed25519</code> and <code>sr25519</code>. This tool allows fine-grained control over the key generation process</li> <li>Third-party key generation utilities - various tools developed by the community</li> </ul>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/spin-your-nodes/#generate-local-keys-with-the-node-template","title":"Generate Local Keys with the Node Template","text":"<p>Best practices for key generation:</p> <ul> <li>Whenever possible, use an air-gapped computer, meaning never connected to the internet, when generating keys for a production blockchain</li> <li>If an air-gapped computer is not an option, disconnect from the internet before generating keys for any public or private blockchain not under your control</li> </ul> <p>For this tutorial, however, you'll use the <code>solochain-template-node</code> command-line options to generate random keys locally while remaining connected to the internet. This method is suitable for learning and testing purposes.</p> <p>Follow these steps to generate your keys:</p> <ol> <li> <p>Navigate to the root directory where you compiled the node template</p> </li> <li> <p>Generate a random secret phrase and Sr25519 keys. Enter a password when prompted:</p> <pre><code>./target/release/solochain-template-node key generate \\\n--scheme Sr25519 \\\n--password-interactive\n</code></pre> <p>The command will output information about the generated keys similar to the following:</p> <p> ./target/release/solochain-template-node key generate \\ --scheme Sr25519 \\ --password-interactive Key password: Secret phrase: digital width rely long insect blind usual name oyster easy steak spend Network ID: substrate Secret seed: 0xc52405d0b45dd856cbf1371f3b33fbde20cb76bf6ee440d12ea15f7ed17cca0a Public key (hex): 0xea23fa399c6bd91af3d7ea2d0ad46c48aff818b285342d9aaf15b3172270e914 Account ID: 0xea23fa399c6bd91af3d7ea2d0ad46c48aff818b285342d9aaf15b3172270e914 Public key (SS58): 5HMhkSHpD4XcibjbU9ZiGemLpnsTUzLsG5JhQJQEcxp3KJaW SS58 Address: 5HMhkSHpD4XcibjbU9ZiGemLpnsTUzLsG5JhQJQEcxp3KJaW </p> <p>Note the Sr25519 public key for the account (SS58 format). This key will be used for producing blocks with Aura. In this example, the Sr25519 public key for the account is <code>5HMhkSHpD4XcibjbU9ZiGemLpnsTUzLsG5JhQJQEcxp3KJaW</code>.</p> </li> <li> <p>Use the generated secret phrase to derive keys using the Ed25519 signature scheme. </p> <pre><code>./target/release/solochain-template-node key inspect \\\n--scheme Ed25519 \\\n--password-interactive \\\n</code></pre> <p>When prompted for a Key password, enter the same password you used in the previous step</p> <p>Note</p> <p>Replace <code>INSERT_SECRET_PHRASE</code> with the secret phrase generated in step 2.</p> <p>The command will output information about the generated keys similar to the following:</p> <p> ./target/release/solochain-template-node key inspect \\ --scheme Ed25519 \\ --password-interactive \\ Key password: Secret phrase: digital width rely long insect blind usual name oyster easy steak spend Network ID: substrate Secret seed: 0xc52405d0b45dd856cbf1371f3b33fbde20cb76bf6ee440d12ea15f7ed17cca0a Public key (hex): 0xc9c2cd111f98f2bf78bab6787449fc007dd7f2a5d02f099919f7fb50ade97dd6 Account ID: 0xc9c2cd111f98f2bf78bab6787449fc007dd7f2a5d02f099919f7fb50ade97dd6 Public key (SS58): 5GdFMFbXy24uz8mFZroFUgdBkY2pq6igBNGAq9tsBfEZRSzP SS58 Address: 5GdFMFbXy24uz8mFZroFUgdBkY2pq6igBNGAq9tsBfEZRSzP </p> <p>The Ed25519 key you've generated is crucial for block finalization using the <code>grandpa</code> consensus algorithm. The Ed25519 public key for the account is <code>5GdFMFbXy24uz8mFZroFUgdBkY2pq6igBNGAq9tsBfEZRSzP</code>.</p> </li> </ol>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/spin-your-nodes/#generate-a-second-set-of-keys","title":"Generate a Second Set of Keys","text":"<p>In this tutorial, the private network will consist of two nodes, meaning you'll need two distinct sets of keys. You have several options for generating this second set of keys:</p> <ul> <li>Use the keys from one of the predefined accounts</li> <li>Follow the steps from the previous section, but use a different identity on your local machine to create a new key pair</li> <li>Derive a child key pair to simulate a second identity on your local machine</li> </ul> <p>For this tutorial, the second set of keys will be:</p> <ul> <li>Sr25519 (for Aura) - <code>5Df9bvnbqKNR8S1W2Uj5XSpJCKUomyymwCGf6WHKyoo3GDev</code></li> <li>Ed25519 (for Grandpa) - <code>5DJRQQWEaJart5yQnA6gnKLYKHLdpX6V4vHgzAYfNPT2NNuW</code></li> </ul>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/spin-your-nodes/#create-a-custom-chain-specification","title":"Create a Custom Chain Specification","text":"<p>After generating key pairs for your blockchain, the next step is creating a custom chain specification. You will share this specification with trusted validators participating in your network.</p> <p>To enable others to participate in your blockchain, ensure that each participant generates their own key pair. Once you collect the keys from all network participants, you can create a custom chain specification to replace the default local one.</p> <p>In this tutorial, you'll modify the local chain specification to create a custom version for a two-node network. The same process can be used to add more nodes if you have the necessary keys.</p>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/spin-your-nodes/#steps-to-create-a-custom-chain-specification","title":"Steps to Create a Custom Chain Specification","text":"<ol> <li> <p>Open a terminal and navigate to the root directory of your compiled node template</p> </li> <li> <p>Export the local chain specification:</p> <pre><code>./target/release/solochain-template-node build-spec \\\n--disable-default-bootnode \\\n--chain local &gt; customSpec.json\n</code></pre> </li> <li> <p>Preview the <code>customSpec.json</code> file:</p> <ul> <li> <p>Preview first fields:</p> <p><pre><code>head customSpec.json\n</code></pre> head customSpec.json <pre>\n{\n    \"name\": \"Local Testnet\",\n    \"id\": \"local_testnet\",\n    \"chainType\": \"Local\",\n    \"bootNodes\": [],\n    \"telemetryEndpoints\": null,\n    \"protocolId\": null,\n    \"properties\": null,\n    \"codeSubstitutes\": { ... },\n    \"genesis\": { ... }\n}\n</pre> </p> </li> <li> <p>Preview last fields:     <pre><code>tail -n 78 customSpec.json\n</code></pre> tail -n 78 customSpec.json <pre>\n{\n    \"patch\": {\n        \"aura\": {\n            \"authorities\": [\n                \"5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY\",\n                \"5FHneW46xGXgs5mUiveU4sbTyGBzmstUspZC92UhjJM694ty\"\n            ]\n        },\n        \"balances\": {\n            \"balances\": [\n                [\n                    \"5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY\",\n                    1152921504606846976\n                ],\n                [\n                    \"5FHneW46xGXgs5mUiveU4sbTyGBzmstUspZC92UhjJM694ty\",\n                    1152921504606846976\n                ],\n                [\n                    \"5FLSigC9HGRKVhB9FiEo4Y3koPsNmBmLJbpXg2mp1hXcS59Y\",\n                    1152921504606846976\n                ],\n                [\n                    \"5DAAnrj7VHTznn2AWBemMuyBwZWs6FNFjdyVXUeYum3PTXFy\",\n                    1152921504606846976\n                ],\n                [\n                    \"5HGjWAeFDfFCWPsjFQdVV2Msvz2XtMktvgocEZcCj68kUMaw\",\n                    1152921504606846976\n                ],\n                [\n                    \"5CiPPseXPECbkjWCa6MnjNokrgYjMqmKndv2rSnekmSK2DjL\",\n                    1152921504606846976\n                ],\n                [\n                    \"5GNJqTPyNqANBkUVMN1LPPrxXnFouWXoe2wNSmmEoLctxiZY\",\n                    1152921504606846976\n                ],\n                [\n                    \"5HpG9w8EBLe5XCrbczpwq5TSXvedjrBGCwqxK1iQ7qUsSWFc\",\n                    1152921504606846976\n                ],\n                [\n                    \"5Ck5SLSHYac6WFt5UZRSsdJjwmpSZq85fd5TRNAdZQVzEAPT\",\n                    1152921504606846976\n                ],\n                [\n                    \"5HKPmK9GYtE1PSLsS1qiYU9xQ9Si1NcEhdeCq9sw5bqu4ns8\",\n                    1152921504606846976\n                ],\n                [\n                    \"5FCfAonRZgTFrTd9HREEyeJjDpT397KMzizE6T3DvebLFE7n\",\n                    1152921504606846976\n                ],\n                [\n                    \"5CRmqmsiNFExV6VbdmPJViVxrWmkaXXvBrSX8oqBT8R9vmWk\",\n                    1152921504606846976\n                ]\n            ]\n        },\n        \"grandpa\": {\n            \"authorities\": [\n                [\n                    \"5FA9nQDVg267DEd8m1ZypXLBnvN7SFxYwV7ndqSYGiN9TTpu\",\n                    1\n                ],\n                [\n                    \"5GoNkf6WdbxCFnPdAnYYQyCjAKPJgLNxXwPjwTh6DGg6gN3E\",\n                    1\n                ]\n            ]\n        },\n        \"sudo\": {\n            \"key\": \"5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY\"\n        }\n    }\n}  \n    </pre> </p> <p>This command will display fields that include configuration details for pallets, such as sudo and balances, as well as the validator settings for the Aura and Grandpa keys.</p> </li> </ul> </li> <li> <p>Edit <code>customSpec.json</code>:</p> <ol> <li> <p>Update the <code>name</code> field: <pre><code>\"name\": \"My Custom Testnet\",\n</code></pre></p> </li> <li> <p>Add Sr25519 addresses for each validator in the authorities array to the <code>aura</code> field to specify the nodes with authority to create blocks:</p> <pre><code>\"aura\": {\n  \"authorities\": [\n    \"5HMhkSHpD4XcibjbU9ZiGemLpnsTUzLsG5JhQJQEcxp3KJaW\",\n    \"5Df9bvnbqKNR8S1W2Uj5XSpJCKUomyymwCGf6WHKyoo3GDev\"\n  ]\n},\n</code></pre> </li> <li> <p>Add Ed25519 addresses for each validator in the authorities array to the <code>grandpa</code> field to specify the nodes with the authority to finalize blocks. Include a voting weight (typically <code>1</code>) for each validator to define their voting power:</p> <pre><code>\"grandpa\": {\n  \"authorities\": [\n    [\n      \"5GdFMFbXy24uz8mFZroFUgdBkY2pq6igBNGAq9tsBfEZRSzP\",\n      1\n    ],\n    [\n      \"5DJRQQWEaJart5yQnA6gnKLYKHLdpX6V4vHgzAYfNPT2NNuW\",\n      1\n    ]\n  ]\n},\n</code></pre> </li> </ol> </li> <li> <p>Save and close <code>customSpec.json</code></p> </li> </ol>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/spin-your-nodes/#convert-chain-specification-to-raw-format","title":"Convert Chain Specification to Raw Format","text":"<p>After creating your custom chain specification, the next crucial step is converting it to a raw format. This process is essential because the raw format includes encoded storage keys that nodes use to reference data in their local storage. By distributing a raw chain specification, you ensure that each node in the network stores data using the same storage keys, which is vital for maintaining data integrity and facilitating network synchronization.</p> <p>To convert your chain specification to the raw format, follow these steps:</p> <ol> <li> <p>Navigate to the root directory where you compiled the node template</p> </li> <li> <p>Run the following command to convert the <code>customSpec.json</code> chain specification to the raw format and save it as <code>customSpecRaw.json</code>:</p> <pre><code>./target/release/solochain-template-node build-spec \\\n--chain=customSpec.json \\\n--raw \\\n--disable-default-bootnode &gt; customSpecRaw.json\n</code></pre> </li> </ol>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/spin-your-nodes/#add-keys-to-the-keystore","title":"Add Keys to the Keystore","text":"<p>To enable block production and finalization, you need to add two types of keys to the keystore for each node in the network:</p> <ul> <li><code>aura</code> authority keys for block production</li> <li><code>grandpa</code> authority keys for block finalization</li> </ul> <p>Follow these steps for each node in your network:</p> <ol> <li> <p>Open a terminal and navigate to the root directory where you compiled the node template</p> </li> <li> <p>Insert the <code>aura</code> secret key:</p> <pre><code>./target/release/solochain-template-node key insert \\\n--base-path /tmp/node01 \\\n--chain customSpecRaw.json \\\n--scheme Sr25519 \\\n--suri \"INSERT_SECRET_PHRASE\" \\\n--password-interactive \\\n--key-type aura\n</code></pre> <p>Note</p> <p>Replace <code>INSERT_SECRET_PHRASE</code> with the secret phrase or seed you generated earlier. When prompted, enter the password you used to generate the keys.</p> </li> <li> <p>Insert the <code>grandpa</code> secret key:     <pre><code>./target/release/solochain-template-node key insert \\\n--base-path /tmp/node01 \\\n--chain customSpecRaw.json \\\n--scheme Ed25519 \\\n--suri \"INSERT_SECRET_PHRASE\" \\\n--password-interactive \\\n--key-type gran\n</code></pre></p> <p>Note</p> <p>Use the same secret phrase or seed and password as in step 2.</p> </li> <li> <p>Verify that your keys are in the keystore by running the following command:</p> <pre><code>ls /tmp/node01/chains/local_testnet/keystore\n</code></pre> <p>You should see output similar to:</p> <p> ls /tmp/node01/chains/local_testnet/keystore 61757261ea23fa399c6bd91af3d7ea2d0ad46c48aff818b285342d9aaf15b3172270e914 6772616ec9c2cd111f98f2bf78bab6787449fc007dd7f2a5d02f099919f7fb50ade97dd6 </p> </li> </ol>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/spin-your-nodes/#start-the-first-node","title":"Start the First Node","text":"<p>Before starting the first node, it's crucial to generate a network key. This key ensures that the node's identity remains consistent, allowing other nodes to connect to it reliably as a bootnode for synchronization.</p> <p>To generate a network key, run the following command:</p> <pre><code>./target/release/solochain-template-node key \\\ngenerate-node-key --base-path /tmp/node01\n</code></pre> <p>Note</p> <p>This command generates a network key and stores it in the same base path used for storing the <code>aura</code> and <code>grandpa</code> keys.</p> <p>After generating the network key, start the first node using your custom chain specification with the following command:</p> <pre><code>./target/release/solochain-template-node \\\n--base-path /tmp/node01 \\\n--chain ./customSpecRaw.json \\\n--port 30333 \\\n--rpc-port 9945 \\\n--validator \\\n--name MyNode01 \\\n--password-interactive\n</code></pre> <p>Upon execution, you should see output similar to the following:</p> ./target/release/solochain-template-node \\ --base-path /tmp/node01 \\ --chain ./customSpecRaw.json \\ --port 30333 \\ --rpc-port 9945 \\ --validator \\ --name MyNode01 \\ --password-interactive 2024-09-12 11:18:46 Substrate Node 2024-09-12 11:18:46 \u270c\ufe0f version 0.1.0-8599efc46ae 2024-09-12 11:18:46 \u2764\ufe0f by Parity Technologies &lt;admin@parity.io&gt;, 2017-2024 2024-09-12 11:18:46 \ud83d\udccb Chain specification: My Custom Testnet 2024-09-12 11:18:46 \ud83c\udff7 Node name: MyNode01 2024-09-12 11:18:46 \ud83d\udc64 Role: AUTHORITY 2024-09-12 11:18:46 \ud83d\udcbe Database: RocksDb at /tmp/node01/chains/local_testnet/db/full 2024-09-12 11:18:46 Using default protocol ID \"sup\" because none is configured in the chain specs 2024-09-12 11:18:46 \ud83c\udff7 Local node identity is: 12D3KooWSbaPxmb2tWLgkQVoJdxzpBPTd9dQPmKiJfsvtP753Rg1 2024-09-12 11:18:46 Running libp2p network backend 2024-09-12 11:18:46 \ud83d\udcbb Operating system: macos 2024-09-12 11:18:46 \ud83d\udcbb CPU architecture: aarch64 2024-09-12 11:18:46 \ud83d\udce6 Highest known block at #0 2024-09-12 11:18:46 \u303d\ufe0f Prometheus exporter started at 127.0.0.1:9615 2024-09-12 11:18:46 Running JSON-RPC server: addr=127.0.0.1:9945, allowed origins=[\"http://localhost:*\", \"http://127.0.0.1:*\", \"https://localhost:*\", \"https://127.0.0.1:*\", \"https://polkadot.js.org\"] 2024-09-12 11:18:51 \ud83d\udca4 Idle (0 peers), best: #0 (0x850f\u2026951f), finalized #0 (0x850f\u2026951f), \u2b07 0 \u2b06 0 <p>After starting the first node, you'll notice:</p> <ul> <li>The node is running with the custom chain specification (\"My Custom Testnet\")</li> <li>The local node identity is displayed (<code>12D3KooWSbaPxmb2tWLgkQVoJdxzpBPTd9dQPmKiJfsvtP753Rg1</code> in this example). This identity is crucial for other nodes to connect to this one</li> <li>The node is currently idle with 0 peers, as it's the only node in the network at this point</li> <li>No blocks are being produced. Block production will commence once another node joins the network</li> </ul>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/spin-your-nodes/#add-more-nodes","title":"Add More Nodes","text":"<p>Block finalization requires at least two-thirds of the validators. In this example network configured with two validators, block finalization can only start after the second node has been added.</p> <p>Before starting additional nodes, ensure you've properly configured their keys as described in the Add Keys to the Keystore section. For this node, the keys should be stored under the <code>/tmp/node02</code> base path.</p> <p>To add a second validator to the private network, run the following command:</p> <pre><code>./target/release/solochain-template-node \\\n--base-path /tmp/node02 \\\n--chain ./customSpecRaw.json \\\n--port 30334 \\\n--rpc-port 9946 \\\n--validator \\\n--name MyNode02 \\\n--bootnodes /ip4/127.0.0.1/tcp/30333/p2p/12D3KooWSbaPxmb2tWLgkQVoJdxzpBPTd9dQPmKiJfsvtP753Rg1 \\\n--unsafe-force-node-key-generation \\\n--password-interactive\n</code></pre> <p>Key points about this command:</p> <ul> <li>It uses a different <code>base-path</code> and name to identify this as the second validator</li> <li>The <code>--chain</code> option specifies the same chain specification file used for the first node</li> <li>The <code>--bootnodes</code> option is crucial. It should contain the local node identifier from the first node in the network</li> <li>The <code>--unsafe-force-node-key-generation</code> parameter forces the generation of a new node key if one doesn't exist. For non-bootnode validators (like this second node and any subsequent nodes), it's less critical if the key changes because they won't be used as bootnodes. However, for consistency and best practices, it's recommended to generate and maintain a stable node key for all validators once the network is set up</li> </ul> <p>After both nodes have added their keys to their respective keystores (under <code>/tmp/node01</code> and <code>/tmp/node02</code>) and been run, you should see:</p> <ul> <li>The same genesis block and state root hashes on both nodes</li> <li>Each node showing one peer</li> <li>Block proposals being produced </li> <li>After a few seconds, new blocks being finalized on both nodes</li> </ul> <p>If successful, you should see logs similar to the following on both nodes:</p> 2024-09-12 15:37:05 \ud83d\udca4 Idle (0 peers), best: #0 (0x8af7\u202653fd), finalized #0 (0x8af7\u202653fd), \u2b07 0 \u2b06 0 2024-09-12 15:37:08 discovered: 12D3KooWMaL5zqYiMnVikaYCGF65fKekSPqXGgyz92eRcqcnfpey /ip4/192.168.1.2/tcp/30334 2024-09-12 15:37:10 \ud83d\udca4 Idle (1 peers), best: #0 (0x8af7\u202653fd), finalized #0 (0x8af7\u202653fd), \u2b07 0.6kiB/s \u2b06 0.6kiB/s 2024-09-12 15:37:12 \ud83d\ude4c Starting consensus session on top of parent 0x8af7c72457d437486fe697b4a11ef42b26c8b4448836bdb2220495aea39f53fd (#0) 2024-09-12 15:37:12 \ud83c\udf81 Prepared block for proposing at 1 (6 ms) [hash: 0xb97cb3a4a62f0cb320236469d8e1e13227a15138941f3c9819b6b78f91986262; parent_hash: 0x8af7\u202653fd; extrinsics (1): [0x1ef4\u2026eecb] 2024-09-12 15:37:12 \ud83d\udd16 Pre-sealed block for proposal at 1. Hash now 0x05115677207265f22c6d428fb00b65a0e139c866c975913431ddefe291124f04, previously 0xb97cb3a4a62f0cb320236469d8e1e13227a15138941f3c9819b6b78f91986262. 2024-09-12 15:37:12 \ud83c\udfc6 Imported #1 (0x8af7\u202653fd \u2192 0x0511\u20264f04) 2024-09-12 15:37:15 \ud83d\udca4 Idle (1 peers), best: #1 (0x0511\u20264f04), finalized #0 (0x8af7\u202653fd), \u2b07 0.5kiB/s \u2b06 0.6kiB/s 2024-09-12 15:37:18 \ud83c\udfc6 Imported #2 (0x0511\u20264f04 \u2192 0x17a7\u2026a1fd) 2024-09-12 15:37:20 \ud83d\udca4 Idle (1 peers), best: #2 (0x17a7\u2026a1fd), finalized #0 (0x8af7\u202653fd), \u2b07 0.6kiB/s \u2b06 0.5kiB/s 2024-09-12 15:37:24 \ud83d\ude4c Starting consensus session on top of parent 0x17a77a8799bd58c7b82ca6a1e3322b38e7db574ee6c92fbcbc26bbe5214da1fd (#2) 2024-09-12 15:37:24 \ud83c\udf81 Prepared block for proposing at 3 (1 ms) [hash: 0x74d78266b1ac2514050ced3f34fbf98a28c6a2856f49dbe8b44686440a45f879; parent_hash: 0x17a7\u2026a1fd; extrinsics (1): [0xe35f\u20268d48] 2024-09-12 15:37:24 \ud83d\udd16 Pre-sealed block for proposal at 3. Hash now 0x12cc1e9492988cfd3ffe4a6eb3186b1abb351a12a97809f7bae4a7319e177dee, previously 0x74d78266b1ac2514050ced3f34fbf98a28c6a2856f49dbe8b44686440a45f879. 2024-09-12 15:37:24 \ud83c\udfc6 Imported #3 (0x17a7\u2026a1fd \u2192 0x12cc\u20267dee) 2024-09-12 15:37:25 \ud83d\udca4 Idle (1 peers), best: #3 (0x12cc\u20267dee), finalized #1 (0x0511\u20264f04), \u2b07 0.5kiB/s \u2b06 0.6kiB/s"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/upgrade-a-running-network/","title":"Upgrade a Running Network","text":""},{"location":"tutorials/polkadot-sdk/parachains/local-chain/upgrade-a-running-network/#introduction","title":"Introduction","text":"<p>One of the key advantages of the Polkadot SDK development framework is its support for forkless upgrades to the blockchain runtime, which forms the core logic of the chain. Unlike many other blockchains, where introducing new features or improving existing ones often requires a hard fork, Polkadot SDK enables seamless upgrades even when introducing breaking changes\u2014without disrupting the network's operation.</p> <p>Polkadot SDK's design incorporates the runtime directly into the blockchain's state, allowing participants to upgrade the runtime by calling the <code>set_code</code> function within a transaction. This mechanism ensures that updates are validated using the blockchain's consensus and cryptographic guarantees, allowing runtime logic to be updated or extended without forking the chain or requiring a new blockchain client.</p> <p>In this tutorial, you'll learn how to upgrade the runtime of a Polkadot SDK-based blockchain without stopping the network or creating a fork. </p> <p>You'll make the following changes to a running network node's runtime:</p> <ul> <li>Increase the <code>spec_version</code></li> <li>Add the Utility pallet</li> <li>Increase the minimum balance for network accounts</li> </ul> <p>By the end of this tutorial, you\u2019ll have the skills to upgrade the runtime and submit a transaction to deploy the modified runtime on a live network.</p>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/upgrade-a-running-network/#prerequisites","title":"Prerequisites","text":"<p>Before starting this tutorial, ensure you meet the following requirements:</p> <ul> <li>Installed and configured Rust on your system. Refer to the Installation guide for detailed instructions on installing Rust and setting up your development environment</li> <li>Completed the Launch a Local Solochain tutorial and have the Polkadot SDK Solochain Template installed on your machine</li> </ul>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/upgrade-a-running-network/#start-the-node","title":"Start the Node","text":"<p>To demonstrate how to update a running node, you first need to start the local node with the current runtime.</p> <ol> <li> <p>Navigate to the root directory where you compiled the Polkadot SDK Solochain Template</p> </li> <li> <p>Start the local node in development mode by running the following command:     <pre><code>./target/release/solochain-template-node --dev\n</code></pre></p> <p>Note</p> <p>Keep the node running throughout this tutorial. You can modify and re-compile the runtime without stopping or restarting the node.</p> </li> <li> <p>Connect to your node using the same steps outlined in the Interact with the Node section. Once connected, you\u2019ll notice the node template is using the default version, <code>100</code>, displayed in the upper left</p> <p></p> </li> </ol>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/upgrade-a-running-network/#modify-the-runtime","title":"Modify the Runtime","text":""},{"location":"tutorials/polkadot-sdk/parachains/local-chain/upgrade-a-running-network/#add-the-utility-pallet-to-the-dependencies","title":"Add the Utility Pallet to the Dependencies","text":"<p>First, you'll update the <code>Cargo.toml</code> file to include the Utility pallet as a dependency for the runtime. Follow these steps:</p> <ol> <li> <p>Open the <code>runtime/Cargo.toml</code> file and locate the <code>[dependencies]</code> section. Add the Utility pallet by inserting the following line:</p> <pre><code>pallet-utility = { version = \"37.0.0\", default-features = false}\n</code></pre> <p>Your <code>[dependencies]</code> section should now look something like this:</p> <pre><code>[dependencies]\ncodec = { features = [\"derive\"], workspace = true }\nscale-info = { features = [\"derive\", \"serde\"], workspace = true }\nframe-support = { features = [\"experimental\"], workspace = true }\n...\npallet-utility = { version = \"37.0.0\", default-features = false }\n</code></pre> </li> <li> <p>In the <code>[features]</code> section, add the Utility pallet to the <code>std</code> feature list by including:     <pre><code>[features]\ndefault = [\"std\"]\nstd = [\n    \"codec/std\",\n    \"scale-info/std\",\n    \"frame-executive/std\",\n    ...\n    \"pallet-utility/std\",\n]\n</code></pre></p> </li> <li> <p>Save the changes and close the <code>Cargo.toml</code> file</p> </li> </ol>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/upgrade-a-running-network/#update-the-runtime-configuration","title":"Update the Runtime Configuration","text":"<p>You'll now modify the <code>runtime/src/lib.rs</code> file to integrate the Utility pallet and make other necessary changes. In this section, you'll configure the Utility pallet by implementing its <code>Config</code> trait, update the runtime macro to include the new pallet, adjust the <code>EXISTENTIAL_DEPOSIT</code> value, and increment the runtime version.</p>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/upgrade-a-running-network/#configure-the-utility-pallet","title":"Configure the Utility Pallet","text":"<p>To configure the Utility pallet, take the following steps:</p> <ol> <li> <p>Implement the <code>Config</code> trait for the Utility pallet:</p> <pre><code>...\n/// Configure the pallet-template in pallets/template\nimpl pallet_template::Config for Runtime {\n    ...\n}\n\n// Add here after all the other pallets implementations\nimpl pallet_utility::Config for Runtime {\n    type RuntimeEvent = RuntimeEvent;\n    type RuntimeCall = RuntimeCall;\n    type PalletsOrigin = OriginCaller;\n    type WeightInfo = pallet_utility::weights::SubstrateWeight&lt;Runtime&gt;;\n}\n...\n</code></pre> </li> <li> <p>Locate the <code>#[frame_support::runtime]</code> macro and add the Utility pallet:</p> <pre><code> // Create the runtime by composing the FRAME pallets that were previously configured\n #[frame_support::runtime]\n mod runtime {\n     ...\n     // Include the custom logic from the pallet-template in the runtime\n     #[runtime::pallet_index(7)]\n     pub type TemplateModule = pallet_template;\n\n     #[runtime::pallet_index(8)]\n     pub type Utility = pallet_utility;\n     ...\n }\n</code></pre> </li> </ol>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/upgrade-a-running-network/#update-existential-deposit-value","title":"Update Existential Deposit Value","text":"<p>To update the <code>EXISTENTIAL_DEPOSIT</code> in the Balances pallet, locate the constant and set the value to <code>1000</code>:</p> <pre><code>...\n/// Existential deposit\npub const EXISTENTIAL_DEPOSIT: u128 = 1000;\n...\n</code></pre> <p>Note</p> <p>This change increases the minimum balance required for accounts to remain active. No accounts with balances between <code>500</code> and <code>1000</code> will be removed. For account removal, a storage migration is needed. See Storage Migration for details.</p>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/upgrade-a-running-network/#update-runtime-version","title":"Update Runtime Version","text":"<p>Locate the <code>runtime_version</code> macro and increment the <code>spec_version</code> field from <code>100</code> to <code>101</code>:</p> <pre><code>#[sp_version::runtime_version]\npub const VERSION: RuntimeVersion = RuntimeVersion {\n    spec_name: create_runtime_str!(\"solochain-template-runtime\"),\n    impl_name: create_runtime_str!(\"solochain-template-runtime\"),\n    authoring_version: 1,\n    spec_version: 101,\n    impl_version: 1,\n    apis: RUNTIME_API_VERSIONS,\n    transaction_version: 1,\n    state_version: 1,\n};\n</code></pre>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/upgrade-a-running-network/#recompile-the-runtime","title":"Recompile the Runtime","text":"<p>Once you've made all the necessary changes, recompile the runtime by running:</p> <pre><code>cargo build --release\n</code></pre> <p>The build artifacts will be output to the <code>target/release</code> directory. The Wasm build artifacts can be found in the <code>target/release/wbuild/solochain-template-runtime</code> directory. You should see the following files:</p> <ul> <li><code>solochain_template_runtime.compact.compressed.wasm</code></li> <li><code>solochain_template_runtime.compact.wasm</code></li> <li><code>solochain_template_runtime.wasm</code></li> </ul>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/upgrade-a-running-network/#execute-the-runtime-upgrade","title":"Execute the Runtime Upgrade","text":"<p>Now that you've generated the Wasm artifact for your modified runtime, it's time to upgrade the running network. This process involves submitting a transaction to load the new runtime logic.</p>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/upgrade-a-running-network/#understand-runtime-upgrades","title":"Understand Runtime Upgrades","text":""},{"location":"tutorials/polkadot-sdk/parachains/local-chain/upgrade-a-running-network/#authorization-with-sudo","title":"Authorization with Sudo","text":"<p>In production networks, runtime upgrades typically require community approval through governance. For this tutorial, the Sudo pallet will be used to simplify the process. The Sudo pallet allows a designated account (usually Alice in development environments) to perform privileged operations, including runtime upgrades.</p>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/upgrade-a-running-network/#resource-accounting","title":"Resource Accounting","text":"<p>Runtime upgrades use the <code>set_code</code> extrinsic, which is designed to consume an entire block's resources. This design prevents other transactions from executing on different runtime versions within the same block. The <code>set_code</code> extrinsic is classified as an Operational call, one of the variants of the <code>DispatchClass</code> enum. This classification means it:</p> <ul> <li>Can use a block's entire weight limit</li> <li>Receives maximum priority</li> <li>Is exempt from transaction fees</li> </ul> <p>To bypass resource accounting safeguards, the <code>sudo_unchecked_weight</code> extrinsic will be used. This allows you to specify a weight of zero, ensuring the upgrade process has unlimited time to complete.</p>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/upgrade-a-running-network/#perform-the-upgrade","title":"Perform the Upgrade","text":"<p>Follow these steps to update your network with the new runtime:</p> <ol> <li> <p>Open Polkadot.js Apps in your web browser and make sure you are connected to your local node</p> </li> <li> <p>Navigate to the Developer dropdown and select the Extrinsics option</p> <p></p> </li> <li> <p>Construct the <code>set_code</code> extrinsic call:</p> <ol> <li>Select the <code>sudo</code> pallet</li> <li>Choose the <code>sudoUncheckedWeight</code> extrinsic</li> <li>Select the <code>system</code> pallet</li> <li>Choose the <code>setCode</code> extrinsic</li> <li> <p>Fill in the parameters:</p> <ul> <li> <p><code>code</code> - the new runtime code</p> <p>Note</p> <p>You can click the file upload toggle to upload a file instead of copying the hex string value.</p> </li> <li> <p><code>weight</code> - leave both parameters set to the default value of <code>0</code></p> </li> </ul> </li> <li> <p>Click on Submit Transaction</p> </li> </ol> <p></p> </li> <li> <p>Review the transaction details and click Sign and Submit to confirm the transaction</p> <p></p> </li> </ol>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/upgrade-a-running-network/#verify-the-upgrade","title":"Verify the Upgrade","text":""},{"location":"tutorials/polkadot-sdk/parachains/local-chain/upgrade-a-running-network/#runtime-version-change","title":"Runtime Version Change","text":"<p>Verify that the runtime version of your blockchain has been updated successfully. Follow these steps to ensure the upgrade was applied:</p> <ol> <li> <p>Navigate to the Network dropdown and select the Explorer option</p> <p></p> </li> <li> <p>After the transaction is included in a block, check:</p> <ol> <li>There has been a successful <code>sudo.Sudid</code> event</li> <li>The indicator shows that the runtime version is now <code>101</code></li> </ol> <p></p> </li> </ol>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/upgrade-a-running-network/#utility-pallet-addition","title":"Utility Pallet Addition","text":"<p>In the Extrinsics section, you should see that the Utility pallet has been added as an option.</p> <p></p>"},{"location":"tutorials/polkadot-sdk/parachains/local-chain/upgrade-a-running-network/#existential-deposit-update","title":"Existential Deposit Update","text":"<p>Check the updated existential deposit value on your blockchain. Follow these steps to query and verify the new value:</p> <ol> <li> <p>Navigate to the Developer dropdown and select the Chain State option</p> <p></p> </li> <li> <p>Query the existential deposit value</p> <ol> <li>Click on the Constants tab </li> <li>Select the <code>balances</code> pallet</li> <li>Choose the <code>existentialDeposit</code> constant</li> <li>Click the + button to execute the query</li> <li>Check the existential deposit value</li> </ol> <p></p> </li> </ol>"},{"location":"tutorials/polkadot-sdk/system-chains/","title":"System Chains Tutorials","text":"<p>Explore step-by-step tutorials on how to integrate with system parachains, such as the Asset Hub chain, within the Polkadot ecosystem.</p>"},{"location":"tutorials/polkadot-sdk/system-chains/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"tutorials/polkadot-sdk/system-chains/asset-hub/","title":"Asset Hub Tutorials","text":"<p>Learn how to manage assets on Asset Hub, including registering local and foreign assets and converting between different asset types.</p>"},{"location":"tutorials/polkadot-sdk/system-chains/asset-hub/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"tutorials/polkadot-sdk/system-chains/asset-hub/asset-conversion/","title":"Convert Assets on Asset Hub","text":""},{"location":"tutorials/polkadot-sdk/system-chains/asset-hub/asset-conversion/#introduction","title":"Introduction","text":"<p>Asset Conversion is an Automated Market Maker (AMM) utilizing Uniswap V2 logic and implemented as a pallet on Polkadot's Asset Hub. For more details about this feature, please visit the Asset Conversion on Asset Hub wiki page.</p> <p>This guide will provide detailed information about the key functionalities offered by the Asset Conversion pallet on Asset Hub, including:</p> <ul> <li>Creating a liquidity pool</li> <li>Adding liquidity to a pool</li> <li>Swapping assets</li> <li>Withdrawing liquidity from a pool</li> </ul>"},{"location":"tutorials/polkadot-sdk/system-chains/asset-hub/asset-conversion/#prerequisites","title":"Prerequisites","text":"<p>Before converting assets on Asset Hub, you must ensure you have:</p> <ul> <li>Access to the Polkadot.js Apps interface and a connection with the intended blockchain</li> <li>A funded wallet containing the assets you wish to convert and enough available funds to cover the transaction fees</li> <li>An asset registered on Asset Hub that you want to convert. If you haven't created an asset on Asset Hub yet, refer to the Register a Local Asset or Register a Foreign Asset documentation to create an asset.</li> </ul>"},{"location":"tutorials/polkadot-sdk/system-chains/asset-hub/asset-conversion/#creating-a-liquidity-pool","title":"Creating a Liquidity Pool","text":"<p>If an asset on Asset Hub does not have an existing liquidity pool, the first step is to create one.</p> <p>The asset conversion pallet provides the <code>createPool</code> extrinsic to create a new liquidity pool, creating an empty liquidity pool and a new <code>LP token</code> asset.</p> <p>Note</p> <p>A testing token with the asset ID <code>1112</code> and the name <code>PPM</code> was created for this example.</p> <p>As stated in the Test Environment Setup section, this tutorial is based on the assumption that you have an instance of Polkadot Asset Hub running locally. Therefore, the demo liquidity pool will be created between DOT and PPM tokens. However, the same steps can be applied to any other asset on Asset Hub.</p> <p>From the Asset Hub perspective, the Multilocation that identifies the PPM token is the following:</p> <pre><code>{\n  parents: 0,\n  interior: {\n    X2: [{ PalletInstance: 50 }, { GeneralIndex: 1112 }]\n  }\n}\n</code></pre> <p>Note</p> <p>The <code>PalletInstance</code> value of <code>50</code> represents the Assets pallet on Asset Hub. The <code>GeneralIndex</code> value of <code>1112</code> is the PPM asset's asset ID.</p> <p>To create the liquidity pool, you can follow these steps:</p> <ol> <li> <p>Navigate to the Extrinsics section on the Polkadot.js Apps interface</p> <ol> <li>Select Developer from the top menu</li> <li>Click on Extrinsics from the dropdown menu</li> </ol> <p></p> </li> <li> <p>Choose the <code>AssetConversion</code> pallet and click on the <code>createPool</code> extrinsic</p> <ol> <li>Select the <code>AssetConversion</code> pallet</li> <li>Choose the <code>createPool</code> extrinsic from the list of available extrinsics</li> </ol> <p></p> </li> <li> <p>Fill in the required fields:</p> <ol> <li> <p><code>asset1</code> - the Multilocation of the first asset in the pool. In this case, it is the DOT token, which the following Multilocation represents:</p> <pre><code>{\n  parents: 0,\n  interior: 'Here'\n}\n</code></pre> </li> <li> <p><code>asset2</code> - the second asset's Multilocation within the pool. This refers to the PPM token, which the following Multilocation identifies:  </p> <pre><code>{\n  parents: 0,\n  interior: {\n    X2: [{ PalletInstance: 50 }, { GeneralIndex: 1112 }]\n  }\n}\n</code></pre> </li> <li> <p>Click on Submit Transaction to create the liquidity pool</p> </li> </ol> <p></p> </li> </ol> <p>Signing and submitting the transaction triggers the creation of the liquidity pool. To verify the new pool's creation, check the Explorer section on the Polkadot.js Apps interface and ensure that the <code>PoolCreated</code> event was emitted.</p> <p></p> <p>As the preceding image shows, the <code>lpToken</code> ID created for this pool is 19. This ID is essential to identify the liquidity pool and associated LP tokens.</p>"},{"location":"tutorials/polkadot-sdk/system-chains/asset-hub/asset-conversion/#adding-liquidity-to-a-pool","title":"Adding Liquidity to a Pool","text":"<p>The <code>addLiquidity</code> extrinsic allows users to provide liquidity to a pool of two assets. Users specify their preferred amounts for both assets and minimum acceptable quantities. The function determines the best asset contribution, which may vary from the amounts desired but won't fall below the specified minimums. Providers receive liquidity tokens representing their pool portion in return for their contribution.</p> <p>To add liquidity to a pool, follow these steps:</p> <ol> <li> <p>Navigate to the Extrinsics section on the Polkadot.js Apps interface</p> <ol> <li>Select Developer from the top menu</li> <li>Click on Extrinsics from the dropdown menu</li> </ol> <p></p> </li> <li> <p>Choose the <code>assetConversion</code> pallet and click on the <code>addLiquidity</code> extrinsic</p> <ol> <li>Select the <code>assetConversion</code> pallet</li> <li>Choose the <code>addLiquidity</code> extrinsic from the list of available extrinsics</li> </ol> <p></p> </li> <li> <p>Fill in the required fields:</p> <ol> <li> <p><code>asset1</code> - the Multilocation of the first asset in the pool. In this case, it is the DOT token, which the following Multilocation represents:</p> <pre><code>{\n  parents: 0,\n  interior: 'Here'\n}\n</code></pre> </li> <li> <p><code>asset2</code> - the second asset's Multilocation within the pool. This refers to the PPM token, which the following Multilocation identifies:</p> <pre><code>{\n  parents: 0,\n  interior: {\n    X2: [{ PalletInstance: 50 }, { GeneralIndex: 1112 }]\n  }\n}\n</code></pre> </li> <li> <p><code>amount1Desired</code> - the amount of the first asset that will be contributed to the pool</p> </li> <li><code>amount2Desired</code> - the quantity of the second asset intended for pool contribution</li> <li><code>amount1Min</code> - the minimum amount of the first asset that will be contributed</li> <li><code>amount2Min</code> - the lowest acceptable quantity of the second asset for contribution</li> <li><code>mintTo</code> - the account to which the liquidity tokens will be minted</li> <li>Click on Submit Transaction to add liquidity to the pool</li> </ol> <p></p> <p>Warning</p> <p>Ensure that the appropriate amount of tokens provided has been minted previously and is available in your account before adding liquidity to the pool.</p> <p>In this case, the liquidity provided to the pool is between DOT tokens and PPM tokens with the asset ID 1112 on Polkadot Asset Hub. The intention is to provide liquidity for 1 DOT token (<code>u128</code> value of 1000000000000 as it has 10 decimals) and 1 PPM token (<code>u128</code> value of 1000000000000 as it also has 10 decimals).</p> </li> </ol> <p>Signing and submitting the transaction adds liquidity to the pool. To verify the liquidity addition, check the Explorer section on the Polkadot.js Apps interface and ensure that the <code>LiquidityAdded</code> event was emitted.</p> <p></p>"},{"location":"tutorials/polkadot-sdk/system-chains/asset-hub/asset-conversion/#swapping-assets","title":"Swapping Assets","text":""},{"location":"tutorials/polkadot-sdk/system-chains/asset-hub/asset-conversion/#swapping-from-an-exact-amount-of-tokens","title":"Swapping From an Exact Amount of Tokens","text":"<p>The asset conversion pallet enables users to exchange a specific quantity of one asset for another in a designated liquidity pool by swapping them for an exact amount of tokens. It guarantees the user will receive at least a predetermined minimum amount of the second asset. This function increases trading predictability and allows users to conduct asset exchanges with confidence that they are assured a minimum return.</p> <p>To swap assets for an exact amount of tokens, follow these steps:</p> <ol> <li> <p>Navigate to the Extrinsics section on the Polkadot.js Apps interface</p> <ol> <li>Select Developer from the top menu</li> <li>Click on Extrinsics from the dropdown menu</li> </ol> <p></p> </li> <li> <p>Choose the <code>AssetConversion</code> pallet and click on the <code>swapExactTokensForTokens</code> extrinsic</p> <ol> <li>Select the <code>AssetConversion</code> pallet</li> <li>Choose the <code>swapExactTokensForTokens</code> extrinsic from the list of available extrinsics</li> </ol> <p></p> </li> <li> <p>Fill in the required fields:</p> <ol> <li> <p><code>path:Vec&lt;StagingXcmV3MultiLocation&gt;</code> - an array of Multilocations representing the path of the swap. The first and last elements of the array are the input and output assets, respectively. In this case, the path consists of two elements:</p> <ul> <li> <p><code>0: StagingXcmV3MultiLocation</code> - the Multilocation of the first asset in the pool. In this case, it is the DOT token, which the following Multilocation represents:</p> <pre><code>{\n  parents: 0,\n  interior: 'Here'\n}\n</code></pre> </li> <li> <p><code>1: StagingXcmV3MultiLocation</code> - the second asset's Multilocation within the pool. This refers to the PPM token, which the following Multilocation identifies:</p> <pre><code>{\n  parents: 0,\n  interior: {\n    X2: [{ PalletInstance: 50 }, { GeneralIndex: 1112 }]\n  }\n}\n</code></pre> </li> </ul> </li> <li> <p><code>amountOut</code> - the exact amount of the second asset that the user wants to receive</p> </li> <li><code>amountInMax</code> - the maximum amount of the first asset that the user is willing to swap</li> <li><code>sendTo</code> - the account to which the swapped assets will be sent</li> <li><code>keepAlive</code> - a boolean value that determines whether the pool should be kept alive after the swap</li> <li>Click on Submit Transaction to swap assets for an exact amount of tokens</li> </ol> <p></p> <p>Warning</p> <p>Ensure that the appropriate amount of tokens provided has been minted previously and is available in your account before adding liquidity to the pool.</p> <p>In this case, the intention is to swap 0.01 DOT token (u128 value of 100000000000 as it has 10 decimals) for 0.04 PPM token (u128 value of 400000000000 as it also has 10 decimals).</p> </li> </ol> <p>Signing and submitting the transaction will execute the swap. To verify execution, check the Explorer section on the Polkadot.js Apps interface and make sure that the <code>SwapExecuted</code> event was emitted.</p> <p></p>"},{"location":"tutorials/polkadot-sdk/system-chains/asset-hub/asset-conversion/#swapping-to-an-exact-amount-of-tokens","title":"Swapping To an Exact Amount of Tokens","text":"<p>Conversely, the Asset Conversion pallet comes with a function that allows users to trade a variable amount of one asset to acquire a precise quantity of another. It ensures that users stay within a set maximum of the initial asset to obtain the desired amount of the second asset. This provides a method to control transaction costs while achieving the intended result.</p> <p>To swap assets for an exact amount of tokens, follow these steps:</p> <ol> <li> <p>Navigate to the Extrinsics section on the Polkadot.js Apps interface</p> <ol> <li>Select Developer from the top menu</li> <li>Click on Extrinsics from the dropdown menu</li> </ol> <p></p> </li> <li> <p>Choose the <code>AssetConversion</code> pallet and click on the <code>swapTokensForExactTokens</code> extrinsic:</p> <ol> <li>Select the <code>AssetConversion</code> pallet</li> <li>Choose the <code>swapTokensForExactTokens</code> extrinsic from the list of available extrinsics</li> </ol> <p></p> </li> <li> <p>Fill in the required fields:</p> <ol> <li> <p><code>path:Vec&lt;StagingXcmV3MultiLocation\\&gt;</code> - an array of Multilocations representing the path of the swap. The first and last elements of the array are the input and output assets, respectively. In this case, the path consists of two elements:</p> <ul> <li> <p><code>0: StagingXcmV3MultiLocation</code> - the Multilocation of the first asset in the pool. In this case, it is the PPM token, which the following Multilocation represents:</p> <pre><code>{\n  parents: 0,\n  interior: {\n    X2: [{ PalletInstance: 50 }, { GeneralIndex: 1112 }]\n  }\n}\n</code></pre> </li> <li> <p><code>1: StagingXcmV3MultiLocation</code> - the second asset's Multilocation within the pool. This refers to the DOT token, which the following Multilocation identifies:</p> <pre><code>{\n  parents: 0,\n  interior: 'Here'\n}\n</code></pre> </li> </ul> </li> <li> <p><code>amountOut</code> - the exact amount of the second asset that the user wants to receive</p> </li> <li><code>amountInMax</code> - the maximum amount of the first asset that the user is willing to swap</li> <li><code>sendTo</code> - the account to which the swapped assets will be sent</li> <li><code>keepAlive</code> - a boolean value that determines whether the pool should be kept alive after the swap</li> <li>Click on Submit Transaction to swap assets for an exact amount of tokens</li> </ol> <p></p> <p>Warning</p> <p>Before swapping assets, ensure that the tokens provided have been minted previously and are available in your account.</p> <p>In this case, the intention is to swap 0.01 DOT token (<code>u128</code> value of 100000000000 as it has ten decimals) for 0.04 PPM token (<code>u128</code> value of 400000000000 as it also has ten decimals).</p> </li> </ol> <p>Signing and submitting the transaction will execute the swap. To verify execution, check the Explorer section on the Polkadot.js Apps interface and make sure that the <code>SwapExecuted</code> event was emitted.</p> <p></p>"},{"location":"tutorials/polkadot-sdk/system-chains/asset-hub/asset-conversion/#withdrawing-liquidity-from-a-pool","title":"Withdrawing Liquidity from a Pool","text":"<p>The Asset Conversion pallet provides the <code>removeLiquidity</code> extrinsic to remove liquidity from a pool. This function allows users to withdraw the liquidity they offered from a pool, returning the original assets. When calling this function, users specify the number of liquidity tokens (representing their share in the pool) they wish to burn. They also set minimum acceptable amounts for the assets they expect to receive back. This mechanism ensures that users can control the minimum value they receive, protecting against unfavorable price movements during the withdrawal process.</p> <p>To withdraw liquidity from a pool, follow these steps:</p> <ol> <li> <p>Navigate to the Extrinsics section on the Polkadot.js Apps interface</p> <ol> <li>Select Developer from the top menu</li> <li>Click on Extrinsics from the dropdown menu</li> </ol> <p></p> </li> <li> <p>Choose the <code>AssetConversion</code> pallet and click on the <code>remove_liquidity</code> extrinsic</p> <ol> <li>Select the <code>AssetConversion</code> pallet</li> <li>Choose the <code>removeLiquidity</code> extrinsic from the list of available extrinsics</li> </ol> <p></p> </li> <li> <p>Fill in the required fields:</p> <ol> <li> <p><code>asset1</code> - the Multilocation of the first asset in the pool. In this case, it is the DOT token, which the following Multilocation represents:</p> <pre><code>{\n  parents: 0,\n  interior: 'Here'\n}\n</code></pre> </li> <li> <p><code>asset2</code> - the second asset's Multilocation within the pool. This refers to the PPM token, which the following Multilocation identifies:</p> <pre><code>{\n  parents: 0,\n  interior: {\n    X2: [{ PalletInstance: 50 }, { GeneralIndex: 1112 }]\n  }\n}\n</code></pre> </li> <li> <p><code>lpTokenBurn</code> - the number of liquidity tokens to burn</p> </li> <li><code>amount1MinReceived</code> - the minimum amount of the first asset that the user expects to receive</li> <li><code>amount2MinReceived</code> - the minimum quantity of the second asset the user expects to receive</li> <li><code>withdrawTo</code> - the account to which the withdrawn assets will be sent</li> <li>Click on Submit Transaction to withdraw liquidity from the pool</li> </ol> <p></p> <p>Warning</p> <p>Ensure that the tokens provided have been minted previously and are available in your account before withdrawing liquidity from the pool.</p> <p>In this case, the intention is to withdraw 0.05 liquidity tokens from the pool, expecting to receive 0.004 DOT token (<code>u128</code> value of 40000000000 as it has 10 decimals) and 0.04 PPM token (<code>u128</code> value of 400000000000 as it also has 10 decimals).</p> </li> </ol> <p>Signing and submitting the transaction will initiate the withdrawal of liquidity from the pool. To verify the withdrawal, check the Explorer section on the Polkadot.js Apps interface and ensure that the <code>LiquidityRemoved</code> event was emitted.</p> <p></p>"},{"location":"tutorials/polkadot-sdk/system-chains/asset-hub/asset-conversion/#test-environment-setup","title":"Test Environment Setup","text":"<p>To test the Asset Conversion pallet, you can set up a local test environment to simulate different scenarios. This guide uses Chopsticks to spin up an instance of Polkadot Asset Hub. For further details on using Chopsticks, please refer to the Chopsticks documentation.</p> <p>To set up a local test environment, execute the following command:</p> <pre><code>npx @acala-network/chopsticks \\\n--config=https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/polkadot-asset-hub.yml\n</code></pre> <p>Note</p> <p>This command initiates a lazy fork of Polkadot Asset Hub, including the most recent block information from the network. For Kusama Asset Hub testing, simply switch out <code>polkadot-asset-hub.yml</code> with <code>kusama-asset-hub.yml</code> in the command.</p> <p>You now have a local Asset Hub instance up and running, ready for you to test various asset conversion procedures. The process here mirrors what you'd do on MainNet. After completing a transaction on TestNet, you can apply the same steps to convert assets on MainNet.</p>"},{"location":"tutorials/polkadot-sdk/system-chains/asset-hub/register-foreign-asset/","title":"Register a Foreign Asset on Asset Hub","text":""},{"location":"tutorials/polkadot-sdk/system-chains/asset-hub/register-foreign-asset/#introduction","title":"Introduction","text":"<p>As outlined in the Asset Hub Overview, Asset Hub supports two categories of assets: local and foreign. Local assets are created on the Asset Hub system parachain and are identified by integer IDs. On the other hand, foreign assets, which originate outside of Asset Hub, are recognized by Multilocations.</p> <p>When registering a foreign asset on Asset Hub, it's essential to notice that the process involves communication between two parachains. The Asset Hub parachain will be the destination of the foreign asset, while the source parachain will be the origin of the asset. The communication between the two parachains is facilitated by the Cross-Chain Message Passing (XCMP) protocol.</p> <p>This guide will take you through the process of registering a foreign asset on the Asset Hub parachain.</p>"},{"location":"tutorials/polkadot-sdk/system-chains/asset-hub/register-foreign-asset/#prerequisites","title":"Prerequisites","text":"<p>The Asset Hub parachain is one of the system parachains on a relay chain, such as Polkadot or Kusama. To interact with these parachains, you can use the Polkadot.js Apps interface for:</p> <ul> <li>Polkadot Asset Hub</li> <li>Kusama Asset Hub</li> </ul> <p>For testing purposes, you can also interact with the Asset Hub instance on the following test networks:</p> <ul> <li>Paseo Asset Hub</li> </ul> <p>Before you start, ensure that you have: </p> <ul> <li>Access to the Polkadot.js Apps interface, and you are connected to the desired chain</li> <li>A parachain that supports the XCMP protocol to interact with the Asset Hub parachain</li> <li>A funded wallet to pay for the transaction fees and subsequent registration of the foreign asset</li> </ul> <p>This guide will use Polkadot, its local Asset Hub instance, and the Astar parachain (<code>ID</code> 2006), as stated in the Test Environment Setup section. However, the process is the same for other relay chains and their respective Asset Hub parachain, regardless of the network you are using and the parachain owner of the foreign asset.</p>"},{"location":"tutorials/polkadot-sdk/system-chains/asset-hub/register-foreign-asset/#steps-to-register-a-foreign-asset","title":"Steps to Register a Foreign Asset","text":""},{"location":"tutorials/polkadot-sdk/system-chains/asset-hub/register-foreign-asset/#asset-hub","title":"Asset Hub","text":"<ol> <li> <p>Open the Polkadot.js Apps interface and connect to the Asset Hub parachain using the network selector in the top left corner </p> <ul> <li>Testing foreign asset registration is recommended on TestNet before proceeding to MainNet. If you haven't set up a local testing environment yet, consult the Environment setup guide. After setting up, connect to the Local Node (Chopsticks) at <code>ws://127.0.0.1:8000</code></li> <li>For live network operations, connect to the Asset Hub parachain. You can choose either Polkadot or Kusama Asset Hub from the dropdown menu, selecting your preferred RPC provider</li> </ul> </li> <li> <p>Navigate to the Extrinsics page</p> <ol> <li>Click on the Developer tab from the top navigation bar</li> <li>Select Extrinsics from the dropdown</li> </ol> <p></p> </li> <li> <p>Select the Foreign Assets pallet</p> <ol> <li>Select the <code>foreignAssets</code> pallet from the dropdown list</li> <li>Choose the <code>create</code> extrinsic</li> </ol> <p></p> </li> <li> <p>Fill out the required fields and click on the copy icon to copy the encoded call data to your clipboard. The fields to be filled are:</p> <ul> <li> <p>id - as this is a foreign asset, the ID will be represented by a Multilocation that reflects its origin. For this case, the Multilocation of the asset will be from the source parachain perspective:</p> <pre><code>{ parents: 1, interior: { X1: [{ Parachain: 2006 }] } }\n</code></pre> </li> <li> <p>admin - refers to the account that will be the admin of this asset. This account will be able to manage the asset, including updating its metadata. As the registered asset corresponds to a native asset of the source parachain, the admin account should be the sovereign account of the source parachain</p> Obtain the sovereign account <p>The sovereign account can be obtained through Substrate Utilities.</p> <p>Ensure that Sibling is selected and that the Para ID corresponds to the source parachain. In this case, since the guide follows the test setup stated in the Test Environment Setup section, the Para ID is <code>2006</code>.</p> <p></p> </li> <li> <p><code>minBalance</code> - the minimum balance required to hold this asset</p> </li> </ul> <p></p> Encoded call data <p>If you want an example of the encoded call data, you can copy the following: <pre><code>0x3500010100591f007369626cd6070000000000000000000000000000000000000000000000000000a0860100000000000000000000000000\n</code></pre></p> </li> </ol>"},{"location":"tutorials/polkadot-sdk/system-chains/asset-hub/register-foreign-asset/#source-parachain","title":"Source Parachain","text":"<ol> <li>Navigate to the Developer &gt; Extrinsics section</li> <li> <p>Create the extrinsic to register the foreign asset through XCM</p> <ol> <li>Paste the encoded call data copied in the previous step</li> <li>Click the Submit Transaction button</li> </ol> <p></p> <p>This XCM call involves withdrawing DOT from the sibling account of the parachain, using it to initiate an execution. The transaction will be carried out with XCM as the origin kind, and will be a hex-encoded call to create a foreign asset on Asset Hub for the specified parachain asset multilocation. Any surplus will be refunded, and the asset will be deposited into the sibling account.</p> <p>Warning</p> <p>Note that the sovereign account on the Asset Hub parachain must have a sufficient balance to cover the XCM <code>BuyExecution</code> instruction. If the account does not have enough balance, the transaction will fail.</p> Example of the encoded call data <p>If you want to have the whole XCM call ready to be copied, go to the Developer &gt; Extrinsics &gt; Decode section and paste the following hex-encoded call data: <pre><code>0x6300330003010100a10f030c000400010000070010a5d4e81300010000070010a5d4e80006030700b4f13501419ce03500010100591f007369626cd607000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n</code></pre></p> <p>Ensure to replace the encoded call data with the one you copied in the previous step.</p> </li> </ol> <p>After the transaction is successfully executed, the foreign asset will be registered on the Asset Hub parachain. </p>"},{"location":"tutorials/polkadot-sdk/system-chains/asset-hub/register-foreign-asset/#asset-registration-verification","title":"Asset Registration Verification","text":"<p>To confirm that a foreign asset has been successfully accepted and registered on the Asset Hub parachain, you can navigate to the <code>Network &gt; Explorer</code> section of the Polkadot.js Apps interface for Asset Hub. You should be able to see an event that includes the following details:</p> <p></p> <p>In the image above, the success field indicates whether the asset registration was successful.</p>"},{"location":"tutorials/polkadot-sdk/system-chains/asset-hub/register-foreign-asset/#test-environment-setup","title":"Test Environment Setup","text":"<p>To test the foreign asset registration process before deploying it on a live network, you can set up a local parachain environment. This guide uses Chopsticks to simulate that process. For more information on using Chopsticks, please refer to the Chopsticks documentation.</p> <p>To set up a test environment, run the following command:</p> <pre><code>npx @acala-network/chopsticks xcm \\\n--r polkadot \\\n--p polkadot-asset-hub \\\n--p astar\n</code></pre> <p>Note</p> <p>The above command will create a lazy fork of Polkadot as the relay chain, its Asset Hub instance, and the Astar parachain. The <code>xcm</code> parameter enables communication through the XCMP protocol between the relay chain and the parachains, allowing the registration of foreign assets on Asset Hub. For further information on the chopsticks usage of the XCMP protocol, refer to the XCM Testing section of the Chopsticks documentation.</p> <p>After executing the command, the terminal will display output indicating the Polkadot relay chain, the Polkadot Asset Hub, and the Astar parachain are running locally and connected through XCM. You can access them individually via the Polkadot.js Apps interface.</p> <ul> <li>Polkadot Relay Chain</li> <li>Polkadot Asset Hub</li> <li>Astar Parachain</li> </ul>"},{"location":"tutorials/polkadot-sdk/system-chains/asset-hub/register-local-asset/","title":"Register a Local Asset on Asset Hub","text":""},{"location":"tutorials/polkadot-sdk/system-chains/asset-hub/register-local-asset/#introduction","title":"Introduction","text":"<p>As detailed in the Asset Hub Overview page, Asset Hub accommodates two types of assets: local and foreign. Local assets are those that were created in Asset Hub and are identifiable by an integer ID. On the other hand, foreign assets originate from a sibling parachain and are identified by a Multilocation.</p> <p>This guide will take you through the steps of registering a local asset on the Asset Hub parachain.</p>"},{"location":"tutorials/polkadot-sdk/system-chains/asset-hub/register-local-asset/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have access to the Polkadot.js Apps interface and a funded wallet with DOT or KSM.</p> <ul> <li>For Polkadot Asset Hub, you would need a deposit of 10 DOT and around 0.201 DOT for the metadata</li> <li>For Kusama Asset Hub, the deposit is 0.1 KSM and around 0.000669 KSM for the metadata</li> </ul> <p>You need to ensure that your Asset Hub account balance is a bit more than the sum of those two deposits, which should seamlessly account for the required deposits and transaction fees.</p>"},{"location":"tutorials/polkadot-sdk/system-chains/asset-hub/register-local-asset/#steps-to-register-a-local-asset","title":"Steps to Register a Local Asset","text":"<p>To register a local asset on the Asset Hub parachain, follow these steps:</p> <ol> <li> <p>Open the Polkadot.js Apps interface and connect to the Asset Hub parachain using the network selector in the top left corner </p> <ul> <li>You may prefer to test local asset registration on TestNet before registering the asset on a MainNet hub. If you still need to set up a local testing environment, review the Environment setup section for instructions. Once the local environment is set up, connect to the Local Node (Chopsticks) available on <code>ws://127.0.0.1:8000</code></li> <li>For the live network, connect to the Asset Hub parachain. Either Polkadot or Kusama Asset Hub can be selected from the dropdown list, choosing the desired RPC provider</li> </ul> </li> <li> <p>Click on the Network tab on the top navigation bar and select Assets from the dropdown list</p> <p></p> </li> <li> <p>Now, you need to examine all the registered asset IDs. This step is crucial to ensure that the asset ID you are about to register is unique. Asset IDs are displayed in the assets column</p> <p></p> </li> <li> <p>Once you have confirmed that the asset ID is unique, click on the Create button on the top right corner of the page</p> <p></p> </li> <li> <p>Fill in the required fields in the Create Asset form:</p> <ol> <li>creator account - the account to be used for creating this asset and setting up the initial metadata</li> <li>asset name - the descriptive name of the asset you are registering</li> <li>asset symbol - the symbol that will be used to represent the asset</li> <li>asset decimals - the number of decimal places for this token, with a maximum of 20 allowed through the user interface</li> <li>minimum balance - the minimum balance for the asset. This is specified in the units and decimals as requested</li> <li>asset ID - the selected id for the asset. This should not match an already-existing asset id</li> <li>Click on the Next button</li> </ol> <p></p> </li> <li> <p>Choose the accounts for the roles listed below:</p> <ol> <li>admin account - the account designated for continuous administration of the token      </li> <li>issuer account - the account that will be used for issuing this token</li> <li>freezer account - the account that will be used for performing token freezing operations</li> <li>Click on the Create button</li> </ol> <p></p> </li> <li> <p>Click on the Sign and Submit button to complete the asset registration process</p> <p></p> </li> </ol>"},{"location":"tutorials/polkadot-sdk/system-chains/asset-hub/register-local-asset/#verify-asset-registration","title":"Verify Asset Registration","text":"<p>After completing these steps, the asset will be successfully registered. You can now view your asset listed on the Assets section of the Polkadot.js Apps interface.</p> <p></p> <p>Note</p> <p>Take into consideration that the Assets section\u2019s link may differ depending on the network you are using. For the local environment, enter <code>ws://127.0.0.1:8000</code> into the Custom Endpoint field.</p> <p>In this way, you have successfully registered a local asset on the Asset Hub parachain.</p> <p>For an in-depth explanation of Asset Hub and its features, please refer to the Polkadot Wiki page on Asset Hub.</p>"},{"location":"tutorials/polkadot-sdk/system-chains/asset-hub/register-local-asset/#test-setup-environment","title":"Test Setup Environment","text":"<p>You can set up a local parachain environment to test the asset registration process before deploying it on the live network. This guide uses Chopsticks to simulate that process. For further information on chopsticks usage, refer to the Chopsticks documentation.</p> <p>To set up a test environment, execute the following command:</p> <pre><code>npx @acala-network/chopsticks \\\n--config=https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/polkadot-asset-hub.yml\n</code></pre> <p>Note</p> <p>The above command will spawn a lazy fork of Polkadot Asset Hub with the latest block data from the network. If you need to test Kusama Asset Hub, replace <code>polkadot-asset-hub.yml</code> with <code>kusama-asset-hub.yml</code> in the command.</p> <p>An Asset Hub instance is now running locally, and you can proceed with the asset registration process. Note that the local registration process does not differ from the live network process. Once you have a successful TestNet transaction, you can use the same steps to register the asset on MainNet.</p>"},{"location":"tutorials/polkadot-sdk/testing/","title":"Blockchain Testing Tutorials","text":"<p>Follow hands-on tutorials to set up, test, and validate the functionality of Polkadot-SDK blockchains, using tools and methods that streamline testing.</p>"},{"location":"tutorials/polkadot-sdk/testing/#in-this-section","title":"In This Section","text":"<p>:::INSERT_IN_THIS_SECTION:::</p>"},{"location":"tutorials/polkadot-sdk/testing/fork-live-chains/","title":"Fork a Chain with Chopsticks","text":""},{"location":"tutorials/polkadot-sdk/testing/fork-live-chains/#introduction","title":"Introduction","text":"<p>Chopsticks is an innovative tool that simplifies the process of forking live Polkadot SDK chains. This guide provides step-by-step instructions to configure and fork chains, enabling developers to:</p> <ul> <li>Replay blocks for state analysis</li> <li>Test cross-chain messaging (XCM)</li> <li>Simulate blockchain environments for debugging and experimentation</li> </ul> <p>With support for both configuration files and CLI commands, Chopsticks offers flexibility for diverse development workflows. Whether you're testing locally or exploring complex blockchain scenarios, Chopsticks empowers developers to gain deeper insights and accelerate application development.</p> <p>For additional support and information, please reach out through GitHub Issues.</p> <p>Note</p> <p>Chopsticks uses Smoldot light client, which only supports the native Polkadot SDK API. As a result, Ethereum JSON-RPC calls are not supported, and tools like Metamask cannot connect to Chopsticks-based forks.</p>"},{"location":"tutorials/polkadot-sdk/testing/fork-live-chains/#prerequisites","title":"Prerequisites","text":"<p>To follow this tutorial, ensure you have completed the following:</p> <ul> <li>Installed Chopsticks - if you still need to do so, see the Install Chopsticks guide for assistance</li> <li>Reviewed Configure Chopsticks - and understand how forked chains are configured</li> </ul>"},{"location":"tutorials/polkadot-sdk/testing/fork-live-chains/#configuration-file","title":"Configuration File","text":"<p>To run Chopsticks using a configuration file, utilize the <code>--config</code> flag. You can use a raw GitHub URL, a path to a local file, or simply the chain's name. The following commands all look different but they use the <code>polkadot</code> configuration in the same way:</p> GitHub URLLocal File PathChain Name <pre><code>npx @acala-network/chopsticks \\\n--config=https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/polkadot.yml\n</code></pre> <pre><code>npx @acala-network/chopsticks --config=configs/polkadot.yml\n</code></pre> <pre><code>npx @acala-network/chopsticks --config=polkadot\n</code></pre> <p>Regardless of which method you choose from the preceding examples, you'll see an output similar to the following:</p> npx @acala-network/chopsticks --config=polkadot [18:38:26.155] INFO: Loading config file https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/polkadot.yml  app: \"chopsticks\"  chopsticks::executor TRACE: Calling Metadata_metadata  chopsticks::executor TRACE: Completed Metadata_metadata [18:38:28.186] INFO: Polkadot RPC listening on port 8000  app: \"chopsticks\" <p>Note</p> <p>If using a file path, make sure you've downloaded the Polkadot configuration file, or have created your own.</p>"},{"location":"tutorials/polkadot-sdk/testing/fork-live-chains/#create-a-fork","title":"Create a Fork","text":"<p>Once you've configured Chopsticks, use the following command to fork Polkadot at block 100:</p> <pre><code>npx @acala-network/chopsticks \\\n--endpoint wss://polkadot-rpc.dwellir.com \\\n--block 100\n</code></pre> <p>If the fork is successful, you will see output similar to the following:</p> npx @acala-network/chopsticks \\ --endpoint wss://polkadot-rpc.dwellir.com \\ --block 100 [19:12:21.023] INFO: Polkadot RPC listening on port 8000  app: \"chopsticks\" <p>Access the running Chopsticks fork using the default address.</p> <pre><code>ws://localhost:8000\n</code></pre>"},{"location":"tutorials/polkadot-sdk/testing/fork-live-chains/#interact-with-a-fork","title":"Interact with a Fork","text":"<p>You can interact with the forked chain using various libraries such as Polkadot.js and its user interface, Polkadot.js Apps.</p>"},{"location":"tutorials/polkadot-sdk/testing/fork-live-chains/#use-polkadotjs-apps","title":"Use Polkadot.js Apps","text":"<p>To interact with Chopsticks via the hosted user interface, visit Polkadot.js Apps and follow these steps:</p> <ol> <li> <p>Select the network icon in the top left corner</p> <p></p> </li> <li> <p>Scroll to the bottom and select Development</p> </li> <li>Choose Custom</li> <li>Enter <code>ws://localhost:8000</code> in the input field</li> <li> <p>Select the Switch button</p> <p></p> </li> </ol> <p>You should now be connected to your local fork and can interact with it as you would with a real chain.</p>"},{"location":"tutorials/polkadot-sdk/testing/fork-live-chains/#use-polkadotjs-library","title":"Use Polkadot.js Library","text":"<p>For programmatic interaction, you can use the Polkadot.js library. The following is a basic example:</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nasync function connectToFork() {\n  const wsProvider = new WsProvider('ws://localhost:8000');\n  const api = await ApiPromise.create({ provider: wsProvider });\n  await api.isReady;\n\n  // Now you can use 'api' to interact with your fork\n  console.log(`Connected to chain: ${await api.rpc.system.chain()}`);\n}\n\nconnectToFork();\n</code></pre>"},{"location":"tutorials/polkadot-sdk/testing/fork-live-chains/#replay-blocks","title":"Replay Blocks","text":"<p>Chopsticks allows you to replay specific blocks from a chain, which is useful for debugging and analyzing state changes. You can use the parameters in the Configuration section to set up the chain configuration, and then use the run-block subcommand with the following additional options:</p> <ul> <li><code>output-path</code> - path to print output</li> <li><code>html</code> - generate HTML with storage diff</li> <li><code>open</code> - open generated HTML</li> </ul> <p>For example, the command to replay block 1000 from Polkadot and save the output to a JSON file would be as follows:</p> <pre><code>npx @acala-network/chopsticks run-block  \\\n--endpoint wss://polkadot-rpc.dwellir.com  \\\n--output-path ./polkadot-output.json  \\\n--block 1000\n</code></pre> Output file content <pre><code>{\n    \"Call\": {\n        \"result\": \"0xba754e7478944d07a1f7e914422b4d973b0855abeb6f81138fdca35beb474b44a10f6fc59a4d90c3b78e38fac100fc6adc6f9e69a07565ec8abce6165bd0d24078cc7bf34f450a2cc7faacc1fa1e244b959f0ed65437f44208876e1e5eefbf8dd34c040642414245b501030100000083e2cc0f00000000d889565422338aa58c0fd8ebac32234149c7ce1f22ac2447a02ef059b58d4430ca96ba18fbf27d06fe92ec86d8b348ef42f6d34435c791b952018d0a82cae40decfe5faf56203d88fdedee7b25f04b63f41f23da88c76c876db5c264dad2f70c\",\n        \"storageDiff\": [\n            [\n                \"0x0b76934f4cc08dee01012d059e1b83eebbd108c4899964f707fdaffb82636065\",\n                \"0x00\"\n            ],\n            [\n                \"0x1cb6f36e027abb2091cfb5110ab5087f0323475657e0890fbdbf66fb24b4649e\",\n                null\n            ],\n            [\n                \"0x1cb6f36e027abb2091cfb5110ab5087f06155b3cd9a8c9e5e9a23fd5dc13a5ed\",\n                \"0x83e2cc0f00000000\"\n            ],\n            [\n                \"0x1cb6f36e027abb2091cfb5110ab5087ffa92de910a7ce2bd58e99729c69727c1\",\n                null\n            ],\n            [\n                \"0x26aa394eea5630e07c48ae0c9558cef702a5c1b19ab7a04f536c519aca4983ac\",\n                null\n            ],\n            [\n                \"0x26aa394eea5630e07c48ae0c9558cef70a98fdbe9ce6c55837576c60c7af3850\",\n                \"0x02000000\"\n            ],\n            [\n                \"0x26aa394eea5630e07c48ae0c9558cef734abf5cb34d6244378cddbf18e849d96\",\n                \"0xc03b86ae010000000000000000000000\"\n            ],\n            [\n                \"0x26aa394eea5630e07c48ae0c9558cef780d41e5e16056765bc8461851072c9d7\",\n                \"0x080000000000000080e36a09000000000200000001000000000000ca9a3b00000000020000\"\n            ],\n            [\n                \"0x26aa394eea5630e07c48ae0c9558cef78a42f33323cb5ced3b44dd825fda9fcc\",\n                null\n            ],\n            [\n                \"0x26aa394eea5630e07c48ae0c9558cef799e7f93fc6a98f0874fd057f111c4d2d\",\n                null\n            ],\n            [\n                \"0x26aa394eea5630e07c48ae0c9558cef7a44704b568d21667356a5a050c118746d366e7fe86e06375e7030000\",\n                \"0xba754e7478944d07a1f7e914422b4d973b0855abeb6f81138fdca35beb474b44\"\n            ],\n            [\n                \"0x26aa394eea5630e07c48ae0c9558cef7a86da5a932684f199539836fcb8c886f\",\n                null\n            ],\n            [\n                \"0x26aa394eea5630e07c48ae0c9558cef7b06c3320c6ac196d813442e270868d63\",\n                null\n            ],\n            [\n                \"0x26aa394eea5630e07c48ae0c9558cef7bdc0bd303e9855813aa8a30d4efc5112\",\n                null\n            ],\n            [\n                \"0x26aa394eea5630e07c48ae0c9558cef7df1daeb8986837f21cc5d17596bb78d15153cb1f00942ff401000000\",\n                null\n            ],\n            [\n                \"0x26aa394eea5630e07c48ae0c9558cef7df1daeb8986837f21cc5d17596bb78d1b4def25cfda6ef3a00000000\",\n                null\n            ],\n            [\n                \"0x26aa394eea5630e07c48ae0c9558cef7ff553b5a9862a516939d82b3d3d8661a\",\n                null\n            ],\n            [\n                \"0x2b06af9719ac64d755623cda8ddd9b94b1c371ded9e9c565e89ba783c4d5f5f9b4def25cfda6ef3a000000006f3d6b177c8acbd8dc9974cdb3cebfac4d31333c30865ff66c35c1bf898df5c5dd2924d3280e7201\",\n                \"0x9b000000\"\n            ],\n            [\"0x3a65787472696e7369635f696e646578\", null],\n            [\n                \"0x3f1467a096bcd71a5b6a0c8155e208103f2edf3bdf381debe331ab7446addfdc\",\n                \"0x550057381efedcffffffffffffffffff\"\n            ],\n            [\n                \"0x3fba98689ebed1138735e0e7a5a790ab0f41321f75df7ea5127be2db4983c8b2\",\n                \"0x00\"\n            ],\n            [\n                \"0x3fba98689ebed1138735e0e7a5a790ab21a5051453bd3ae7ed269190f4653f3b\",\n                \"0x080000\"\n            ],\n            [\n                \"0x3fba98689ebed1138735e0e7a5a790abb984cfb497221deefcefb70073dcaac1\",\n                \"0x00\"\n            ],\n            [\n                \"0x5f3e4907f716ac89b6347d15ececedca80cc6574281671b299c1727d7ac68cabb4def25cfda6ef3a00000000\",\n                \"0x204e0000183887050ecff59f58658b3df63a16d03a00f92890f1517f48c2f6ccd215e5450e380e00005809fd84af6483070acbb92378e3498dbc02fb47f8e97f006bb83f60d7b2b15d980d000082104c22c383925323bf209d771dec6e1388285abe22c22d50de968467e0bb6ce00b000088ee494d719d68a18aade04903839ea37b6be99552ceceb530674b237afa9166480d0000dc9974cdb3cebfac4d31333c30865ff66c35c1bf898df5c5dd2924d3280e72011c0c0000e240d12c7ad07bb0e7785ee6837095ddeebb7aef84d6ed7ea87da197805b343a0c0d0000\"\n            ],\n            [\n                \"0xae394d879ddf7f99595bc0dd36e355b5bbd108c4899964f707fdaffb82636065\",\n                null\n            ],\n            [\n                \"0xbd2a529379475088d3e29a918cd478721a39ec767bd5269111e6492a1675702a\",\n                \"0x4501407565175cfbb5dca18a71e2433f838a3d946ef532c7bff041685db1a7c13d74252fffe343a960ef84b15187ea0276687d8cb3168aeea5202ea6d651cb646517102b81ff629ee6122430db98f2cadf09db7f298b49589b265dae833900f24baa8fb358d87e12f3e9f7986a9bf920c2fb48ce29886199646d2d12c6472952519463e80b411adef7e422a1595f1c1af4b5dd9b30996fba31fa6a30bd94d2022d6b35c8bc5a8a51161d47980bf4873e01d15afc364f8939a6ce5a09454ab7f2dd53bf4ee59f2c418e85aa6eb764ad218d0097fb656900c3bdd859771858f87bf7f06fc9b6db154e65d50d28e8b2374898f4f519517cd0bedc05814e0f5297dc04beb307b296a93cc14d53afb122769dfd402166568d8912a4dff9c2b1d4b6b34d811b40e5f3763e5f3ab5cd1da60d75c0ff3c12bcef3639f5f792a85709a29b752ffd1233c2ccae88ed3364843e2fa92bdb49021ee36b36c7cdc91b3e9ad32b9216082b6a2728fccd191a5cd43896f7e98460859ca59afbf7c7d93cd48da96866f983f5ff8e9ace6f47ee3e6c6edb074f578efbfb0907673ebca82a7e1805bc5c01cd2fa5a563777feeb84181654b7b738847c8e48d4f575c435ad798aec01631e03cf30fe94016752b5f087f05adf1713910767b7b0e6521013be5370776471191641c282fdfe7b7ccf3b2b100a83085cd3af2b0ad4ab3479448e71fc44ff987ec3a26be48161974b507fb3bc8ad23838f2d0c54c9685de67dc6256e71e739e9802d0e6e3b456f6dca75600bc04a19b3cc1605784f46595bfb10d5e077ce9602ae3820436166aa1905a7686b31a32d6809686462bc9591c0bc82d9e49825e5c68352d76f1ac6e527d8ac02db3213815080afad4c2ecb95b0386e3e9ab13d4f538771dac70d3059bd75a33d0b9b581ec33bb16d0e944355d4718daccb35553012adfcdacb1c5200a2aec3756f6ad5a2beffd30018c439c1b0c4c0f86dbf19d0ad59b1c9efb7fe90906febdb9001af1e7e15101089c1ab648b199a40794d30fe387894db25e614b23e833291a604d07eec2ade461b9b139d51f9b7e88475f16d6d23de6fe7831cc1dbba0da5efb22e3b26cd2732f45a2f9a5d52b6d6eaa38782357d9ae374132d647ef60816d5c98e6959f8858cfa674c8b0d340a8f607a68398a91b3a965585cc91e46d600b1310b8f59c65b7c19e9d14864a83c4ad6fa4ba1f75bba754e7478944d07a1f7e914422b4d973b0855abeb6f81138fdca35beb474b44c7736fc3ab2969878810153aa3c93fc08c99c478ed1bb57f647d3eb02f25cee122c70424643f4b106a7643acaa630a5c4ac39364c3cb14453055170c01b44e8b1ef007c7727494411958932ae8b3e0f80d67eec8e94dd2ff7bbe8c9e51ba7e27d50bd9f52cbaf9742edecb6c8af1aaf3e7c31542f7d946b52e0c37d194b3dd13c3fddd39db0749755c7044b3db1143a027ad428345d930afcefc0d03c3a0217147900bdea1f5830d826f7e75ecd1c4e2bc8fd7de3b35c6409acae1b2215e9e4fd7e360d6825dc712cbf9d87ae0fd4b349b624d19254e74331d66a39657da81e73d7b13adc1e5efa8efd65aa32c1a0a0315913166a590ae551c395c476116156cf9d872fd863893edb41774f33438161f9b973e3043f819d087ba18a0f1965e189012496b691f342f7618fa9db74e8089d4486c8bd1993efd30ff119976f5cc0558e29b417115f60fd8897e13b6de1a48fbeee38ed812fd267ae25bffea0caa71c09309899b34235676d5573a8c3cf994a3d7f0a5dbd57ab614c6caf2afa2e1a860c6307d6d9341884f1b16ef22945863335bb4af56e5ef5e239a55dbd449a4d4d3555c8a3ec5bd3260f88cabca88385fe57920d2d2dfc5d70812a8934af5691da5b91206e29df60065a94a0a8178d118f1f7baf768d934337f570f5ec68427506391f51ab4802c666cc1749a84b5773b948fcbe460534ed0e8d48a15c149d27d67deb8ea637c4cc28240ee829c386366a0b1d6a275763100da95374e46528a0adefd4510c38c77871e66aeda6b6bfd629d32af9b2fad36d392a1de23a683b7afd13d1e3d45dad97c740106a71ee308d8d0f94f6771164158c6cd3715e72ccfbc49a9cc49f21ead8a3c5795d64e95c15348c6bf8571478650192e52e96dd58f95ec2c0fb4f2ccc05b0ab749197db8d6d1c6de07d6e8cb2620d5c308881d1059b50ffef3947c273eaed7e56c73848e0809c4bd93619edd9fd08c8c5c88d5f230a55d2c6a354e5dd94440e7b5bf99326cf4a112fe843e7efdea56e97af845761d98f40ed2447bd04a424976fcf0fe0a0c72b97619f85cf431fe4c3aa6b3a4f61df8bc1179c11e77783bfedb7d374bd1668d0969333cb518bd20add8329462f2c9a9f04d150d60413fdd27271586405fd85048481fc2ae25b6826cb2c947e4231dc7b9a0d02a9a03f88460bced3fef5d78f732684bd218a1954a4acfc237d79ccf397913ab6864cd8a07e275b82a8a72520624738368d1c5f7e0eaa2b445cf6159f2081d3483618f7fc7b16ec4e6e4d67ab5541bcda0ca1af40efd77ef8653e223191448631a8108c5e50e340cd405767ecf932c1015aa8856b834143dc81fa0e8b9d1d8c32278fca390f2ff08181df0b74e2d13c9b7b1d85543416a0dae3a77530b9cd1366213fcf3cd12a9cd3ae0a006d6b29b5ffc5cdc1ab24343e2ab882abfd719892fca5bf2134731332c5d3bef6c6e4013d84a853cb03d972146b655f0f8541bcd36c3c0c8a775bb606edfe50d07a5047fd0fe01eb125e83673930bc89e91609fd6dfe97132679374d3de4a0b3db8d3f76f31bed53e247da591401d508d65f9ee01d3511ee70e3644f3ab5d333ca7dbf737fe75217b4582d50d98b5d59098ea11627b7ed3e3e6ee3012eadd326cf74ec77192e98619427eb0591e949bf314db0fb932ed8be58258fb4f08e0ccd2cd18b997fb5cf50c90d5df66a9f3bb203bd22061956128b800e0157528d45c7f7208c65d0592ad846a711fa3c5601d81bb318a45cc1313b122d4361a7d7a954645b04667ff3f81d3366109772a41f66ece09eb93130abe04f2a51bb30e767dd37ec6ee6a342a4969b8b342f841193f4f6a9f0fac4611bc31b6cab1d25262feb31db0b8889b6f8d78be23f033994f2d3e18e00f3b0218101e1a7082782aa3680efc8502e1536c30c8c336b06ae936e2bcf9bbfb20dd514ed2867c03d4f44954867c97db35677d30760f37622b85089cc5d182a89e29ab0c6b9ef18138b16ab91d59c2312884172afa4874e6989172014168d3ed8db3d9522d6cbd631d581d166787c93209bec845d112e0cbd825f6df8b64363411270921837cfb2f9e7f2e74cdb9cd0d2b02058e5efd9583e2651239654b887ea36ce9537c392fc5dfca8c5a0facbe95b87dfc4232f229bd12e67937d32b7ffae2e837687d2d292c08ff6194a2256b17254748857c7e3c871c3fff380115e6f7faf435a430edf9f8a589f6711720cfc5cec6c8d0d94886a39bb9ac6c50b2e8ef6cf860415192ca4c1c3aaa97d36394021a62164d5a63975bcd84b8e6d74f361c17101e3808b4d8c31d1ee1a5cf3a2feda1ca2c0fd5a50edc9d95e09fb5158c9f9b0eb5e2c90a47deb0459cea593201ae7597e2e9245aa5848680f546256f3\"\n            ],\n            [\n                \"0xd57bce545fb382c34570e5dfbf338f5e326d21bc67a4b34023d577585d72bfd7\",\n                null\n            ],\n            [\n                \"0xd57bce545fb382c34570e5dfbf338f5ea36180b5cfb9f6541f8849df92a6ec93\",\n                \"0x00\"\n            ],\n            [\n                \"0xd57bce545fb382c34570e5dfbf338f5ebddf84c5eb23e6f53af725880d8ffe90\",\n                null\n            ],\n            [\n                \"0xd5c41b52a371aa36c9254ce34324f2a53b996bb988ea8ee15bad3ffd2f68dbda\",\n                \"0x00\"\n            ],\n            [\n                \"0xf0c365c3cf59d671eb72da0e7a4113c49f1f0515f462cdcf84e0f1d6045dfcbb\",\n                \"0x50defc5172010000\"\n            ],\n            [\n                \"0xf0c365c3cf59d671eb72da0e7a4113c4bbd108c4899964f707fdaffb82636065\",\n                null\n            ],\n            [\n                \"0xf68f425cf5645aacb2ae59b51baed90420d49a14a763e1cbc887acd097f92014\",\n                \"0x9501800300008203000082030000840300008503000086030000870300008703000089030000890300008b0300008b0300008d0300008d0300008f0300008f0300009103000092030000920300009403000094030000960300009603000098030000990300009a0300009b0300009b0300009d0300009d0300009f0300009f030000a1030000a2030000a3030000a4030000a5030000a6030000a6030000a8030000a8030000aa030000ab030000ac030000ad030000ae030000af030000b0030000b1030000b1030000b3030000b3030000b5030000b6030000b7030000b8030000b9030000ba030000ba030000bc030000bc030000be030000be030000c0030000c1030000c2030000c2030000c4030000c5030000c5030000c7030000c7030000c9030000c9030000cb030000cc030000cd030000ce030000cf030000d0030000d0030000d2030000d2030000d4030000d4030000d6030000d7030000d8030000d9030000da030000db030000db030000dd030000dd030000df030000e0030000e1030000e2030000e3030000e4030000e4030000\"\n            ],\n            [\n                \"0xf68f425cf5645aacb2ae59b51baed9049b58374218f48eaf5bc23b7b3e7cf08a\",\n                \"0xb3030000\"\n            ],\n            [\n                \"0xf68f425cf5645aacb2ae59b51baed904b97380ce5f4e70fbf9d6b5866eb59527\",\n                \"0x9501800300008203000082030000840300008503000086030000870300008703000089030000890300008b0300008b0300008d0300008d0300008f0300008f0300009103000092030000920300009403000094030000960300009603000098030000990300009a0300009b0300009b0300009d0300009d0300009f0300009f030000a1030000a2030000a3030000a4030000a5030000a6030000a6030000a8030000a8030000aa030000ab030000ac030000ad030000ae030000af030000b0030000b1030000b1030000b3030000b3030000b5030000b6030000b7030000b8030000b9030000ba030000ba030000bc030000bc030000be030000be030000c0030000c1030000c2030000c2030000c4030000c5030000c5030000c7030000c7030000c9030000c9030000cb030000cc030000cd030000ce030000cf030000d0030000d0030000d2030000d2030000d4030000d4030000d6030000d7030000d8030000d9030000da030000db030000db030000dd030000dd030000df030000e0030000e1030000e2030000e3030000e4030000e4030000\"\n            ]\n        ],\n        \"offchainStorageDiff\": [],\n        \"runtimeLogs\": []\n    }\n}\n</code></pre>"},{"location":"tutorials/polkadot-sdk/testing/fork-live-chains/#xcm-testing","title":"XCM Testing","text":"<p>To test XCM (Cross-Consensus Messaging) messages between networks, you can fork multiple parachains and a relay chain locally using Chopsticks.</p> <ul> <li><code>relaychain</code> - relay chain config file</li> <li><code>parachain</code> - parachain config file  </li> </ul> <p>For example, to fork Moonbeam, Astar, and Polkadot enabling XCM between them, you can use the following command:</p> <pre><code>npx @acala-network/chopsticks xcm \\\n--r polkadot \\\n--p moonbeam \\\n--p astar\n</code></pre> <p>After running it, you should see output similar to the following:</p> npx @acala-network/chopsticks xcm \\ --r polkadot \\ --p moonbeam \\ --p astar [13:46:07.901] INFO: Loading config file https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/moonbeam.yml  app: \"chopsticks\" [13:46:12.631] INFO: Moonbeam RPC listening on port 8000  app: \"chopsticks\" [13:46:12.632] INFO: Loading config file https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/astar.yml  app: \"chopsticks\"  chopsticks::executor TRACE: Calling Metadata_metadata  chopsticks::executor TRACE: Completed Metadata_metadata [13:46:23.669] INFO: Astar RPC listening on port 8001  app: \"chopsticks\" [13:46:25.144] INFO (xcm): Connected parachains [2004,2006]  app: \"chopsticks\" [13:46:25.144] INFO: Loading config file https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/polkadot.yml  app: \"chopsticks\"  chopsticks::executor TRACE: Calling Metadata_metadata  chopsticks::executor TRACE: Completed Metadata_metadata [13:46:53.320] INFO: Polkadot RPC listening on port 8002  app: \"chopsticks\" [13:46:54.038] INFO (xcm): Connected relaychain 'Polkadot' with parachain 'Moonbeam'  app: \"chopsticks\" [13:46:55.028] INFO (xcm): Connected relaychain 'Polkadot' with parachain 'Astar'  app: \"chopsticks\" <p>Now you can interact with your forked chains using the ports specified in the output.</p>"},{"location":"tutorials/polkadot-sdk/testing/fork-live-chains/#websocket-commands","title":"WebSocket Commands","text":"<p>Chopstick's internal WebSocket server has special endpoints that allow the manipulation of the local Polkadot SDK chain.</p> <p>These are the methods that can be invoked and their parameters:</p> <ul> <li> <p>dev_newBlock (newBlockParams) \u2014 generates one or more new blocks</p> ParametersExample <ul> <li><code>newBlockParams</code> NewBlockParams  - the parameters to build the new block with. Where the <code>NewBlockParams</code> interface includes the following properties:<ul> <li><code>count</code> number - the number of blocks to build</li> <li><code>dmp</code> { msg: string, sentAt: number }[] - the downward messages to include in the block</li> <li><code>hrmp</code> Record&lt;string | number, { data: string, sentAt: number }[]&gt; - the horizontal messages to include in the block</li> <li><code>to</code> number - the block number to build to</li> <li><code>transactions</code> string[] - the transactions to include in the block</li> <li><code>ump</code> Record&lt;number, string[]&gt; - the upward messages to include in the block</li> <li><code>unsafeBlockHeight</code> number - build block using a specific block height (unsafe)</li> </ul> </li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nasync function main() {\n  const wsProvider = new WsProvider('ws://localhost:8000');\n  const api = await ApiPromise.create({ provider: wsProvider });\n  await api.isReady;\n  await api.rpc('dev_newBlock', { count: 1 });\n}\n\nmain();\n</code></pre> </li> <li> <p>dev_setBlockBuildMode (buildBlockMode) \u2014 sets block build mode</p> ParameterExample <ul> <li><code>buildBlockMode</code> BuildBlockMode - the build mode. Can be any of the following modes:     <pre><code>export enum BuildBlockMode {\n  Batch = 'Batch', /** One block per batch (default) */\n  Instant = 'Instant', /** One block per transaction */\n  Manual = 'Manual', /** Only build when triggered */\n}\n</code></pre></li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nasync function main() {\n  const wsProvider = new WsProvider('ws://localhost:8000');\n  const api = await ApiPromise.create({ provider: wsProvider });\n  await api.isReady;\n  await api.rpc('dev_setBlockBuildMode', 'Instant');\n}\n\nmain();\n</code></pre> </li> <li> <p>dev_setHead (hashOrNumber) \u2014 sets the head of the blockchain to a specific hash or number</p> ParameterExample <ul> <li><code>hashOrNumber</code> string | number - the block hash or number to set as head</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nasync function main() {\n  const wsProvider = new WsProvider('ws://localhost:8000');\n  const api = await ApiPromise.create({ provider: wsProvider });\n  await api.isReady;\n  await api.rpc('dev_setHead', 500);\n}\n\nmain();\n</code></pre> </li> <li> <p>dev_setRuntimeLogLevel (runtimeLogLevel) \u2014 sets the runtime log level</p> ParameterExample <ul> <li><code>runtimeLogLevel</code> number - the runtime log level to set</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nasync function main() {\n  const wsProvider = new WsProvider('ws://localhost:8000');\n  const api = await ApiPromise.create({ provider: wsProvider });\n  await api.isReady;\n  await api.rpc('dev_setRuntimeLogLevel', 1);\n}\n\nmain();\n</code></pre> </li> <li> <p>dev_setStorage (values, blockHash) \u2014 creates or overwrites the value of any storage</p> ParametersExample <ul> <li><code>values</code> object - JSON object resembling the path to a storage value</li> <li><code>blockHash</code> string - the block hash to set the storage value</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nimport { Keyring } from '@polkadot/keyring';\nasync function main() {\n  const wsProvider = new WsProvider('ws://localhost:8000');\n  const api = await ApiPromise.create({ provider: wsProvider });\n  await api.isReady;\n  const keyring = new Keyring({ type: 'ed25519' });\n  const bob = keyring.addFromUri('//Bob');\n  const storage = {\n    System: {\n      Account: [[[bob.address], { data: { free: 100000 }, nonce: 1 }]],\n    },\n  };\n  await api.rpc('dev_setStorage', storage);\n}\n\nmain();\n</code></pre> </li> <li> <p>dev_timeTravel (date) \u2014 sets the timestamp of the block to a specific date\"</p> ParameterExample <ul> <li><code>date</code> string - timestamp or date string to set. All future blocks will be sequentially created after this point in time</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nasync function main() {\n  const wsProvider = new WsProvider('ws://localhost:8000');\n  const api = await ApiPromise.create({ provider: wsProvider });\n  await api.isReady;\n  await api.rpc('dev_timeTravel', '2030-08-15T00:00:00');\n}\n\nmain();\n</code></pre> </li> </ul>"},{"location":"tutorials/polkadot-sdk/testing/spawn-basic-chain/","title":"Spawn a Basic Chain with Zombienet","text":""},{"location":"tutorials/polkadot-sdk/testing/spawn-basic-chain/#introduction","title":"Introduction","text":"<p>Zombienet simplifies blockchain development by enabling developers to create temporary, customizable networks for testing and validation. These ephemeral chains are ideal for experimenting with configurations, debugging applications, and validating functionality in a controlled environment.</p> <p>In this guide, you'll learn how to define a basic network configuration file, spawn a blockchain network using Zombienet's CLI, and interact with nodes and monitor network activity using tools like Polkadot.js Apps and Prometheus</p> <p>By the end of this tutorial, you'll be equipped to deploy and test your own blockchain networks, paving the way for more advanced setups and use cases.</p>"},{"location":"tutorials/polkadot-sdk/testing/spawn-basic-chain/#prerequisites","title":"Prerequisites","text":"<p>To successfully complete this tutorial, you must ensure you've first:</p> <ul> <li>Installed Zombienet</li> <li>Reviewed the information in Configure Zombienet and understand how to customize a spawned network</li> </ul>"},{"location":"tutorials/polkadot-sdk/testing/spawn-basic-chain/#define-the-network","title":"Define the Network","text":"<p>Zombienet uses a configuration file to define the ephemeral network that will be spawned. Follow these steps to create and define the configuration file:</p> <ol> <li>Create a file named <code>spawn-a-basic-network.toml</code> <pre><code>touch spawn-a-basic-network.toml\n</code></pre></li> <li>Add the following code to the file you just created: spawn-a-basic-network.toml<pre><code>[settings]\ntimeout = 120\n\n[relaychain]\n\n[[relaychain.nodes]]\nname = \"alice\"\nvalidator = true\n\n[[relaychain.nodes]]\nname = \"bob\"\nvalidator = true\n\n[[parachains]]\nid = 100\n\n[parachains.collator]\nname = \"collator01\"\n</code></pre></li> </ol> <p>This configuration file defines a network with the following chains:</p> <ul> <li>relaychain - with two nodes named <code>alice</code> and <code>bob</code> </li> <li>parachain - with a collator named <code>collator01</code> </li> </ul> <p>Settings also defines a timeout of 120 seconds for the network to be ready.</p>"},{"location":"tutorials/polkadot-sdk/testing/spawn-basic-chain/#spawn-the-network","title":"Spawn the Network","text":"<p>To spawn the network, run the following command:</p> <pre><code>zombienet -p native spawn spawn-a-basic-network.toml\n</code></pre> <p>This command will spawn the network defined in the <code>spawn-a-basic-network.toml</code> configuration file. The <code>-p native</code> flag specifies that the network will be spawned using the native provider.</p> <p>If successful, you will see the following output:</p> zombienet -p native spawn spawn-a-basic-network.toml Network launched \ud83d\ude80\ud83d\ude80 Namespace zombie-75a01b93c92d571f6198a67bcb380fcd Provider native Node Information Name alice Direct Link https://polkadot.js.org/apps/?rpc=ws://127.0.0.1:55308#explorer Prometheus Link http://127.0.0.1:55310/metrics Log Cmd tail -f /tmp/zombie-794af21178672e1ff32c612c3c7408dc_-2397036-6717MXDxcS55/alice.log Node Information Name bob Direct Link https://polkadot.js.org/apps/?rpc=ws://127.0.0.1:55312#explorer Prometheus Link http://127.0.0.1:50634/metrics Log Cmd tail -f /tmp/zombie-794af21178672e1ff32c612c3c7408dc_-2397036-6717MXDxcS55/bob.log Node Information Name collator01 Direct Link https://polkadot.js.org/apps/?rpc=ws://127.0.0.1:55316#explorer Prometheus Link http://127.0.0.1:55318/metrics Log Cmd tail -f /tmp/zombie-794af21178672e1ff32c612c3c7408dc_-2397036-6717MXDxcS55/collator01.log Parachain ID 100 ChainSpec Path /tmp/zombie-794af21178672e1ff32c612c3c7408dc_-2397036-6717MXDxcS55/100-rococo-local.json <p>Note</p> <p>If the IPs and ports aren't explicitly defined in the configuration file, they may change each time the network is started, causing the links provided in the output to differ from the example.</p>"},{"location":"tutorials/polkadot-sdk/testing/spawn-basic-chain/#interact-with-the-spawned-network","title":"Interact with the Spawned Network","text":"<p>After the network is launched, you can interact with it using Polkadot.js Apps. To do so, open your browser and use the provided links listed by the output as <code>Direct Link</code>.</p>"},{"location":"tutorials/polkadot-sdk/testing/spawn-basic-chain/#connect-to-the-nodes","title":"Connect to the Nodes","text":"<p>Use the 55308 port address to interact with the same <code>alice</code> node used for this tutorial. Ports can change from spawn to spawn so be sure to locate the link in the output when spawning your own node to ensure you are accessing the correct port.</p> <p>If you want to interact with the nodes more programmatically, you can also use the Polkadot.js API. For example, the following code snippet shows how to connect to the <code>alice</code> node using the Polkadot.js API and log some information about the chain and node:</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nasync function main() {\n  const wsProvider = new WsProvider('ws://127.0.0.1:55308');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Retrieve the chain &amp; node information via rpc calls\n  const [chain, nodeName, nodeVersion] = await Promise.all([\n    api.rpc.system.chain(),\n    api.rpc.system.name(),\n    api.rpc.system.version(),\n  ]);\n\n  console.log(\n    `You are connected to chain ${chain} using ${nodeName} v${nodeVersion}`,\n  );\n}\n\nmain()\n  .catch(console.error)\n  .finally(() =&gt; process.exit());\n</code></pre> <p>Both methods allow you to interact easily with the network and its nodes.</p>"},{"location":"tutorials/polkadot-sdk/testing/spawn-basic-chain/#check-metrics","title":"Check Metrics","text":"<p>You can also check the metrics of the nodes by accessing the links provided in the output as <code>Prometheus Link</code>. Prometheus is a monitoring and alerting toolkit that collects metrics from the nodes. By accessing the provided links, you can see the metrics of the nodes in a web interface. So, for example, the following image shows the Prometheus metrics for Bob's node from the Zombienet test:</p> <p></p>"},{"location":"tutorials/polkadot-sdk/testing/spawn-basic-chain/#check-logs","title":"Check Logs","text":"<p>To view individual node logs, locate the <code>Log Cmd</code> command in Zombienet's startup output. For example, to see what the alice node is doing, find the log command that references <code>alice.log</code> in its file path. Note that Zombienet will show you the correct path for your instance when it starts up, so use that path rather than copying from the below example:</p> <pre><code>tail -f  /tmp/zombie-794af21178672e1ff32c612c3c7408dc_-2397036-6717MXDxcS55/alice.log\n</code></pre> <p>After running this command, you will see the logs of the <code>alice</code> node in real-time, which can be useful for debugging purposes. The logs of the <code>bob</code> and <code>collator01</code> nodes can be checked similarly.</p>"}]}